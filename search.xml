<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>深入分析Dubbo SPI 机制实现原理之实践应用</title>
      <link href="/2022/01/11/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Dubbo%20SPI%20%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8B%E5%AE%9E%E8%B7%B5%E5%BA%94%E7%94%A8/"/>
      <url>/2022/01/11/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90Dubbo%20SPI%20%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B9%8B%E5%AE%9E%E8%B7%B5%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="深入分析Dubbo-SPI-机制实现原理之实践应用"><a href="#深入分析Dubbo-SPI-机制实现原理之实践应用" class="headerlink" title="深入分析Dubbo SPI 机制实现原理之实践应用"></a>深入分析Dubbo SPI 机制实现原理之实践应用</h3><p>​        Dubbo采用”微内核+插件”的方式实现了对扩展开发对修改封闭，有效地将框架的内核与扩展进行了解耦。Dubbo扩展jdk原生的SPI机制，实现依赖注入、AOP、按需创建实例三个核心功能。本文将从JDK原生的SPI机制开始，逐步深入分析Dubbo中的SPI机制。Dubbo中的SPI机制利用了策略模式+工厂模式+单例模式+配置文件，深入理解其原理有利于日常开发写出扩展性更高、耦合度更低的高质量代码。深入分析Dubbo SPI 机制实现原理将分为两篇《深入分析Dubbo SPI 机制实现原理之应用》与《深入分析Dubbo SPI 机制实现原理之源码解读》，《深入分析Dubbo SPI 机制实现原理之实践应用》即本篇侧重分析Dubbo的SPI机制整体如何实现与具体实践应用，《深入分析Dubbo SPI 机制实现原理之源码解读》侧重结合源码深入分析。</p><h4 id="1-JDK-中SPI机制"><a href="#1-JDK-中SPI机制" class="headerlink" title="1 JDK 中SPI机制"></a>1 JDK 中SPI机制</h4><p>​        SPI (Service Provider Interface) 是jdk中自带的一种服务定义与提供机制。服务定义一般由权威的组织或机构完成，即服务相关的核心接口的定义；服务提供一般由第三方厂商实现，即服务相关的核心接口的具体实现；服务的使用者并不关心不同厂商具体实现的差异，而是按照标准的接口完成实现业务逻辑。SPI中最具代表性的便是JDBC规范，JDK中给出的数据操作的核心接口定义，而像mysql、SQL Server、Oraclet等数据库厂商则提供了具体实现的Connector jar实现。以JDBC为例，JDBC规范定义了Driver接口，而像mysql厂商则提供了具体的Connector jar，并在jar中包含<code>META-INF/services</code>目录，该目录下有一个名为java.sql.Driver的文件，即JDBC规范定义的Driver接口，其内容为mysql厂商的具体实现类：</p><blockquote><p>com.mysql.jdbc.Driver<br>com.mysql.fabric.jdbc.FabricMySQLDriver</p></blockquote><p>在JDBC4规范中，作为使用者只要classpath下面有对应的mysql connector，直接用下面代码便可以获取mysql数据库的连接。</p><pre class="line-numbers language-java"><code class="language-java">Connection conn <span class="token operator">=</span>   DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost:3306/mydb"</span><span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">,</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>同样如果是SQL Server的话，只要修改对应获取Connection的url参数，更改classpath下面connector为SQL Server 就可以获取SQL Server数据库的连接。这样一来就将不同厂商在数据库Driver实现上差别给屏蔽了，达到了关注点分离的目的，业务开发人员只要按照JDBC的规范去写业务逻辑，当然像Mybatis、Hiberante等ORM框架又在JDBC规范上做更多的封装让操作数据库变得更加友好简单。</p><h5 id="1-1-JDK-中SPI如何使用"><a href="#1-1-JDK-中SPI如何使用" class="headerlink" title="1.1 JDK 中SPI如何使用"></a>1.1 JDK 中SPI如何使用</h5><p>可以看到SPI整体可分为三步服务定义、服务提供、服务调用</p><ul><li><p><strong>服务定义</strong> 主要是为服务或功能提供接口的定义与抽象。下面代码是Repository服务的定义。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> example<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Repository</span> <span class="token punctuation">{</span>  <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span>String data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>服务提供</strong> 根据自身特点实现服务定义阶段定义的接口，并在classpath下面创建<code>META-INF/services</code>目录，该目录下有一个文件名与已定义好的接口名一致的文件（如上看到的java.sql.Driver），文件内容为该接口的具体实现类的类名，如果有多个具体实际则换行，一行一个具体实现类的类名。下面代码是Repository服务的不同实现，以及按SPI规则将服务暴露出去。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> example<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MysqlRepository</span> <span class="token keyword">implements</span> <span class="token class-name">Repository</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span>String data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>data <span class="token operator">+</span> <span class="token string">" saved by Mysql Repository!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> example<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MongoDBRepository</span> <span class="token keyword">implements</span> <span class="token class-name">Repository</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span>String data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>data <span class="token operator">+</span> <span class="token string">" saved by MongoDB repository!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>META-INF/services/example.Repository 文件内容如下：</p><blockquote><p>example.MongoDBRepository<br>example.MysqlRepository        </p></blockquote></li><li><p><strong>服务调用</strong> 通过classpath下面引用上面服务提供方实现的具体Jar（如果服务提供与服务调用在同一工程可以直接进行使用），然后通ServiceLoader#load方法加载对应服务，并通过ServiceLoader#iterator方法遍历可用的服务。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//通过load方法加载对应服务</span>ServiceLoader<span class="token operator">&lt;</span>Repository<span class="token operator">></span> serviceLoader <span class="token operator">=</span> ServiceLoader<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>Repository<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//遍历可用的服务</span>Iterator<span class="token operator">&lt;</span>Repository<span class="token operator">></span> iterator <span class="token operator">=</span> serviceLoader<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  Repository repository <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//调用实际服务</span>  repository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token string">"Data"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><h5 id="1-2-JDK-中SPI核心源分析"><a href="#1-2-JDK-中SPI核心源分析" class="headerlink" title="1.2 JDK 中SPI核心源分析"></a>1.2 JDK 中SPI核心源分析</h5><p>​        JDK的SPI的本质是从配置文件中获取接口的具体实现类，然后通过类的全限定名加载类并通过无参数的构造函数反射创建对象。下面结合上面的例子简单的分析一下SPI的核心源码。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//ServiceLoader#load加载服务</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>S<span class="token operator">></span> ServiceLoader<span class="token operator">&lt;</span>S<span class="token operator">></span> <span class="token function">load</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>S<span class="token operator">></span> service<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//获取当前线程的ClassLoader，这个ClassLoader是AppClassLoader</span>  ClassLoader cl <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> ServiceLoader<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>service<span class="token punctuation">,</span> cl<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//ServiceLoader$LazyIterator#nextService 获取下一个可用服务实现，省略无关代码</span><span class="token keyword">private</span> S <span class="token function">nextService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**以上面Repository服务的SPI为例，变量cn实际是保存在META-INF/services/example.Repository  文件中的类名example.MongoDBRepository或example.MysqlRepository每次遍历服务时获取一个**/</span>  String cn <span class="token operator">=</span> nextName<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//参数loader为ServiceLoader#load方法中通过contextClassLoader获取到的AppClassLoader</span>        c <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>cn<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> loader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//省略无关代码...</span>    <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//省略无关代码...</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//通过反射调用类的无参构造函数创建对象</span>        S p <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">cast</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        providers<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>cn<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//省略无关代码...</span>    <span class="token punctuation">}</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        通过前面核心源码的分析，可以看到JDK原生的SPI机制是通过获取配置文件中接口实现类的全限定类名，然后通过反射调用无参数构造函数创建对象来实现服务定义与具体实现的隔离，但对于像Dubbo这像的RPC框架而言JDK原生的SPI机制，显得过于简单与粗暴。虽然SPI机制利用反射隐式地为我们创建对象，但却只能通过无参地构造方法创建对象。如果SPI能像Spring框架中那样具备依赖注入、AOP、按需加载实例是不是能更好地满足Dubbo框架将核心接口定义与具体实现分离的诉求（”微内核+插件” 的诉求）呢？实际Dubbo拓展的SPI机制便实现了依赖注入、AOP、按需加载实例的功能，我仿佛在Dubbo的SPI机制上看到了Spring的身影。</p><h4 id="2-Dubbo中SPI机制概述"><a href="#2-Dubbo中SPI机制概述" class="headerlink" title="2 Dubbo中SPI机制概述"></a>2 Dubbo中SPI机制概述</h4><p>​        有了上面对JDK原生SPI的一个整体认识后，再理解Dubbo中的SPI机制将相对容易很多。Dubbo的拓展的SPI机制核心要解决三件事，即<strong>如何实现按需创建实例、如何实现依赖注入、如何实现AOP</strong>，当然除了这三点外Dubbo的SPI机制还提供超强的自适应拓展机制。在没有分析Dubbo中的SPI机制前，大家可以思考一下如何去实现这三点。本节先整体看一下怎么使用Dubbo中SPI机制提供的各种能力，下一节通过源码深入分析具体实现。    </p><p><strong>注意：后面分析是基于dubbo-2.6.4</strong> </p><h5 id="2-1-Dubbo-中SPI基本用法"><a href="#2-1-Dubbo-中SPI基本用法" class="headerlink" title="2.1 Dubbo 中SPI基本用法"></a>2.1 Dubbo 中SPI基本用法</h5><pre><code>     Dubbo中的SPI机制同样是通过解析配置文件获取接口的具体实现类，然后通过反射完成对象创建与依赖注入，同时在创建对象的过程中会判断是否有Wrapper类的存在来实现AOP功能（本质上Dubbo中的SPI实现AOP是通过静态代理的）。与JDK的SPI机制一样同样可以将整个服务定义到最后调用服务，拆分为三大步。</code></pre><blockquote><p><strong>1、定义服务</strong></p><p>定义服务的核心接口，并在服务接口上加上@SPI注解，如果服务要实现自适应拓展可在接口方法上加上@Adaptive注解或是在接口实现类上加@Adaptive注解（这实际属性提供服务部分）。</p><p><strong>2、提供服务</strong></p><p>实现服务接口，并在META-INF/dubbo/internal/或META-INF/dubbo/或META-INF/services/目录下面创建名为服务接口名的配置文件。配置文件的内容为键值对，key为拓展实现类的键，值为拓展实现类的全限定类名。如果要实现自适应拓展功能可在类上加@Adaptive注解。下面是Dubbo中com.alibaba.dubbo.common.compiler.Compiler 接口实现类对应配置文件的具体内容。</p><pre class="line-numbers language-java"><code class="language-java">adaptive<span class="token operator">=</span>com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>common<span class="token punctuation">.</span>compiler<span class="token punctuation">.</span>support<span class="token punctuation">.</span>AdaptiveCompilerjdk<span class="token operator">=</span>com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>common<span class="token punctuation">.</span>compiler<span class="token punctuation">.</span>support<span class="token punctuation">.</span>JdkCompilerjavassist<span class="token operator">=</span>com<span class="token punctuation">.</span>alibaba<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>common<span class="token punctuation">.</span>compiler<span class="token punctuation">.</span>support<span class="token punctuation">.</span>JavassistCompiler<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>3、调用服务</strong></p><p>与JDK的SPI机制类似，服务实例的创建与调用都有一个核心类负责，Dubbo中该类为ExtensionLoader。通过ExtensionLoader#getExtensionLoader方法获取对应的ExtensionLoader实例，然后再通过Extension的名称调用ExtensionLoader#getExtension方法获取具体的接口实现类，最后调用接口定义的方法完成服务调用 。下面展示了如何通过ExtensionLoader获取Dubbo的Compiler实现类中JavassistCompiler实现，然后调用Compiler#compile方法将源代码编译为字节码并加载到JVM中生成对应的Class类实例。</p><pre class="line-numbers language-java"><code class="language-java">ExtensionLoader<span class="token operator">&lt;</span>Compiler<span class="token operator">></span> loader <span class="token operator">=</span> ExtensionLoader<span class="token punctuation">.</span><span class="token function">getExtensionLoader</span><span class="token punctuation">(</span>Compiler<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//javassist为com.alibaba.dubbo.common.compiler.Compiler文件中JavassistCompiler实现的Key </span>Compiler compiler <span class="token operator">=</span> loader<span class="token punctuation">.</span><span class="token function">getExtension</span><span class="token punctuation">(</span><span class="token string">"javassist"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>compiler<span class="token punctuation">.</span><span class="token function">compile</span><span class="token punctuation">(</span><span class="token string">"resource code ..."</span><span class="token punctuation">,</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></blockquote><p>实际上面调用服务的过程中是通过策略模式实现的，当首次传Extension的名称时ExtensionLoader才会去配置文件中找到相应的限制定类名，并将该类加载到JVM然后通过反射创建对象，创建完后会将创建好的实现缓存在全局的ConcurrentMap中，这个过程完成了实例的按需创建。</p><h5 id="2-2-Dubbo-中SPI自适应拓展用法"><a href="#2-2-Dubbo-中SPI自适应拓展用法" class="headerlink" title="2.2 Dubbo 中SPI自适应拓展用法"></a>2.2 Dubbo 中SPI自适应拓展用法</h5><p>​        Spring中依赖注入与AOP是整个框架的核心精髓，同样Dubbo的SPI中的依赖注入与AOP也是实现”微内核+插件”的精髓。在讲如何使用Dubbo 中SPI自适应拓展时，先来讲一下自适应拓展，因为Dubbo在依赖注入时会用到自适应拓展。自适应拓展是什么？简单地理解就是在拓展接口方法被调用时，先调用一个代理类，然后再由代理类通过策略模式根据运行时传入的参数决定动态哪一个创建扩展实现并最终调用其方法。看起有点像普通的策略模式，通过参数不同然后定位到接口的某一具体实现，但实际上Dubbo的SPI的自适应拓展要更智能点。Dubbo首先会根据调用拓展接口时传入的参数为拓展接口生成具体有代理功能的代码，然后通过javassist 或 jdk 编译这段代码，并将对应的类加载到JVM，最后通过反射创建拓展接口的代理实例。而代理实例内部则采用了普通的策略模式，根据根据调用拓展接口时传入的参数去决定具体要调用哪一个拓展实现。</p><p>​        上面讲到Dubbo的SPI机制会根据调用拓展接口传入的参数决定使用哪一个具体拓展实现类。Dubbo为了形成统一的契约机制，定义了URL模型来完成整个框架中核心参数的传递与获取。URL模型与我们熟悉的URL（Uniform Resource Locators）很类似，这不细讲可以参数Dubbo 官网 <a href="https://dubbo.apache.org/zh/blog/2019/10/17/dubbo-%E4%B8%AD%E7%9A%84-url-%E7%BB%9F%E4%B8%80%E6%A8%A1%E5%9E%8B/">Dubbo 中的 URL 统一模型</a>。在使用自适应拓展时，要接口声明的方法要包括类型为URL参数或者参数内有getURL方法用于获取URL，否则运行时将抛出异常。要从接口声明的方法的参数列表中获取URL，主要是为了通过URL去获取扩展类的键，也就是为了定位具体要调用哪个扩展实现。</p><p>​        自适应拓展使用上与Dubbo中SPI基本用法的区别主要是要在方法上加 @Adapitve注解，同时方法参数列表中要有URL类型参数或者能通过参数的getURL方法获取URL。@Adapitve注解后面分析源时会详细讲，@Adapitve可标注在方法或类上，标注方法表示Dubbo会自动为其生成自适应类（实际就是代理类），标注在类上表示自适应类要人工实现。Dubbbo内部仅有两个类被 Adaptive 注解，分别是 AdaptiveExtensionFactory 和AdaptiveCompiler。来通过一个例子对自适应拓展有更加直观的认识。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> org<span class="token punctuation">.</span>knight<span class="token punctuation">;</span><span class="token annotation punctuation">@SPI</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">EngineMaker</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Adapitve</span>    Engine <span class="token function">makeEngine</span><span class="token punctuation">(</span>URL url<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Dubbo 会为EngineMaker接口生成具体代理功能的代码，下面是Dubbo为EngineMaker接口生成的代理类代码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> org<span class="token punctuation">.</span>knight<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EngineMaker</span>$Adaptive <span class="token keyword">implements</span> <span class="token class-name">EngineMaker</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Wheel <span class="token function">makeEngine</span><span class="token punctuation">(</span>URL url<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>url <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"url == null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">// 1.从 URL 中获取 EngineMaker 名称</span>        String engineMakerName <span class="token operator">=</span> url<span class="token punctuation">.</span><span class="token function">getParameter</span><span class="token punctuation">(</span><span class="token string">"engine.maker"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>engineMakerName <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"engineMakerName == null"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 2.通过 SPI 加载具体的 EngineMaker</span>        EngineMaker engineMaker <span class="token operator">=</span> ExtensionLoader            <span class="token punctuation">.</span><span class="token function">getExtensionLoader</span><span class="token punctuation">(</span>EngineMaker<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getExtension</span><span class="token punctuation">(</span>engineMakerName<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3.调用目标方法</span>        <span class="token keyword">return</span> engineMaker<span class="token punctuation">.</span><span class="token function">makeEngine</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>EngineMaker$Adaptive 是一个代理类，EngineMaker$Adaptive将代理EngineMaker#makeEngine 方法，在makeEngine方法内部通过参数URL获取具体的EngineMaker的拓展实现的扩展名（Dubbo中SPI机制配置文件中的key），再通过SPI加载具体的EngineMaker实现类，最后调用实现类实例的makeEngine 方法。</p><h5 id="2-3-Dubbo-中SPI依赖注入与AOP用法"><a href="#2-3-Dubbo-中SPI依赖注入与AOP用法" class="headerlink" title="2.3 Dubbo 中SPI依赖注入与AOP用法"></a>2.3 Dubbo 中SPI依赖注入与AOP用法</h5><p>​        按照前面说的方式使用Dubbo中的SPI机制去调用具体的扩展实现时，Dubbo的SPI机制内部在加载创建实例后，会检测具体的拓展实现类内部所有的只有一个参数的public的setXXX方法，然后通过ExtensionFactory尝试获取对应的扩展实现并完成依赖注入。下面通过一个详细的例子来看一下，CarMaker的拓展类ElectricCarMaker内部依赖了EngineMaker，并暴露了setEngineMaker方法以便Dubbo注入依赖的EngineMaker。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Engine接口</span><span class="token keyword">package</span> org<span class="token punctuation">.</span>knight<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Engine</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//FuelEngine实现</span><span class="token keyword">package</span> org<span class="token punctuation">.</span>knight<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FuelEngine</span> <span class="token keyword">implements</span> <span class="token class-name">Engine</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token function">FuelEngine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"FuelEngine implementation!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//ElectricEngine实现</span><span class="token keyword">package</span> org<span class="token punctuation">.</span>knight<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ElectricEngine</span> <span class="token keyword">implements</span> <span class="token class-name">Engine</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token function">ElectricEngine</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ElectricEngine implementation!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Car接口</span><span class="token keyword">package</span> org<span class="token punctuation">.</span>knight<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>  <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//ElectricCar实现</span><span class="token keyword">package</span> org<span class="token punctuation">.</span>knight<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ElectricCar</span> <span class="token keyword">implements</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> Engine engine<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token function">ElectricCar</span><span class="token punctuation">(</span>Engine engine<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>engine <span class="token operator">=</span> engine<span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ElectricCar implementation!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ElectricCar run with "</span> <span class="token operator">+</span>  engine<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//CarMaker接口</span><span class="token keyword">package</span> org<span class="token punctuation">.</span>knight<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>common<span class="token punctuation">.</span>URL<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>common<span class="token punctuation">.</span>extension<span class="token punctuation">.</span>SPI<span class="token punctuation">;</span><span class="token annotation punctuation">@SPI</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">CarMaker</span> <span class="token punctuation">{</span>  Car <span class="token function">makeCar</span><span class="token punctuation">(</span>URL url<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//ElectricCarMaker实现</span><span class="token keyword">package</span> org<span class="token punctuation">.</span>knight<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>common<span class="token punctuation">.</span>URL<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ElectricCarMaker</span> <span class="token keyword">implements</span> <span class="token class-name">CarMaker</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> EngineMaker engineMaker<span class="token punctuation">;</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> ElectricCar <span class="token function">makeCar</span><span class="token punctuation">(</span>URL url<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ElectricCar</span><span class="token punctuation">(</span>engineMaker<span class="token punctuation">.</span><span class="token function">makeEngine</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setEngineMaker</span><span class="token punctuation">(</span>EngineMaker engineMaker<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Inject property engineMaker by Dubbo SPI!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>engineMaker <span class="token operator">=</span> engineMaker<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//EngineMaker接口</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>common<span class="token punctuation">.</span>URL<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>common<span class="token punctuation">.</span>extension<span class="token punctuation">.</span>Adaptive<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>common<span class="token punctuation">.</span>extension<span class="token punctuation">.</span>SPI<span class="token punctuation">;</span><span class="token annotation punctuation">@SPI</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">EngineMaker</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//指URL模型要传入的参数名称为engineMakerType或engineType</span>  <span class="token annotation punctuation">@Adaptive</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"engineMakerType"</span><span class="token punctuation">,</span> <span class="token string">"engineType"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  Engine <span class="token function">makeEngine</span><span class="token punctuation">(</span>URL url<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//ElectricEngineMaker实现</span><span class="token keyword">package</span> org<span class="token punctuation">.</span>knight<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>common<span class="token punctuation">.</span>URL<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ElectricEngineMaker</span> <span class="token keyword">implements</span> <span class="token class-name">EngineMaker</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> ElectricEngine <span class="token function">makeEngine</span><span class="token punctuation">(</span>URL url<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ElectricEngine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//FuelEngineMaker实现</span><span class="token keyword">package</span> org<span class="token punctuation">.</span>knight<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>common<span class="token punctuation">.</span>URL<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FuelEngineMaker</span> <span class="token keyword">implements</span> <span class="token class-name">EngineMaker</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> FuelEngine <span class="token function">makeEngine</span><span class="token punctuation">(</span>URL url<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">FuelEngine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>META-INF/services下面有两个配置文件org.knight.CarMaker内容为</p><blockquote><p>electricCarMaker=org.knight.ElectricCarMaker</p></blockquote><p>org.knight.EngineMaker内容为</p><blockquote><p>electricEngineMaker=org.knight.ElectricEngineMaker<br>fuelEngineMaker=org.knight.FuelEngineMaker</p></blockquote><p>执行操作的主函数代码如下</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//主函数</span><span class="token keyword">package</span> org<span class="token punctuation">.</span>knight<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>common<span class="token punctuation">.</span>URL<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>common<span class="token punctuation">.</span>extension<span class="token punctuation">.</span>ExtensionLoader<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Main</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//1、获取对应ExtensionLoader实现</span>    ExtensionLoader<span class="token operator">&lt;</span>CarMaker<span class="token operator">></span> extensionLoader <span class="token operator">=</span> ExtensionLoader<span class="token punctuation">.</span><span class="token function">getExtensionLoader</span><span class="token punctuation">(</span>CarMaker<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//2、通过扩展类的名（配置文件中的key）, 加载并创建对应CarMaker扩展实现（ElectricEngineMaker）。</span>    CarMaker carMaker <span class="token operator">=</span> extensionLoader<span class="token punctuation">.</span><span class="token function">getExtension</span><span class="token punctuation">(</span><span class="token string">"electricCarMaker"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//3、通过URL传递engineMakerType参数，engineMakerType参数的值为electricEngineMaker</span>    URL url <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token number">8080</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addParameter</span><span class="token punctuation">(</span><span class="token string">"engineMakerType"</span><span class="token punctuation">,</span> <span class="token string">"electricEngineMaker"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//4、调用具体扩展实现类的方法（实际调用ElectricEngineMaker#makeCar方法）</span>    Car car <span class="token operator">=</span> carMaker<span class="token punctuation">.</span><span class="token function">makeCar</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//5、执行Car#run方法</span>    car<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码执行完后得出以下结果</p><blockquote><p>Inject property engineMaker by Dubbo SPI!<br>ElectricEngine implementation!<br>ElectricCar implementation!<br>ElectricCar run with class org.knight.ElectricEngine</p></blockquote><p>可以看到Dubbo为CarMaker的拓展类ElectricCarMaker注入了依赖的EngineMaker对象，并且实现注入的EngineMaker类型为ElectricEngineMaker而不是FuelEngineMaker。上面比较关键代码片段是</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@SPI</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">EngineMaker</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//指URL模型要传入的参数名称为engineMakerType或engineType</span>  <span class="token annotation punctuation">@Adaptive</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"engineMakerType"</span><span class="token punctuation">,</span> <span class="token string">"engineType"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  Engine <span class="token function">makeEngine</span><span class="token punctuation">(</span>URL url<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>与</p><pre><code>//3、通过URL传递engineMakerType参数，engineMakerType参数的值为electricEngineMakerURL url = new URL(&quot;&quot;, &quot;&quot;, 8080).addParameter(&quot;engineMakerType&quot;, &quot;electricEngineMaker&quot;);</code></pre><p>EngineMaker#makeEngine方法上的@Adaptive注解的值engineMakerType与engineType规定要通过参数engineMakerType或engineType去URL模型中获取EngineMaker自适应扩展的扩展名。如果URL模型中参数engineMakerType对应的值非空，则Dubbo优先从URL中获取该参数值作为扩展名；否则Dubbo再考虑从URL模型中获取参数engineType，URL模型中参数engineType对应的值非空，则Dubbo从URL中获取参数engineType值作为扩展名；最后Dubbo会采用默认的扩展名，也就是@SPI注解的值作为扩展名作为兜底的扩展名，当然提前是默认的扩展名要存在（上面的情况没有指定默认的扩展名，@SPI(“electricEngineMaker”) 代表将electricEngineMaker作为默认的扩展名）。当所有情况当不符合时，那么Dubbo就无法获取扩展名，也无法完成后面的依赖注入这时会直接抛出异常。Dubbo获取到EngineMaker对应的扩展名后，则会从META-INF/services/org.knight.EngineMaker配置文件中用扩展名去找到具体的全限定类名，并加载类到JVM同时通过反射创建对象，而后再将ElectricEngineMaker实例注入到ElectricCarMaker内。</p><p>​        那如果EngineMaker#makeEngine方法上的@Adaptive注解的值为空时Dubbo会如何处理呢？此时Dubbo会将EngineMaker按其内部规则转化为engine.maker作为URL中扩展名的参数，然后通过该参数即engine.maker去从RUL模型中获取值作为扩展名。再结合@Adaptive注解 value()上的注释体会一下上面的分析。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Adaptive</span> <span class="token punctuation">{</span>    String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>String[] value() default {};上面的注释如下</p><pre class="line-numbers language-java"><code class="language-java">Decide which target extension to be injected<span class="token punctuation">.</span> The name of the target extension is decided by the parameter passed in the URL<span class="token punctuation">,</span> and the parameter names are given by <span class="token keyword">this</span> method<span class="token punctuation">.</span>If the specified parameters are not found from URL<span class="token punctuation">,</span> then the <span class="token keyword">default</span> extension will be used <span class="token keyword">for</span> dependency <span class="token function">injection</span> <span class="token punctuation">(</span>specified in its <span class="token keyword">interface</span>'s SPI<span class="token punctuation">)</span><span class="token punctuation">.</span>For example<span class="token punctuation">,</span> given String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token string">"key1"</span><span class="token punctuation">,</span> <span class="token string">"key2"</span><span class="token punctuation">}</span><span class="token operator">:</span>find parameter <span class="token string">'key1'</span> in URL<span class="token punctuation">,</span> use its value as the extension's name<span class="token keyword">try</span> <span class="token string">'key2'</span> <span class="token keyword">for</span> extension<span class="token string">'s name if '</span>key1' is not <span class="token function">found</span> <span class="token punctuation">(</span>or its value is empty<span class="token punctuation">)</span> in URLuse <span class="token keyword">default</span> extension <span class="token keyword">if</span> <span class="token string">'key2'</span> doesn't exist eitherotherwise<span class="token punctuation">,</span> <span class="token keyword">throw</span> IllegalStateExceptionIf the parameter names are empty<span class="token punctuation">,</span> then a <span class="token keyword">default</span> parameter name is generated from <span class="token keyword">interface</span><span class="token string">'s class name with the rule: divide classname from capital char into several parts, and separate the parts with dot '</span><span class="token punctuation">.</span>'<span class="token punctuation">,</span> <span class="token keyword">for</span> example<span class="token punctuation">,</span> <span class="token keyword">for</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>xxx<span class="token punctuation">.</span>YyyInvokerWrapper<span class="token punctuation">,</span> the generated name is String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token string">"yyy.invoker.wrapper"</span><span class="token punctuation">}</span><span class="token punctuation">.</span>Returns<span class="token operator">:</span>parameter names in URL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以参照下面的流程图，仔细理解一下如何从URL模型中获取扩展名，然后用扩展名去加载类。实际整个流程的核心目标是确定URL模型中获取扩展名的参数名，即通过什么参数从URL模型中获取扩展名。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20220113100031.png"></p><p>Dubbo中SPI机制的依赖注入如何使用已分析完了，下面看看该如何去使用Dubbo中SPI机制的AOP。Spring中的AOP本质上是代理，Dubbo中SPI机制的AOP本质上也是代理，只不过这个代理是静态的，即要先创建代理类然后才能在实际类执行前后作相应的增强。这里先创建EngineMaker的代理类也就是AOP执行类，代码如下。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> org<span class="token punctuation">.</span>knight<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>dubbo<span class="token punctuation">.</span>common<span class="token punctuation">.</span>URL<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EngineMakerWrapper</span> <span class="token keyword">implements</span> <span class="token class-name">EngineMaker</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> EngineMaker engineMaker<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//公共的构建函数参数声明时一定要有被增强的接口作为唯一的参数，这是Dubbo实现AOP的入口</span>  <span class="token keyword">public</span> <span class="token function">EngineMakerWrapper</span><span class="token punctuation">(</span>EngineMaker engineMaker<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>engineMaker <span class="token operator">=</span> engineMaker<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> Engine <span class="token function">makeEngine</span><span class="token punctuation">(</span>URL url<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Before Advice by EngineMakerWrapper!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Engine engine <span class="token operator">=</span> engineMaker<span class="token punctuation">.</span><span class="token function">makeEngine</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"After Advice by EngineMakerWrapper!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> engine<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>AOP类EngineMakerWrapper代理了EngineMaker，并在执行对应makeEngine方法前后加上了简单的增强。现在只要在原来的META-INF/services/org.knight.EngineMaker配置文件中新增一行如下配置便可使AOP功能生效。</p><blockquote><p>engineMakerWrapper=org.knight.EngineMakerWrapper</p></blockquote><p>然后再次执行之前的main函数得到如下的输出。</p><blockquote><p>Inject property engineMaker by Dubbo SPI!<br>Before Advice by EngineMakerWrapper!<br>ElectricEngine implementation!<br>After Advice by EngineMakerWrapper!<br>ElectricCar implementation!<br>ElectricCar run with class org.knight.ElectricEngine</p></blockquote><p>编写Dubbo中SPI机制的AOP对应的代理类时，一定要有公共的构造函数，且构建函数参数声明时一定要有被增强的接口作为唯一的参数，否则Dubbo无法实现AOP，同时在配置文件中要将该代理类加入。虽然在配置文件中通过键值对配置了AOP对应的代理类，但却不能像正常扩展类那样通过扩展名获取到对应的实现。</p><pre class="line-numbers language-java"><code class="language-java">ExtensionLoader<span class="token operator">&lt;</span>EngineMaker<span class="token operator">></span> loader <span class="token operator">=</span> ExtensionLoader<span class="token punctuation">.</span><span class="token function">getExtensionLoader</span><span class="token punctuation">(</span>EngineMaker<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * META-INF/services/org.knight.EngineMaker配置文件有对应的 * engineMakerWrapper=org.knight.EngineMakerWrapper，但获取不到engineMaker，其值为null **/</span>EngineMaker engineMaker <span class="token operator">=</span> loader<span class="token punctuation">.</span><span class="token function">getExtension</span><span class="token punctuation">(</span><span class="token string">"engineMakerWrapper"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码执行后将抛出异常提示<em>No such extension org.knight.EngineMaker by name engineMakerWrapper</em></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​        本文从JDK原生的SPI机制开始由浅及深逐步地介绍了Dubbo中SPI机制，并通过示例展示了如何运用Dubbo中SPI机制的依赖注入、AOP、自适应拓展，本中重点分析了如何从URL模型与自适应拓展注解@Adaptive来确定要最终要获取的扩展类。下篇中将结合源码深入分析了依赖注入、AOP、自适应拓展是如何实现的。希望看完本文你会有所收获，限于本人能力有限文中不正确还望指正。最后欢迎关注个人公众号洞悉源码。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p> <a href="https://dubbo.apache.org/zh/blog/2019/10/17/dubbo-%E4%B8%AD%E7%9A%84-url-%E7%BB%9F%E4%B8%80%E6%A8%A1%E5%9E%8B/">Dubbo 中的 URL 统一模型</a></p><p><a href="https://dubbo.apache.org/zh/docsv2.7/dev/source/dubbo-spi/">Dubbo SPI</a></p><p><a href="https://dubbo.apache.org/zh/docsv2.7/dev/source/adaptive-extension/">SPI 自适应拓展</a></p><h4 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h4><p>​        原创不易，点赞、在看、转发是对我莫大的鼓励，关注公众号洞悉源码是对我最大的支持。同时相信我会分享更多干货，我同你一起成长，我同你一起进步。</p>]]></content>
      
      
      <categories>
          
          <category> Dubbo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
            <tag> SPI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入分析G1垃圾收集器实现原理</title>
      <link href="/2021/12/03/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2021/12/03/%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90G1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="深入分析G1垃圾收集器实现原理"><a href="#深入分析G1垃圾收集器实现原理" class="headerlink" title="深入分析G1垃圾收集器实现原理"></a>深入分析G1垃圾收集器实现原理</h3><h4 id="1-与垃圾收集器有关的算法"><a href="#1-与垃圾收集器有关的算法" class="headerlink" title="1 与垃圾收集器有关的算法"></a>1 与垃圾收集器有关的算法</h4><p>​        在分析G1前先简单回顾一下与垃圾收集器相关的算法。通常所谓的垃圾收集器更多地是指跟踪垃圾收集器（<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection">Tracing Garbage Collection</a>），而不是引用计数（<a href="https://en.wikipedia.org/wiki/Reference_counting">Reference Counting</a> ）垃圾收集器。跟踪垃圾收集器采用可达性分析方法确定哪些对象要被回收，通常会选取一些对象作为GC Roots，如果对象能直接或间接地被GC Roots中的对象引用，则认为该对象可达（存活对象）不能被回收，否则该对象不可达（垃圾对象）要被回收。</p><h5 id="1-1-三色标记算法"><a href="#1-1-三色标记算法" class="headerlink" title="1.1 三色标记算法"></a>1.1 三色标记算法</h5><p>​        在确定内存中哪些对象是垃圾对象时，可以采用最简单的标记算法，即给内存中每个对象一个专门的标记位，被标记则认为是存活对象，否则是垃圾对象，然从GC Roots的对象集合开始递归遍历对象图，如果对象图中的对象能被GC Roots中的对象直接或简接引用则进行标记。理论上该算法可以确定内存中哪些对象是存活的，哪些对象是垃圾，但整个过程应用程序必须暂停，并且要处理所有的内存区域。</p><p>​        为了解决上面的问题，Dijkstra等人在<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.63.4752&rep=rep1&type=pdf">On-the-Fly Garbage Collection: An Exercise in Cooperation</a> 一文中提出了三色标记（<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking">Tri-color Marking</a>）算法。像Go、JavaScript 、Java等语言在内存回收上都采用了三色标记算法的变种。</p><p>​        <strong>三色标记算法会创建白色、灰色、黑色三个集合，三个集合内分别只存储白色对象、灰色对象、黑色对象。白色对象，代表尚未开始标记的对象或已完成标记并确认为垃圾的对象；灰色集合，代表还在标记中的对象，即遍历对象图时已遍历到自己，但还未完成自己引用 对象的遍历；黑色对象，代表已完成标记并确认为存活的对象（正常情况下，对象标记的颜色变化只能白色变成灰色，灰色变成黑色）。起初黑色集合通常为空，灰色集合内为GC Roots直接引用的对象，其他对象均在白色集合内。一个对象任一时刻只能在白色、灰色、黑色三个集合中的某一个。</strong>通常三色标记算法的处理流程如下：</p><blockquote><p>1、起初除GC Roots 外的其他对象全白色集合，将GC Roots直接引用的对象从白色集合内移到灰色集合。</p><p>2、从灰色集合取出一个灰色对象，依次处理该对象引用的对象。若其未引用任何对象，则直接将其移入黑色集合中；若其引用的对象在白色集合中则将其移入灰色集合，否则直接不处理，当该灰色对象引用的对象全处理完后，再将其移入黑色集合中。</p><p>3、重复第2步的流程直到灰色集合为空。</p><p>4、上面的步骤处理完后，GC Roots与黑色集合内的对象为存活对象，而白色集合内的对象为垃圾对象，最后要做的就是将白色集合内的垃圾对象清理。</p></blockquote><p>​        下图展示了除GC Roots 另外有8个对象时，三色标记算法的处理流程。</p><ul><li><p><strong>起初除了GC Roots内的对象外，其他对象全在右则的白色集合中。</strong></p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211227132722.png"></p></li></ul><ul><li><p><strong>将GC Roots直接引用的对象从白色集合内移到灰色集合后，此时A对象与F对象已从白色集移到灰色集合。</strong></p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211227133022.png"></p></li></ul><ul><li><p><strong>处理完灰色集合中的A对象引用的B对象后，此时B对象已从白色集移到灰色集合。</strong></p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211227133518.png"></p></li><li><p><strong>处理完灰色集合中的A对象引用的C对象与D对象后。此时A对象已从灰色集合移到黑色集合，C对象与D对象已从白色集移到灰色集合。</strong></p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211227134814.png"></p></li><li><p><strong>处理灰色集合中剩余的B对象、C对象、D对象与F对象后，B对象、C对象、D对象与F对象象已从灰色集移到黑色集合。</strong></p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211227135310.png"></p></li><li><p><strong>经历过上面的处理后灰色集合已为空，三色标记法标记阶段结束到达清理阶段，白色集合中的E对象、G对象与H对象被清理，最后结果如下图。</strong></p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211227135930.png"></p></li></ul><h5 id="1-2-三色标记算法的不足"><a href="#1-2-三色标记算法的不足" class="headerlink" title="1.2 三色标记算法的不足"></a>1.2 三色标记算法的不足</h5><p>​        如果应用程序线程与三色标记算法的GC线程一起运行，则可能出现对象错标与漏标。<strong>所谓的对象错标是指原为是垃圾的对象被标记为黑色认为是存活的，这种情况的出现并不会引起应用程序的错误，只是会将垃圾收集的时间拖延到下一次垃圾回收。而对象漏标，则是原本要标记为黑色的对象，被遗漏了，没有被标记，最终导致该对象在白色集合中被垃圾回收集给回收掉；这种情况的一旦发生应用程序将出现未知的异常，这个异常可能是无关紧要的也可能是致命的。</strong></p><p>​        以上面的例子来看看漏标是怎么发生的。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211227144710.png"></p><p>假设GC线程准备下一步标记工作前，对象的标记状态如上图。此时GC线程下一步将处理灰色集合中的F对象，由于F对象未引用任何对象其将直接移动到黑色集合中，整体个灰色集合为空标记结束。<strong>可是如果在GC线程还未完成F对象从灰色集合转移到黑色集合的操作时，应用线程正好增加了F对象对G对象的引用呢？</strong></p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211227151639.png"></p><p>​        由于F对象已结束标记工作（实际GC线程已认为F对象是黑色的），F对象最终还是会从灰色集合成功地转移到黑色集合。而GC线程将无法感知应用程序新增加的F对象到G对象的引用，最终导致G对象的漏标。实际上产生漏标一定会满足下面两种情况的一种。</p><blockquote><p>1、GC线程标记的过程中，应用线程增加黑色对象到白色对象的引用 </p><p>2、GC线程标记的过程中，应用线程删除了灰色对象到白色对象的引用</p></blockquote><p>上面的漏标示例实际是第一种情况，论文<a href="https://www.cs.cmu.edu/~fp/courses/15411-f08/misc/wilson94-gc.pdf">Uniprocessor Garbage Collection Techniques</a>  的 3.2.1 Incremental approache小节将处理漏标时关注的点不同将GC分为 Snapshot-at-beginning collectors 与 Incremental update collectors。Snapshot-at-beginning collectors 关注于处理第一种情况，而Incremental update collectors关注于处理第二种情况，G1属于Snapshot-at-beginning collectors，而CMS属于Incremental update collectors。G1并发标记过程关注处理应用线程增加黑色对象到白色对象的引用，即当黑色对象新引用了白色对象时，便将这个黑色对象重新设置为灰（技术实现上采用pre-write barrier） ；而CMS发标记过程关注处理线程删除了灰色对象到白色对象的引用，即当灰色对象删除了白色对象的引用时，便将这个白色对象直接置灰（技术实现上采用post-write barrier）。</p><p>​        那具体采用何种技术手段处理上面的两种情况呢？其实也很简单，就是想办法让GC线程感知对象引用的变化，即所谓的写屏障（write barrier）。这里的所说的写屏障并不是硬件层面的写屏障，而是软件层的写屏障，其实质可理解为在引用赋值这个写操作前加一个切面，根据切点加入时机不同又可分为 pre-write barrier 与post-write barrier，下面是G1中采用的写屏障的伪代码实现（<a href="https://hllvm-group.iteye.com/group/topic/44381">来源于[HotSpot VM] 请教G1算法的原理</a> ）。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">oop_field_store</span><span class="token punctuation">(</span>oop<span class="token operator">*</span> field<span class="token punctuation">,</span> oop new_value<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">pre_write_barrier</span><span class="token punctuation">(</span>field<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// pre-write barrier: for maintaining SATB invariant</span>  <span class="token operator">*</span>field <span class="token operator">=</span> new_value<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// the actual store</span>  <span class="token function">post_write_barrier</span><span class="token punctuation">(</span>field<span class="token punctuation">,</span> new_value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// post-write barrier: for tracking cross-region reference</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>G1中利用pre-write barrier来保证并发标记过程中要处理的SATB（snapshot-at-the-beginning）的完整性（G1  SATB具体如何的实现后面会详细分析），即GC线程在跟踪标记开始阶段生成的对象图快照时，应用线程对该对象图快照的修改能通过pre-write barrier感知。另一方面G1采用post-write barrier来维护并发标记过程中应用线程新产生的需要跟踪的跨区间引用（后面分析G1的RSet时会再补充说明）。</p><h5 id="1-3-对象的清除实现方式"><a href="#1-3-对象的清除实现方式" class="headerlink" title="1.3 对象的清除实现方式"></a>1.3 对象的清除实现方式</h5><p>​        当对象标记结束后，便可以清除对象。而在具体实现时可以采用三种方式标记清除、标记复制、标记压缩算法。标记清除最为简单与高效，其直接将那些垃圾对象清除，但这也带来了内存碎片的问题，同时对象分配时也不得不采用空闲空间列表算法而不能采用高效的指针碰撞算法。标记复制算法通常要额外占用50%的空间，其实现是一直用一半内存存储对象，而另一半内存置空，当回收垃圾时，将已使用空间中仍存活的对象直接复制到置空的那段内存中，然后直接置空之前使用的那半内存。标记压缩算法，兼顾标记清除与标记复制算法的优点，在回收垃圾后会对存活对象进行相应的移动，尽量将碎片化的内存空间进行压缩。</p><h4 id="2-分代垃圾收集器"><a href="#2-分代垃圾收集器" class="headerlink" title="2 分代垃圾收集器"></a>2 分代垃圾收集器</h4><p>​        在分析G1垃圾收集器之前有必要先简单回顾一下HotSpot VM中的其他垃圾收集器。在G1出现之前HotSpot VM中的其他垃圾收集器都是基于新生代与年老代进行垃圾回收的，这些垃圾回收器集统称为分代垃圾。而G1则是兼顾分代与分区的垃圾收集器。</p><h5 id="2-1-分代垃圾收集器垃圾收集过程"><a href="#2-1-分代垃圾收集器垃圾收集过程" class="headerlink" title="2.1 分代垃圾收集器垃圾收集过程"></a>2.1 分代垃圾收集器垃圾收集过程</h5><p>​        分代垃圾收集器将Heap划分为新生代（Young Generation）与年老代 (Old Generation)，在JDK1.8 之前还有永久代（Permanent  Generation）的概念。新生代又被进一步划分为Eden、From Space 、To Space，其中 From Space 与 To Space 大小相等又称作Survivor Spaces。 </p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211223170303.png"></p><p>​        Heap被划分为新生代与年老代是基于弱分代假设的，在java应用程序与其他应用程序中都可以观测到弱分代假设的现象。</p><blockquote><p>1、大多数分配的对象不会被长期引用（被认为是存活的）即他们很年轻就死去。</p><p>2、老对象很少持有来自新对象的引用。</p></blockquote><p>新生代垃圾回收相对频繁，且利用的算法高效快速，因为年轻代空间通常很小并且可能包含许多不再被引用的对象。而年老代垃圾回收频率则相对较低，但由于年老代占用内存相对更多，通常老代垃圾回收将更加耗时。新生代与年老代分别存储不同年龄的对象，通常刚分配内存的对象被存储在新生代，每经过一次垃圾回收如果对象还存活其年龄将加1，当经过多轮垃圾回收后如果对象的年龄超过了MaxTenuringThreshold值，该对象将晋升到年老代。</p><p>​        由于新生代垃圾回收相对更加频繁，新生代垃圾回收更加关注垃圾回收的时效性，通常会采用复制算法或标记清除算法处理垃圾回收。年老代占用内存相对更大，而垃圾回收频繁较低，年老代垃圾回收更加关注垃圾回收的空间性，即垃圾回收后能否释放更多连续的内存，通常会采用压缩算法处理垃圾回收。</p><p>现在来简单看看对象如何在Eden、Survivor与Old Generation之间进行分配与转移的。</p><ul><li><strong>任何新对象都被分配到新生代的Eden空间，当Eden区域无法容纳新对象时，会触发一次Young GC。 最开始时两个Survivor空间都是空（下图是已经过若干次GC的情况）。</strong></li></ul><p><img src="https://gitee.com/0909/blog/raw/master/img/20211223173516.png"></p><ul><li><p><strong>Young GC 过程中Eden空间仍被引用的对象（存活对象）会被复制到第一个Survivor空间（S0 Survivor Space）。 而Eden 空间未被引用的对象将被直接删除。经历过一次Young GC后仍存活的对象，其年龄都会增加1，下图S0 Survivor Space中的对象都只经历一次Young GC，全被标记为1。</strong></p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211223174139.png"></p></li><li><p><strong>下一次Young GC 中仍被引用的对象（存活对象）会被复制到之前是空的Survivor空间（To survivor space ，实际是之前的S1 survivor space），Eden 空间未被引用的对象将被直接删除。 之前的S0 suvivor space现在称为Form survivor space，其中依赖被引用的对象，被复现到了之前是空的Survivor空间（To survivor space ），Form survivor space 未被引用的对象将被直接删除。仍被引用的对象从Form survivor space复制到To survivor space后，其对象年龄将加1，表明该对象又经历了一次Young GC。</strong></p></li></ul><p><img src="https://gitee.com/0909/blog/raw/master/img/20211223174344.png"></p><ul><li><strong>再下一次Young GC 中，会重复上面相同的过程。 但这时Survivor space 角色将进行交换，即From survivor space 变成 To survivor space，To survivor space 变成 From survivor space。这个交换的目的实际就是为了将已使用的Survivor space中仍存活的对象复制到被清空的Survivor space中。</strong></li></ul><p><img src="https://gitee.com/0909/blog/raw/master/img/20211224085233.png"></p><ul><li>**当经历很多次Young GC后新生代中仍存活的对象将会晋升（Promotion）到老年代。下图展示了当MaxTenuringThreshold参数为8 时，仍存活的对象从新生代的From survivor space晋升到老年代。 **</li></ul><p><img src="https://gitee.com/0909/blog/raw/master/img/20211224090307.png"></p><ul><li><p><strong>随着Young GC 的不断发生，新生代中仍存活的对象将不断地晋升到年老代。最终老年代将没有更多的空间容纳新晋升的对象，此时引发Major GC。</strong></p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211224091207.png"></p></li></ul><p>对象分配与晋升时何时会触发GC的详细流程图可以参考下图（参考了《码出高效：Java开发手册》第四章走进JVM中的图）：</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211224112404.png"></p><p>​        上图中没有描绘出 Thread Local Allocation Buffer （TLAB）与 Promotion Local Allocation Buffer （PLAB）的细节。此外上图中的Full GC可能让大家引起歧义，因为和Major GC太容易混淆了。实际JVM规范与垃圾收回相关的文献并没有给Full GC 与 Major GC作定义。一般Full GC认为是对新生代与老年代都进行垃圾回收，而Major GC则是专门针对年老代垃圾进行回收。那问题来了由Young GC 引发了老年代的垃圾回收，是叫Full GC好呢，还是Major GC好呢？个人认为可能Full GC更合适，这个大家可以不用过多纠结这个。实现纠结可以看看这两篇文章<a href="https://plumbr.io/blog/garbage-collection/minor-gc-vs-major-gc-vs-full-gc">Minor GC vs Major GC vs Full GC</a> 与 <a href="https://www.zhihu.com/question/41922036">Major GC和Full GC的区别是什么？触发条件呢？</a>。</p><p>​        上面只简单的描述了分代垃圾收集器垃圾收集的过程，实际垃圾收集器不仅负责了内存的回收工作，同样负责了对象的分配工作。更多的入门内容可以参考<a href="https://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf">Memory Management in the Java HotSpot™ Virtual Machine</a> 、<a href="https://plumbr.io/handbook/garbage-collection-in-java">Plumbr Handbook Java Garbage Collection</a>。如果想再进一步了解垃圾回收相关的东西，还可以看看 《垃圾回收算法手册 自动内存管理的艺术》。</p><h5 id="2-2-串行垃圾收集器"><a href="#2-2-串行垃圾收集器" class="headerlink" title="2.2 串行垃圾收集器"></a>2.2 串行垃圾收集器</h5><p>​        串行垃圾收集器（Serial GC）在进行垃圾回收时只有单个GC线程在进行垃圾回收。通常实现串行垃圾回收器更加简单，串行垃圾回收器内部不用维护复杂的数据结构，内存开销也更加小。但由于在STW（Stop The World）时只有单个GC线程在进行垃圾回收工作，垃圾回收的时间通常都会比较长，并且与应用程序占用的内存呈线性增长。该垃圾回收器比较适合Client端与嵌入设备等占用内存较小的场景。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211224125812.png"></p><p>​        上图灰色箭头为应用线程，而黑色箭头为GC线程，应用线程在工作时通常都是多线程，而到过安全点后应用线程停止工作也叫SWT（Stop The World），串行垃圾回收器将开始一个GC线程完成垃圾回收工作。根据回收分代的不同串行垃圾回收器通常又分为Serial New 与 Serial Old，他们分别负责回收新生代（Young Generation）与年老代（Old Generation）。Serial New采用复制算法完成垃圾清理工作，Serial Old采用压缩算法完成垃圾清理工作。</p><h5 id="2-3-并行垃圾收集器"><a href="#2-3-并行垃圾收集器" class="headerlink" title="2.3 并行垃圾收集器"></a>2.3 并行垃圾收集器</h5><p>​        很显然在多核CPU架构下面垃圾回收时，串行垃圾回收器不能利用多核CPU的优势。因此出行了并行垃圾收集器（Parallel GC），其与串行垃圾回收器最大的差别在于STW时，进行垃圾回收的线程由单个变成了多个。相对于串行垃圾回收器而言，由于垃圾回收的工作被分配给了多个线程，每次进行GC时整体时间将大大下降。并行垃圾回收器工作时，新生代与年老代都会采用线程并行处理垃圾回收工作。与串行垃圾回收器一样，并行垃圾回收器，根据回收分代的不同通常又分为ParNew 与 Parallel Old，他们分别负责回收新生代（Young Generation）与年老代（Old Generation）。同样新生代垃圾回收采用复制算法完成垃圾清理工作，年老代采用压缩算法完成垃圾清理工作。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211224130228.png"></p><p>​        上图灰色箭头为应用线程，而黑色箭头为GC线程，并行垃圾回收器在STW时进行垃圾回收的线程相对于串行垃圾回收器而言变成了多个线程，并且这些线程同时进行垃圾回收工作。</p><h5 id="2-4-并发标记清除垃圾收集器"><a href="#2-4-并发标记清除垃圾收集器" class="headerlink" title="2.4 并发标记清除垃圾收集器"></a>2.4 并发标记清除垃圾收集器</h5><p>​        并发标记清除垃圾收集器 （Concurrent Mark  Sweep，CMS ）是Hotspot VM上真正意义上的并发垃圾回收器。所谓并发（Concurrent）是指GC线程与应用线程一起工作，GC线程工作时不用STW，应用线程也在工作，而通常说的并行（Parallel）是指多个GC线程同时工作，清理垃圾。很多文献中将应用线程叫作Mutator Thread。</p><p>​        CMS 主要负责回收年老代垃圾，使用CMS时新生代垃圾收集工作通常由Serial New 或 ParNew 完成，默认新生代垃圾回收器为ParNew。CMS回收年老代垃圾时，将整体垃圾回收的过程拆分为多个阶段，并且大部分阶段与应用线程都是并发不会发生STW。CMS整体垃圾回收过程可分为初始化标记（ Initial-mark）、并发标记（Concurrent Marking）、并发预清除（Concurrent Pre-cleaning）、重新标记（Remark）、并发清除（Concurrent Sweeping），初始化标记与重新标记都会发生STW，但通常时间都比较短。CMS早其版本中初始化标记与重新标记都是由单线程完成的，后期版本可以通过 -XX:+CMSParallelInitialMark 与 -XX:CMSParallelRemarkEnabled 分别将初始化标记与重新标记阶段指定为多线程。在CMS对年老代进行并发回收时很多可能新生代发生了Young GC，此时年老代垃圾回收将立刻中断，直到Young GC结束后又重新恢复。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211224130703.png"></p><p>​        上图灰色箭头为应用线程，而黑色箭头为GC线程，CMS在Initial-mark阶段开启多个GC线程对GC Root进行标记，该阶段通常时间会比较短。CMS在并发标记与并发预清除阶段同会开启多线程工作，该阶段GC线程与应用线程并发工作。上图中Concurrent Making Pre-cleaning 阶段中长的黑色箭头代表处理Concurrent Making工作的GC线程，短的黑色箭头代表处理Pre-cleaning工作的线程。CMS在重新标记同样开启多个GC线程并且与Initial-mark阶段一样会SWT。CMS在并发清除阶段GC线程与应用线程并发工作。</p><p>​        CMS调优的一个关键问题是如何找出合适的时间让CMS开始并发工作，以便在应用程序耗尽可用的堆空间之前CMS完成所有的并发工作。通常会某次Young GC后开始CMS的并发工作，因为Young GC过后 CMS Initail-mark 要标记的对象通常会更少。CMS另外的一个问题是年老代内存碎片问题，由于CMS在回收年老代时采用了标记清除算法，标记清除算法相对于压缩算法而言执行效率更高，但由于清理垃圾时没有对内存的压缩整理，其不可避免地会出现内存碎片问题。下面二种情况会由于内存碎片问题最终导致concurrent mode failure。</p><blockquote><p>1、Young GC 时，Eden区域存活的对象过大Survivor区域无法存放导致promotion failed，此时对象只能放入年老代，但由于内存碎片问题年老代同样放不下该对象，最后将发生concurrent mode failure，这时会引发Full GC，Full GC会回收整个Heap 空间导致STW时长骤增。</p><p>2、Young GC 时，Survivor 区域存活对象年龄超过了MaxTenuringThreshold，晋升到年老代，但由于内存碎片问题年老代放不下该对象，将发生concurrent mode failure，这时会引发Full GC。</p></blockquote><p>更多关于CMS调优方面的实践可以参考这两篇文章 <a href="https://tech.meituan.com/2020/11/12/java-9-cms-gc.html">Java中9种常见的CMS GC问题分析与解决</a>  与 <a href="https://blog.ragozin.info/2011/06/understanding-gc-pauses-in-jvm-hotspots_02.html">Understanding GC pauses in JVM, HotSpot’s CMS collector</a></p><p>​        下面是一张关于HotSpot VM 中垃圾回收器如何组合分别处理年轻代与年老代的经典图。上面部分的Serial New、ParNew、Parallel Scavenge 都是专门用于处理新生代垃圾收集器，下面部分的CMS、Serial Old、Parallel Old是专门用于处理年老代的垃圾收集器，而处于中间的G1即能处理新生代也能处理年老代。图中的黑色实线代表哪些新生代垃圾收集器能与哪些年老代垃圾收集器组合工作。CMS与Serial Old之间的黑色虚线代表CMS发生concurrent mode failure时fail safe成Full GC采用Serial Old回收年老代垃圾。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211222114547.png"></p><p>​        上面提到的Serial GC（Serial New 与 Serial Old）、Parallel GC（ParNew、Parallel Scavenge、Parallel Old）、CMS，由于新生代与年老代其内存布局是连续的（虚似内存是连续的）这些垃圾收集器在回收垃圾时要么只能处理具体某一个分区要么只能处理整个Heap。这必然会导致垃圾回收的STW时间或多或少与应用程序占用内存线性正相关，即应用程序占用的内存越大在执行垃圾回收时STW时间将越久。前面的垃圾收集器都是分代的垃圾收集器，G1开启了分区垃圾收集器的先河（虽然G1在逻辑上也有新生代与年老代的概念）。G1利用分治的思想将整体Heap划分为一块块大小相等的Region，在内存管理时可以针对这些Region进行管理，而不是笼统地对某个Generation进行管理。由于Region的大小通常远小于Generation，垃圾回收时处理多个Region效率通常高于处理某个Generation。</p><h4 id="3-G1垃圾收集器概述"><a href="#3-G1垃圾收集器概述" class="headerlink" title="3 G1垃圾收集器概述"></a>3 G1垃圾收集器概述</h4><p>​        G1（Garbage First）垃圾收集器是续CMS收集器后的另一款跨时代的垃圾收集器，其开启了分区垃圾收集器的先河。G1通过时间预测模型尽可能地满足用户对暂停时间的要求（用户可以通过-XX:MaxGCPauseMillis=XXX，来指定垃圾收回时最大的暂停时间），G1 利用压缩算法优化回收垃圾更多的分区，所以他被称作垃圾优先（Garbage First）垃圾收集器。</p><h5 id="3-1-G1-垃圾收集中的内存布局"><a href="#3-1-G1-垃圾收集中的内存布局" class="headerlink" title="3.1 G1 垃圾收集中的内存布局"></a>3.1 G1 垃圾收集中的内存布局</h5><p>​        G1与上面介绍的传统分代垃圾收集器一样同样存在Eden Generation、Survivor Generation、Old Generation的概念，但与他们最大的区别在于这些Generation的关系是逻辑上的关系，其各Generation内存布局不会存在连续性。G1 将Heap划分为一个个Region，每个Region的大小为2的N次方，其值在1M到32M之间。每一个Region属于某个Generation，于是有了Eden Region、Survivor Region、Old Region/Tenured Region的概念（不像传统分代垃圾收集器，G1中没有From Survivor 与 To Survivor的概念， 因为G1不管是Young GC、Mix GC、Full GC 对象都是从一个Region转移到另外一个Region或是直接清除）。除此之外G1还有一个专门用于存放大对象的Region（默认对象占用内存超过Region大小二分之一的对象），称为Humongous Region，Humongous Region 可能由多个Region构成，但一个Region最多存放一个大对象，当多个Region用于存放一个特别大的对象这些Region内在布局上是连续的。当经过多次Young GC、Mix GC、Full GC与对象分配后（G1中Young GC、Mix GC、Full GC 相关的东西后面会涉及），Eden Region、Survivor Region、Old Region、Humongous Region之间的角色会转变，即原来存有具体某种Generation对象的Region被清空后可以用来存放Eden对象、Survivor对象、Old 对象或是Humongous对象中的某一种。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211220091224.png"></p><p>​        这种将内存分为一个个Region的内存布局更加有利于内存的回收，垃圾回收集可以采用分治的思想去管理一小块的内存（处理内存的分配与回收），避免了之前版本垃圾回收集在处理Old Generation时只能处理整个Old Generation困局（整个Old Generation一起处理通常非常耗时的，而且这个过程中避免不了STW）。</p><h5 id="3-2-G1-垃圾收集的周期"><a href="#3-2-G1-垃圾收集的周期" class="headerlink" title="3.2 G1 垃圾收集的周期"></a>3.2 G1 垃圾收集的周期</h5><p>​        从全局视角来看，G1收集器回收垃圾的过程是在Young-only 阶段与Space Reclamation阶段之间进行交替的，下图来源于Oracle官网<a href="https://docs.oracle.com/en/java/javase/11/gctuning/garbage-first-garbage-collector.html#GUID-ED3AB6D3-FD9B-4447-9EDF-983ED2F7A573">HotSpot Virtual Machine Garbage Collection Tuning Guide</a> 一文中。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211224132700.png"></p><ul><li><p>Young-only 阶段</p><blockquote><p>Young-only阶段实际包括了多次Young GC 与整个并发标记过程。其从一些普通的Young GC（上图中小的蓝色点代表普通的Young GC）开始，并将满足条件的对象提升到老年代。当年老代占用内存超过阈值时，会触发并发标记阶段，该阈值由参数-XX:InitiatingHeapOccupancyPercent=65%，指定默认值为65%。与此同时G1会开启并发的Young GC（上图中大的蓝色大代表并发的Young GC） ，而不是普通的Young GC。整个并发标记阶段是与普通的Young GC交替的。并发标记阶段又可细分为初始化标记（Initial Marking）、重新标记（Remark）与清理（Cleanup）阶段。初始化标记阶段实际是在并发的Young GC中完成的（文献中通常用piggybacking一词表述）。当初始化标记完成后可能会发生若干的普通Yong GC，才进入Remark阶段（上图中靠上方的黄色小点）。接着并发标记可能被Young GC打断，Young GC结束后再进入Cleanup阶段（上图中靠下方的黄色小点）。</p></blockquote></li><li><p>Space Reclamation 阶段</p><blockquote><p>当Cleanup结束后，G1会进入Space Reclamation 阶段，该阶段由若干次的MixGC组成。每次MixGC都会从之前并发标记阶段标记的对象中选择一部分进行清理，MixGC过程中同时伴随着部分的Young GC（上图中红色的小点代表一次MixGC）。当G1发现清除对象所获取的空间不够多时将停止MixGC，与此同时Space Reclamation 阶段结束。</p></blockquote></li></ul><p>当Space Reclamation 阶段结束后，G1收集周期又重一个Young-only阶段重新开始。Young-only中的普通Young GC的触发条件与前分的分代垃圾收集器Young GC触发条件一致，只不过G1是针对Region处理的，即G1会根据Eden Region中是否有Region能够容纳新对象来决定是否要开启Young GC。作为兜底策略，当G1垃圾回收过程释放的内存不足于满足应用程序中新对象对内存要求时，G1会采用Full GC处理所有Region。</p><h5 id="3-3-记忆集（RSet）"><a href="#3-3-记忆集（RSet）" class="headerlink" title="3.3 记忆集（RSet）"></a>3.3 记忆集（RSet）</h5><p>​        前面已了解到Young GC时只会处理新生代对应的Region即 Eden Region与Survivor Region，这有利于降低每次Young GC的时间。但如果 Eden Region与Survivor Region持有老年代的引用呢，难道在Young GC时，要把Heap中所有的Region都遍历一次才能确定Eden Region与Survivor Region有哪些对象才是垃圾吗？这种方式显然是不可取的，这样一来就会拉长Young GC的时间。</p><p>​        有种有效地方法是新生代的每一个Region都维护一个集合记录一下老年代指进来的（point-in）的跨代引用，这样在Young GC时只要看一下这个point-in的集合就行，这个集合便是所谓的记忆集（Remember Set，RSet）。那年老代里面需要这个RSet吗？前面提到每次Mix GC时会回收部分年老代的Region，如果没有这个记忆集的话和Young GC一样同样避免不了要扫描整个年老代的Region，所以年老代的Region也要维护一个point-in的集合，不过个集合记录是Old Region point-in 过来的集合，至于Young Region point-in 过来的则可以不用管。</p><p>​        那RSet具体实现上又是怎么样的呢？在这之前必须先知道卡表（CardTable），在G1之前CMS中也有CardTable。CardTable本质上是一种point-out数据结构，表示某一区域自己有指向别的区域的引用。在G1中CardTable由byte数组构成，数组的每个元素称之为卡片/卡页（CardPage）。CardTale会映射到整个堆的空间，每个CardPage会对应堆中的512B空间。如下图所示，在一个大小为8GB的堆中，那么CardTable的长度为16777215 (8GB / 512B)；假设-XX:G1HeapRegionSize参数为2MB，即每个Region 大小为2 MB，则每个Region都会对应4096个CardPage。CardTable将占用16MB额外内存空间。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211228111452.png"></p><p>查找一个对象所在的CardPage只需要应用如下公式便可得出。<br>$$<br>CardPageIndex = (对象的地址 – 堆开始地址) ÷ 512<br>$$<br>​        说完CardTable再来看看RSet的具体实现，RSet实际是通过HashMap实现的，该HashMap其key引用了本Region的其他Regionr的地址，value是一个数组，数组的元素是引用方的对象所对应的CardPage在CardTable中的下标。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211228115616.png"></p><p>​        </p><p>如上图所示，区域B中的对象y引用了区域A中的对象x，这个引用关系跨了两个区域。y对象所在的CardPage为179，在区域A的RSet中，以区域B的地址作为key，b对象所在CardPage下标79为value记录了这个引用关系，这样就完成了这个跨区域引用的记录。不过这个CardTable的粒度有点粗，毕竟一个CardPage有512B，在一个CardPage内可能会存在多个对象。所以在扫描标记时，需要扫描RSet中关联的整个CardPage，上图的例子是要把CardTable下标为79的CardPage都扫描一遍。</p><p>​        实际上HotSpot VM 中 G1的RSet具体实现要比上面说的更加复杂（上面说的只是其中的一种情况，Sparse粒度的情况 ）。应用程序中可能存在频繁的更新引用情况，这会使得某些区域的RSet变成popular Region。G1 采用不同粒度的方式来处理RSet Popularity，RSet可分为Sparse、Fine、Coarse三种粒度。不同粒度时RSet内部采用不同的数据结构记录其他Region point-in 进来的引用 ，上面介绍的便是Sparse粒度时的情况。下面是 <a href="http://www.diva-portal.se/smash/get/diva2:754515/FULLTEXT01.pdf">Evaluating and improving remembered sets in the HotSpot G1 garbage collector</a>论文中给出的G1中 RSet 数据结构的简化定义。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211228153952.png"></p><blockquote><p><strong>1、Sparse Grained (上面g1_rset数据结构中的 saprse)</strong></p><p>稀疏粒度情况时，采用HashMap实现，该HashMap其key引用了本Region的其他Regionr的地址，value是一个数组，数组的元素是引用方的对象所对应的CardPage在CardTable中的下标。</p><p><strong>2、Fine Grained (上面g1_rset数据结构中的 fine_grained)</strong></p><p>细粒度情况时，同样采用HashMap实现，该HashMap其key引用了本Region的其他Regionr的地址，value是一个位图，位图的最大位数代表一个Region最多能被拆分为多少CardPage，位图上值为1则代表Region上CardPage内有对象引用了RSet 所属Region的对象。</p><p><strong>3、Coarse Grained (上面g1_rset数据结构中的 coarse)</strong></p><p>粗粒度情况时，采用位图实现，位图的最大位数代表整个Heap能被拆分为多少个Region。位图上值为1则代表其他Region内有对象引用了RSet 所属Region的对象。因为Region的大小是一样的，可以通过Heap的起始地址，计算出位图中每个Region的起始地址。</p></blockquote><p>G1通常利用Refinement Threads 异步维护RSet，每个线程会利用前面介绍的post-write barrier 将跨代引用与Old Generation 到 Old Generation 的引用记录到各自的local log buffer中，当local log buffer满了之后会刷新到全局的 log buffer中，Refinement Threads 专门处理全局的 log buffer来维护RSet，当Refinement Threads 不能有效地处理全局的log buffer时，应用线程将一起处理 log buffer，但这对应用线程的性能有损耗。当垃圾回收过程中如果全局的log buffer还未处理完，GC线程将处这些log buffer。</p><pre><code>void oop_field_store(oop* field, oop new_value) &#123;  pre_write_barrier(field);             // pre-write barrier: for maintaining SATB invariant  *field = new_value;                   // the actual store  post_write_barrier(field, new_value); // post-write barrier: for tracking cross-region reference&#125;</code></pre><h5 id="3-4-回收集（CSet）"><a href="#3-4-回收集（CSet）" class="headerlink" title="3.4 回收集（CSet）"></a>3.4 回收集（CSet）</h5><p>​        回收集（Collection Set，CSet），其代表每次GC暂停时回收的一系列目标分区。在任意一次收集暂停中，CSet所有分区都会被释放，内部存活的对象都会被转移到分配的空闲分区中。因此无论是年轻代收集，还是混合收集，工作的机制都是一致的。年轻代收集CSet只容纳年轻代分区，而混合收集会通过启发式算法，在老年代候选回收分区中，筛选出回收收益最高的分区添加到CSet中。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211228170601.png"></p><h4 id="4-深入分析G1垃圾收集"><a href="#4-深入分析G1垃圾收集" class="headerlink" title="4 深入分析G1垃圾收集"></a>4 深入分析G1垃圾收集</h4><p>​        前面已简要地介绍了，G1中Heap的内存布局、全局视角下G1的周期、RSet具体实现、CSet等内容，下再更细致地介绍一下G1中的Young GC 阶段、并发标记阶段、Mix GC 阶段。</p><h5 id="4-1-Young-GC阶段"><a href="#4-1-Young-GC阶段" class="headerlink" title="4.1 Young GC阶段"></a>4.1 Young GC阶段</h5><p>​        同分代垃圾回收器一样，当G1中没有Eden Region能够容纳新要创建的对象时，G1中Young GC被触发；同时每个线程都有对应的TLAB，小的对象优先直接在TLAB中创建。前面已了解到G1的Young GC阶段只会回收全部的Young Region，Eden Region 与 Survivor Region；同时如果年老代内存占比超过了指定的阈值时，Young GC会一同完成并发标阶段的初始化标记工作。每次Young GC后，G1会根据当前新生代大小、新生代最小值、新生代最大值、目标暂停时间等重新调整新生代的大小。下面通常Young GC的 GC日志看一下Young GC具体包括那些阶段。JDK的采用的是HotSpot  1.8.0_241版本的JDK，JVM参数如下：</p><blockquote><p>-XX:+UseG1GC -XX:G1HeapRegionSize=2m -Xms2g -Xmx2g -Xloggc:/Users/mac/Desktop/g1log -XX:+PrintGCDetails </p><p>-XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps</p></blockquote><pre class="line-numbers language-java"><code class="language-java"><span class="token number">2021</span><span class="token operator">-</span><span class="token number">12</span><span class="token operator">-</span>29T10<span class="token operator">:</span><span class="token number">03</span><span class="token operator">:</span><span class="token number">58.217</span><span class="token operator">-</span><span class="token number">0800</span><span class="token operator">:</span> <span class="token number">0.244</span><span class="token operator">:</span> <span class="token punctuation">[</span>GC <span class="token function">pause</span> <span class="token punctuation">(</span>G1 Evacuation Pause<span class="token punctuation">)</span> <span class="token punctuation">(</span>young<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0914253</span> secs<span class="token punctuation">]</span>   <span class="token punctuation">[</span>Parallel Time<span class="token operator">:</span> <span class="token number">90.3</span> ms<span class="token punctuation">,</span> GC Workers<span class="token operator">:</span> <span class="token number">8</span><span class="token punctuation">]</span>      <span class="token punctuation">[</span>GC Worker <span class="token function">Start</span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> Min<span class="token operator">:</span> <span class="token number">244.0</span><span class="token punctuation">,</span> Avg<span class="token operator">:</span> <span class="token number">244.1</span><span class="token punctuation">,</span> Max<span class="token operator">:</span> <span class="token number">244.1</span><span class="token punctuation">,</span> Diff<span class="token operator">:</span> <span class="token number">0.1</span><span class="token punctuation">]</span>      <span class="token punctuation">[</span>Ext Root <span class="token function">Scanning</span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> Min<span class="token operator">:</span> <span class="token number">0.1</span><span class="token punctuation">,</span> Avg<span class="token operator">:</span> <span class="token number">0.3</span><span class="token punctuation">,</span> Max<span class="token operator">:</span> <span class="token number">0.7</span><span class="token punctuation">,</span> Diff<span class="token operator">:</span> <span class="token number">0.7</span><span class="token punctuation">,</span> Sum<span class="token operator">:</span> <span class="token number">2.2</span><span class="token punctuation">]</span>      <span class="token punctuation">[</span>Update <span class="token function">RS</span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> Min<span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> Avg<span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> Max<span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> Diff<span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> Sum<span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">]</span>         <span class="token punctuation">[</span>Processed Buffers<span class="token operator">:</span> Min<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> Avg<span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> Max<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> Diff<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> Sum<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">]</span>      <span class="token punctuation">[</span>Scan <span class="token function">RS</span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> Min<span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> Avg<span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> Max<span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> Diff<span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> Sum<span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">]</span>      <span class="token punctuation">[</span>Code Root <span class="token function">Scanning</span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> Min<span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> Avg<span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> Max<span class="token operator">:</span> <span class="token number">0.2</span><span class="token punctuation">,</span> Diff<span class="token operator">:</span> <span class="token number">0.2</span><span class="token punctuation">,</span> Sum<span class="token operator">:</span> <span class="token number">0.2</span><span class="token punctuation">]</span>      <span class="token punctuation">[</span>Object <span class="token function">Copy</span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> Min<span class="token operator">:</span> <span class="token number">89.1</span><span class="token punctuation">,</span> Avg<span class="token operator">:</span> <span class="token number">89.6</span><span class="token punctuation">,</span> Max<span class="token operator">:</span> <span class="token number">89.8</span><span class="token punctuation">,</span> Diff<span class="token operator">:</span> <span class="token number">0.7</span><span class="token punctuation">,</span> Sum<span class="token operator">:</span> <span class="token number">716.5</span><span class="token punctuation">]</span>      <span class="token punctuation">[</span><span class="token function">Termination</span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> Min<span class="token operator">:</span> <span class="token number">0.0</span><span class="token punctuation">,</span> Avg<span class="token operator">:</span> <span class="token number">0.1</span><span class="token punctuation">,</span> Max<span class="token operator">:</span> <span class="token number">0.2</span><span class="token punctuation">,</span> Diff<span class="token operator">:</span> <span class="token number">0.2</span><span class="token punctuation">,</span> Sum<span class="token operator">:</span> <span class="token number">0.8</span><span class="token punctuation">]</span>         <span class="token punctuation">[</span>Termination Attempts<span class="token operator">:</span> Min<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> Avg<span class="token operator">:</span> <span class="token number">1.0</span><span class="token punctuation">,</span> Max<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span> Diff<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">,</span> Sum<span class="token operator">:</span> <span class="token number">8</span><span class="token punctuation">]</span>      <span class="token punctuation">[</span>GC Worker <span class="token function">Other</span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> Min<span class="token operator">:</span> <span class="token number">0.1</span><span class="token punctuation">,</span> Avg<span class="token operator">:</span> <span class="token number">0.2</span><span class="token punctuation">,</span> Max<span class="token operator">:</span> <span class="token number">0.2</span><span class="token punctuation">,</span> Diff<span class="token operator">:</span> <span class="token number">0.1</span><span class="token punctuation">,</span> Sum<span class="token operator">:</span> <span class="token number">1.3</span><span class="token punctuation">]</span>      <span class="token punctuation">[</span>GC Worker <span class="token function">Total</span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> Min<span class="token operator">:</span> <span class="token number">90.1</span><span class="token punctuation">,</span> Avg<span class="token operator">:</span> <span class="token number">90.1</span><span class="token punctuation">,</span> Max<span class="token operator">:</span> <span class="token number">90.2</span><span class="token punctuation">,</span> Diff<span class="token operator">:</span> <span class="token number">0.1</span><span class="token punctuation">,</span> Sum<span class="token operator">:</span> <span class="token number">721.0</span><span class="token punctuation">]</span>      <span class="token punctuation">[</span>GC Worker <span class="token function">End</span> <span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token operator">:</span> Min<span class="token operator">:</span> <span class="token number">334.2</span><span class="token punctuation">,</span> Avg<span class="token operator">:</span> <span class="token number">334.2</span><span class="token punctuation">,</span> Max<span class="token operator">:</span> <span class="token number">334.2</span><span class="token punctuation">,</span> Diff<span class="token operator">:</span> <span class="token number">0.1</span><span class="token punctuation">]</span>   <span class="token punctuation">[</span>Code Root Fixup<span class="token operator">:</span> <span class="token number">0.0</span> ms<span class="token punctuation">]</span>   <span class="token punctuation">[</span>Code Root Purge<span class="token operator">:</span> <span class="token number">0.0</span> ms<span class="token punctuation">]</span>   <span class="token punctuation">[</span>Clear CT<span class="token operator">:</span> <span class="token number">0.1</span> ms<span class="token punctuation">]</span>   <span class="token punctuation">[</span>Other<span class="token operator">:</span> <span class="token number">1.1</span> ms<span class="token punctuation">]</span>      <span class="token punctuation">[</span>Choose CSet<span class="token operator">:</span> <span class="token number">0.0</span> ms<span class="token punctuation">]</span>      <span class="token punctuation">[</span>Ref Proc<span class="token operator">:</span> <span class="token number">0.7</span> ms<span class="token punctuation">]</span>      <span class="token punctuation">[</span>Ref Enq<span class="token operator">:</span> <span class="token number">0.0</span> ms<span class="token punctuation">]</span>      <span class="token punctuation">[</span>Redirty Cards<span class="token operator">:</span> <span class="token number">0.1</span> ms<span class="token punctuation">]</span>      <span class="token punctuation">[</span>Humongous Register<span class="token operator">:</span> <span class="token number">0.1</span> ms<span class="token punctuation">]</span>      <span class="token punctuation">[</span>Humongous Reclaim<span class="token operator">:</span> <span class="token number">0.0</span> ms<span class="token punctuation">]</span>      <span class="token punctuation">[</span>Free CSet<span class="token operator">:</span> <span class="token number">0.0</span> ms<span class="token punctuation">]</span>   <span class="token punctuation">[</span>Eden<span class="token operator">:</span> <span class="token number">102</span><span class="token punctuation">.</span><span class="token function">0M</span><span class="token punctuation">(</span><span class="token number">102</span><span class="token punctuation">.</span>0M<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">.</span><span class="token function">0B</span><span class="token punctuation">(</span><span class="token number">88</span><span class="token punctuation">.</span>0M<span class="token punctuation">)</span> Survivors<span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">.</span>0B<span class="token operator">-</span><span class="token operator">></span><span class="token number">14</span><span class="token punctuation">.</span>0M Heap<span class="token operator">:</span> <span class="token number">102</span><span class="token punctuation">.</span><span class="token function">0M</span><span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">.</span>0M<span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span><span class="token number">98</span><span class="token punctuation">.</span><span class="token function">0M</span><span class="token punctuation">(</span><span class="token number">2048</span><span class="token punctuation">.</span>0M<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>Times<span class="token operator">:</span> user<span class="token operator">=</span><span class="token number">0.12</span> sys<span class="token operator">=</span><span class="token number">0.28</span><span class="token punctuation">,</span> real<span class="token operator">=</span><span class="token number">0.09</span> secs<span class="token punctuation">]</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如上GC日志第一行所示 <strong>GC pause (G1 Evacuation Pause) (young)</strong> 代表本次GC 暂停为G1 的 Young GC。Young GC的工作分为并行工作与其他工作，为别为GC日志中的 <strong>[Parallel Time: 90.3 ms, GC Workers: 8]</strong> 与  **[Other: 1.1 ms]**。并行工作是Young GC的主要工作内容，并行工作被拆分为如下几部分。</p><blockquote><p><strong>1、External Root Scanning（GC日志中的 [Ext Root Scanning (ms): …部分）</strong> </p><p>负责处理扫描指向CSet的外部根，例如寄存器、线程堆栈等。</p><p><strong>2、Update Remembered Sets (RSets) （GC日志中的 [Update RS (ms): …部分）</strong></p><p>负责更新RSet，RSet之前详细介绍过主要是用来记录别的Region point-in 进来的引用。</p><p><strong>3、Processed Buffers（GC日志中的[Processed Buffers: …部分）</strong></p><p>前面说过RSet的维护是通过先写log buffer然后再更新，Processed Buffers 便是处理那些在Young GC开始后还没有被Refinement Thread 处理完的 log buffer，这保证的RSet的完整性。</p><p><strong>4、Scan RSets（GC日志中的[Scan RS (ms): …部分）</strong></p><p>负责扫描RSets中其他Region指向本Region的引用。这个扫描时间会因为RSet 的 Popularity 不同采用不同的粒度的数据结构存储而相差很多；前面介绍过的Coarse Grained时RSet的扫描时间将最耗时。</p><p><strong>5、Code Root Scanning（GC日志中的[Code Root Scanning (ms): …部分）</strong></p><p>负责扫描CSet中已编译源代码的引用根。</p><p><strong>6、Object Copy （GC日志中的[Object Copy (ms): …部分）</strong></p><p>负责将新生代Region，即Eden Region与 Survivor Region中依赖存活的对象复制到未使用的Survivor Region中或者将晋升的对象复制到Old Region中。</p><p><strong>7、Termination （GC日志中的[Termination (ms): …与 [Termination Attempts (ms): …）部分</strong></p><p>当每个GC Work线程完成其自身的工作后，会进行了结束阶段，这时已完成工作的Work 线程会与其他Work线程同步，同时尝试采用工作窃取算法获取还未完成工作的其他线程的工作。Termination Attempts 部分代表Work线程成功获取工作，处理完后再次尝试结束。这个过程其还会再次尝试获取其他未完成工作线程的任务。</p></blockquote><p>其他工作，这部分主要是一些他们的任务包括选择Regino进入CSet、引用处理、引用入列队、重新标记卡页为脏页、释放CSet、处理Humongous对象等。关于G1 GC 日志更详细的解释可以参考<a href="https://www.redhat.com/en/blog/collecting-and-reading-g1-garbage-collector-logs-part-2">Collecting and reading G1 garbage collector logs - part 2</a>。</p><p>​        当年老代内存占比超过了-XX:InitiatingHeapOccupancyPercent指定的阈值，Young  GC会顺便完成并发标记的初始化标记工作。这时在GC日志中将出现 <strong>GC pause (G1 Evacuation Pause) (young) (initial-mark)</strong> 的关键信息，其中的initial-mark 代表在进行Young GC时稍带完成的初始化标记工作。</p><h5 id="4-2-G1中的SATB具体实现"><a href="#4-2-G1中的SATB具体实现" class="headerlink" title="4.2  G1中的SATB具体实现"></a>4.2  G1中的SATB具体实现</h5><p>​        文章的最开始已介绍过垃圾收集器通常会采用Tri-color Marking 算法来处理标记阶段对象引用的分析过程，在处理漏标问题上G1采用了Yuasa在<a href="https://www.semanticscholar.org/paper/Real-time-garbage-collection-on-general-purpose-Yuasa/824abbe901d9caa07d5a7e3cdfccf26da97d2e81">Real-Time Garbage Collection on General Purpose Machines</a> 提出的“snapshot-at-the-beginning” (SATB) 算法。</p><p>​        SATB 算法确保在并发标记开始后所有的垃圾对象都通过快照被识别出来。在并发标记过程中新分配的对象被认为是存活的对象，不用对他们进行追踪分析，这有利于减小标记的开销。G1维护二个用于并发标记的全局bitmap，分别被标记为previous与next。previous位图中保存了前一次并发标记的标记信息，next 位图保存了当前正在进行或刚完成并发标记的标记信息。previous bitmap中上次并发标记的标记信息，在本次本发标记中可以直接使用。同时每个Region都有几个重要的指针 PTAMS（上一次并发标记的起始位置）、NTAMS（下一次并发标记的起始位置）、Bottom（Region的起始地址）、Top（Region已使用地址）、End（Region的结束地址）；TAMS实现是 top at mark start的缩写，也就是每次并发标记会把对应的指针放在Top针指同一位置，代表标志的结束位置 。每次并发标记开始时，NTAMS指针重新指Top指针的位置，当并发标记结束后，NTAMS指针与 PTAMS指针会交位置，next bitmap 与 previous bitmap 交换角色，新的next bitmap 被清空，即原来的 previous bitmap被清空。 </p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211230103620.png"></p><p>上图展示了某次并发标记过程中一个Region中 Bottom、PTAMS、NTAMS、Top、End指针位置，指针之间区域的含义。区间中的白色、灰色、黑色可以大致理解为三色标记法中的三种颜色。</p><blockquote><p><strong>[Bottom, PTAMS) 区间</strong></p><p>该区间代表上次并发标记的区间，PTAMS为上次并发标记的结束位置，该区间上次并发标记的信息能直接被正在进行的并发标记利用，即正在进行的并发标记通过上次bitmap知道该区间哪些是垃圾哪些是存活对象。</p><p><strong>[PTAMS, NTAMS) 区间</strong></p><p>该区间代表本次正在进行的并发标记的区间，NTAMS为本次并发标记的结束位置，在并发标记开始时G1会为[PTAMS, NTAMS) 区间创建一个快照，实际就是next bitmap，然后处理bitmap映射的地址，标记这些地址上的对象是垃圾还是存活的。实际标记过程就是有一个指针从PTAMS指针位置一直移到NTAMS指针位置。</p><p><strong>[NTAMS, Top) 区间</strong></p><p>该区间代表并发标记过程中，应用线程新生成的对象，前面已说过在并发标记过程中新分配的对象被认为是存活的对象，所以上图中该区间全是黑色的。并发标记刚开始时Top指针与NTAMS指针处于同一位置，当应用线程每生成一个新对象时，Top指针就会相应的向End指针的方向右移。</p><p><strong>[Top, End) 区间</strong></p><p>该区间代表Region中还没有使用的空间。</p></blockquote><p>很显然GC线程只会去处理**[PTAMS, NTAMS) 区间<strong>完成标记工作，而应用线程运行则会对</strong>[Bottom, Top)区间<strong>有影响。应用线程对</strong>[Bottom, Top)区间<strong>中</strong>[NTAMS, Top)区间<strong>的影响并不会影响GC线程的并发标记工作，因为该部分应用线程新增的对象都认为是存活的对象。应用线程对</strong>[Bottom, Top)区间<strong>中</strong>[PTAMS, NTAMS)区间<strong>的影响可能会影响GC线程的并发标记工作，G1通过前面介绍的pre-write barrier来确保标记的正确性，即如果应用线程在</strong>[PTAMS, NTAMS)区间<strong>内增加了黑色对象对白色对象的引用，pre-write barrier内部处理时会将白色对象设置为灰色对象，使得该对象能再次被标记不会产生漏标。应用线程对</strong>[Bottom, Top)区间<strong>中</strong>[Bottom, PTAMS)区间**的影响可能会影响GC线程的并发标记工作，具体G1是如何处理这个有待考证，猜测应该也是利用write barrier这里的技术。</p><p>​        有了上面介绍，再看一下 Sun公司 G1的论文<a href="http://cs.williams.edu/~dbarowy/cs334s18/assets/p37-detlefs.pdf">Garbage-First Garbage Collection</a> 中 Initial Marking Pause/Concurrent Marking 小节中的这个图应该会清晰点。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211230131421.png"></p><p>Initial Marking阶段，当Region首次被标记时，PrevBitmap为空，NextBitmap中有**[PrevTAMS, NextTAMS)区间**的块照，并发标记结束后将确定Bitmap中哪些是垃圾对象， PrevTAMS指针与Bottom指针位置相同，NextTAMS指针与Top指针位置相同。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211230132112.png"></p><p>Remark 阶段，**[PrevTAMS, NextTAMS)区间**的存活对象与垃圾对象被标记出来，NextBitmap发生改变其中黑色部分表示标记出来的存活对象，白色部分为垃圾对象。同时由于应用程序生成了新的对象，Top指针的位置从NextTAMS指针处向右移动了。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211230132437.png"></p><p>Cleanup/GC Pauses阶段，NextBitmap 与 PrevBitmap互换角色，同时NextTAMS指针与PrevTAMS指针互换位置。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211230132713.png"></p><p>新一轮标记Initial Marking阶段，NextTAMS指针重新指向Top指针，PrevBitmap保证了上一次的标记信息，NextBitmap中有**[PrevTAMS, NextTAMS)区间**的块照。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211230133029.png"></p><p>新一轮标记Remark阶段，再重复上面B的事情。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211230133359.png"></p><p>新一轮标记Remark阶段，Cleanup/GC Pauses阶段，再重复上面C的事情。</p><h5 id="4-3-并发标记阶段"><a href="#4-3-并发标记阶段" class="headerlink" title="4.3 并发标记阶段"></a>4.3 并发标记阶段</h5><p>​        并发标记阶段主要是将Mix GC时要收集的垃圾对象先进行标记，然后根据Region能释放的内存空间做一下排序，同时其会在标记的最后阶段直接释放那些没有存活对象的Region，并将这些Region加入到可用Region列表中。并发标记阶段可细分为Initial Mark、Root Region Scanning、Concurrent Marking、Remark、Cleanup等等五个阶段。</p><p><strong>Initial Mark 阶段</strong> </p><p>当年老代内存占比超过 -XX:InitiatingHeapOccupancyPercent指定的阈值时会触发并发标记，并发标记的第一个阶段为Initial Mark，该阶段会STW，其只扫描GCRoot直接引用的对象，由于Young GC时也要扫描GCRoot直接引用的对象，Young GC时会顺便完成Initial Mark的工作。GC日志通常会有<strong>GC pause (G1 Evacuation Pause) (young) (initial-mark)</strong> 的关键信息，其中的initial-mark 代表在进行Young GC时顺便完成的初始化标记工作。</p><p><strong>Root Region Scanning 阶段</strong></p><p>实际扫描的是新生代Survivor Region引用的对象，该阶段必须在下次GC暂停前完成，因为Heap要扫描存活对象的话，Survivor Region引用的对象必须先被识别。</p><p><strong>Concurrent Marking 阶段</strong></p><p>并发标记阶段GC线程与应用线程是并发的，同时可以通过-XX:ConcGCThreads指定并行GC线程数。前面已介绍过G1采用pre-write barrier 解决并发标记过种中因为应用线程更新了并发开始阶段创建的对象图的快照导致的漏标问题，每个线程。并发标记阶段会顺带完成每个Region对象的计数工作，方便后面统计哪些Region能回收更多的内存。</p><p><strong>Remark 阶段</strong></p><p>该阶段实际是标记的最后阶段，其会SWT，这个阶段就负责把剩下的引用处理完，该阶段会处理之前SATB write barrier记录的尚未处理引用。但其与与CMS的remark有本质的区别，即G1的Remark的暂停只需要扫描SATB buffer，而CMS的remark需要重新扫描里全部的dirty card 外加整个根集合，而此时整个新生代都会被当作根集合的一部分，因而CMS remark有可能会非常慢。</p><p><strong>Cleanup 阶段</strong></p><p>该阶段会阶段会STW，其主要工作是重置标记状态，如前面介绍的NextBitmap 与 PrevBitmap互换角色，同时NextTAMS指针与PrevTAMS指针互换位置。同时若发现有Region没有存活对象，则会直接将Region清空并将Region加入到空闲Region列表中。当然统计每个Region能回收多少垃圾的统计工作也在这个阶段完成，这样后Mix GC对象转移时便能快速地确定CSet。</p><h5 id="4-4-Mix-GC阶段"><a href="#4-4-Mix-GC阶段" class="headerlink" title="4.4 Mix GC阶段"></a>4.4 Mix GC阶段</h5><p>​        MixGC阶段主要负责回收部分年老代与全部新生代的Region，G1会根据设置的目标暂停时间-XX:MaxGCPauseMillis将并发标记阶段标记好的Region，按其可以释放内存空间大小，依次进行回收，即一个MixGC 阶段会包含多次的MixGC，当G1发现释放垃圾对象获取的内存空间过小时其将停止MixGC。MixGC时在GC日志中将出现**GC pause (G1 Evacuation Pause) (mixed)**的关键信息。作为兜底策略，当G1垃圾回收过程释放的内存不足于满足应用程序中新对象对内存要求时，G1会采用Full GC处理所有Region。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​        本文详细深入地分析了G1垃圾收集器底层的实现原理，虽然没有涉及G1垃圾收集器的具体源码但基本把G1相关的知识都由浅及深地分析了一下。希望看完本文你会有所收获，限于本人能力有限文中不正确还望指正。最后欢迎关注个人公众号洞悉源码。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>Java Performance Companion</p><p>《垃圾回收算法手册自动内存管理的艺术》</p><p><a href="https://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf">Memory Management in the Java HotSpot™ Virtual Machine</a></p><p><a href="https://plumbr.io/handbook/garbage-collection-in-java">Plumbr Handbook Java Garbage Collection</a></p><p><a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html">Java Garbage Collection Basics</a></p><p><a href="https://www.infoq.com/articles/G1-One-Garbage-Collector-To-Rule-Them-All/">G1: One Garbage Collector To Rule Them All</a></p><p><a href="https://docs.oracle.com/en/java/javase/11/gctuning/garbage-first-garbage-collector.html#GUID-ED3AB6D3-FD9B-4447-9EDF-983ED2F7A573">HotSpot Virtual Machine Garbage Collection Tuning Guide</a></p><p><a href="https://www.redhat.com/en/blog/collecting-and-reading-g1-garbage-collector-logs-part-2">Collecting and reading G1 garbage collector logs - part 2</a> </p><p><a href="https://hllvm-group.iteye.com/group/topic/44381">[HotSpot VM] 请教G1算法的原理</a></p><p><a href="https://blog.coderap.com/book/note/36">Java虚拟机07 - 垃圾收集器之G1</a></p><p><a href="http://cs.williams.edu/~dbarowy/cs334s18/assets/p37-detlefs.pdf">Garbage-First Garbage Collection</a></p><p><a href="https://plumbr.io/blog/garbage-collection/minor-gc-vs-major-gc-vs-full-gc">Minor GC vs Major GC vs Full GC</a></p><p><a href="https://www.semanticscholar.org/paper/Real-time-garbage-collection-on-general-purpose-Yuasa/824abbe901d9caa07d5a7e3cdfccf26da97d2e81">Real-Time Garbage Collection on General Purpose Machines</a></p><p><a href="https://www.memorymanagement.org/glossary/t.html#term-tri-color-marking">memorymanagement.org Tri-color Marking</a></p><p><a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Tri-color_marking">Wiki Tri-color Marking</a></p><p><a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.63.4752&rep=rep1&type=pdf">On-the-Fly Garbage Collection: An Exercise in Cooperation</a></p><p><a href="https://www.cs.cmu.edu/~fp/courses/15411-f08/misc/wilson94-gc.pdf">Uniprocessor Garbage Collection Techniques</a></p><p><a href="http://www.diva-portal.se/smash/get/diva2:754515/FULLTEXT01.pdf">Evaluating and improving remembered sets in the<br>HotSpot G1 garbage collector</a></p><p><a href="https://zhuanlan.zhihu.com/p/110079401">面试官问我G1回收器怎么知道你是什么时候的垃圾？</a></p><h4 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h4><p>​        原创不易，点赞、在看、转发是对我莫大的鼓励，关注公众号洞悉源码是对我最大的支持。同时相信我会分享更多干货，我同你一起成长，我同你一起进步。</p>]]></content>
      
      
      <categories>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> G1 </tag>
            
            <tag> Tri-color Marking </tag>
            
            <tag> RSet </tag>
            
            <tag> CSet </tag>
            
            <tag> Refinement Thread </tag>
            
            <tag> Write Barrier </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解JDK9之前的ClassLoader</title>
      <link href="/2021/11/16/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3JDK9%E4%B9%8B%E5%89%8D%E7%9A%84ClassLoader/"/>
      <url>/2021/11/16/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3JDK9%E4%B9%8B%E5%89%8D%E7%9A%84ClassLoader/</url>
      
        <content type="html"><![CDATA[<h3 id="一文详解JDK9之前的ClassLoader"><a href="#一文详解JDK9之前的ClassLoader" class="headerlink" title="一文详解JDK9之前的ClassLoader"></a>一文详解JDK9之前的ClassLoader</h3><p>​        提到类加载器（ClassLoader）也许能让你想起过往开发中遇到的诸如类冲突、ClassNotFoundException、NoClassDefFoundError之类的令人头疼的问题。Google了一下，关于ClassLoader的文章很多，但我还是觉得没有把一些核心的知识点结串再一起，大多数文章停留在介绍双亲委派机制上，而且很多文章都是基于JDK8或之前的版本去分析ClassLoader的，JDK9模块化的引入已将历史的双亲委派机制破坏。今天先总结一下JDK8涉及的知识点与源码，后面再专门针对JDK9中的ClassLoader写一篇分析。下面是本文的总体内容。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211124114341.png"></p><p><strong>注意：后面的涉及到JDK源码分析的部分，若没有明确指出都是JDK8的源码</strong></p><h4 id="1-ClassLoader概述"><a href="#1-ClassLoader概述" class="headerlink" title="1 ClassLoader概述"></a>1 ClassLoader概述</h4><h5 id="1-1-ClassLoader做什么的？"><a href="#1-1-ClassLoader做什么的？" class="headerlink" title="1.1 ClassLoader做什么的？"></a>1.1 ClassLoader做什么的？</h5><p>​        ClassLoader顾名思义他是用来加载类的，ClassLoader的设计源为了满足Java Applet的需求。当Java源代码经过编译后会生成对应的字节码文件（ *.class文件，当然也可按Java语言规范去生成的 *.class文件），这种字节码本质是遵守JVM规范的字节数组。 ClassLoader负责将字节码文件转换成JVM内存中的Class对象（这些字节码文件可以来源本地磁盘文件 *.class、也可以来源Jar包里的  *.class、甚至可以来源于远程服务器的字节流）。通常利用相应的反编译工具便可将  *.class文件转换成源代码文件，通过加密技术能对字节码文件进行密处理，但加密后的字节码文件已不再是遵守JVM规范的字节码数组，其不能被系统类加载器直接加载到JVM中，需要我们自己实现对应的ClassLoader。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Class</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> ClassLoader classLoader<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token function">Class</span><span class="token punctuation">(</span>ClassLoader loader<span class="token punctuation">)</span> <span class="token punctuation">{</span>    classLoader <span class="token operator">=</span> loader<span class="token punctuation">;</span>  <span class="token punctuation">}</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                               <span class="token punctuation">}</span> <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        Class类中有对应的ClassLoader成员变量，用于表明当前Class对象是由哪个ClassLoader加载而来的。<strong>注意：JVM中判断一个类是不是同一个类不是直接通过类的全限定名是否相等来的。两个类要相同其类的全限定名要相同并且要由相同的类加载器加载，否则在作赋值、equals、isAssignableFrom、instanceof等操作时都会出现问题。</strong></p><h5 id="1-2-延迟加载"><a href="#1-2-延迟加载" class="headerlink" title="1.2  延迟加载"></a>1.2  延迟加载</h5><p>​        一个类什么时候被加载到JVM呢？JVM运行时并不是将工程依赖的所有类，一次性全加载到内存实例化成Class对象，而是按需加载，也称延迟加载。程序在运行过程中会逐步加载其需要用到的类，一个类一旦被ClassLoader加载过后就会缓存在内存中，程序运行中要再次使用该类的话会直接从缓存中取出。</p><p>​        当程序调用某个类的静态方法时，该类肯定要被加载的，但该类的实例成员变量对应的类并不需要加载，但静态成员变量对应的类可能会被加载，因为静态方法可能会访问该静态成员变量。而实例成员变量对应的类需要等到实例化对象的时候才会加载。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ClassLazyLoadTest</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    MainClass<span class="token punctuation">.</span><span class="token function">callStaticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MainClass</span> <span class="token punctuation">{</span>    FieldClass fieldClass<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">callStaticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">FieldClass</span> <span class="token punctuation">{</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        上面的代码启动时加上VM参数 <strong>-verbose:class</strong> 能看到有哪些类被加载到JVM中。运行结果如下：</p><blockquote><p>…<br>[Loaded sun.net.spi.DefaultProxySelector$1 from /Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/rt.jar]<br>[Loaded <strong>org.fzdata.classloader.ClassLazyLoadTest</strong> from file:/Users/mac/Desktop/0909/zc/backend-service/target/classes/]<br>[Loaded sun.net.NetProperties$1 from /Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/rt.jar]<br>…<br>[Loaded java.lang.Void from /Library/Java/JavaVirtualMachines/jdk1.8.0_241.jdk/Contents/Home/jre/lib/rt.jar]<br>[Loaded <strong>org.fzdata.classloader.ClassLazyLoadTest$MainClass</strong> from file:/Users/mac/Desktop/0909/zc/backend-service/target/classes/]<br>…</p></blockquote><p>​        可以看到ClassLazyLoadTest类与MainClass类被加载到JVM中，而FieldClass类虽然是MainClass类的实例成员变量，但由于main方法中调用MainClass.callStaticMethod()时只需要类MainClass就行，而FieldClass类只有当实例化MainClass对应的对象时才需要加载。</p><h5 id="1-3-类的生命周期"><a href="#1-3-类的生命周期" class="headerlink" title="1.3  类的生命周期"></a>1.3  类的生命周期</h5><pre><code>     从JVM将类加载到内存到调用类的方法使用类，要经过一系列阶段包括：加载 Loading、连接 Linking（校验 Verification、准备 Preparation、解析 Resolution）、初始化 Initialization 、使用 Using 、卸载 Unloading。其中 校验、准备、解析统一归属连接。</code></pre><p><img src="https://gitee.com/0909/blog/raw/master/img/20211119123740.png"></p><p>​        加载、验证、准备、初始化与卸载这五个阶段的顺序是确定，类的加载过程按上图的顺序按部就班地开始，而解析阶段则不一定JVM规范并没有明确解析的顺序，其由可能发生在初始化阶段之后。<strong>注意：上图表示的是各阶段的开始时间之间的顺序关系，而不是说验证阶段要等待加载阶段完成以后才能进行，实际这些阶段通常都是互相交叉地混合式进行的，在一个阶段执行的过程中会调用或激活下一个阶段。</strong></p><ul><li><p><strong>加载阶段</strong></p><p>该阶段主要将不同来源的类的字节码文件转化为Class对象，以便访问类的各类信息。前面提过类加载是延迟加载，只有真正要使用类时才会触发类的加载。类的加载过程包括加载、验证、准备、解析、初始化的五个阶段，从Java开发的角度来看，只有加载阶段能被干预，其他阶段都是由JVM主导。</p></li><li><p><strong>验证阶段</strong></p><p>验证阶段主要是校验字节码文件是否符合JVM的规范，主要分为文件格式校验、元数据验证、字节码验证等。</p></li><li><p><strong>准备阶段</strong></p><p>准备阶段是正式为类变量（被static修饰的变量）分配内存并设置零值的阶段，其内存都分配在方法区，不同类型的变量都会有对应的零值比如引用类型是null、int 是0 、boolean是false等。<strong>注意：这个阶段只会为类变量分配内存，而实例变量内存的分配要随着对象实例化时一起分配在堆内存中; 同时如果类变量是一个静态常量（同时被static与final修饰的变量），这阶段就会为其赋值成对应的常量值。</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">9</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">613</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> String c <span class="token operator">=</span> <span class="token string">"yeyi"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面的例子在这个阶段 a 的值为0，b值为613，c值为 null。</p></li><li><p><strong>解析阶段</strong></p><p>解析阶段实际是将符号引用解析成为直接引用，符号引用只是一个区分的标识并不指向对象真正存储的内存地址，而直接引用可以直接指向目标的指针、相对偏移量或能定位到目标的句柄。比如Person类中引用了一个 Address 类，一开始 Person 类并不知道 Address 类在内存中的地址，所以就先搞个符号引用替代一下，假装知道，等类加载解析的时候再将这个符号引用替换为Address 类真正的内存地址。</p></li><li><p><strong>初始化阶段</strong></p><p>初始化是类加载的最后一步，初始化阶段会为类变量赋予初始值（不包括静态常量，同时被static与final修饰的变量）。其实际是执行类的初始化方法clinit&lt;&gt;，该方法会被加锁执行，且只执行一次。clinit&lt;&gt;方法会按程序定义的顺序收集类中的static代码块将其放入clinit&lt;&gt;方法中。clinit&lt;&gt;方法与对象的构造函数init&lt;&gt;不同，其不能显示调用父类的clinit&lt;&gt;方法，JVM会保证调用子类的clinit&lt;&gt;方法前，父类的clinit&lt;&gt;方法已被调用。JVM 规范 Java SE 8 版本第五节中明确规定只有6种情况会触发类的初始化，同时在 Java语言规范 <strong>Initialization of Classes and Interfaces</strong>一节中有相对于Java工程师更直观的说明。下面是JVM规范 Java SE 8 版本明确的会触发类的初始化的6种情况。</p><blockquote><p><strong>1、JVM启动时用户要指定一个主函数（main方法），JVM会先初始化该方法所属的类。</strong></p><p><strong>2、执行new、getstatic、putstatic、invokestatic节码指令时引用了对应类且类未初始化，则先初始化该类。这4条指令常见的Java代码场景是：使用new关键字实例化对象、读取或设置一个类的静态变量（被final修饰的静态变量除外，其值在常用池中）、调用一个类的静态方法。</strong></p><p><strong>3、通过java.lang.reflect包或Class类中方法对类进行反射操作时，如果类未初始化，则会先初始化该类。</strong></p><p><strong>4、当初次调用MethodHandle 实例时，初始化该MethodHandle指向的方法所在类。</strong></p><p><strong>5、当一个类的其子类在初始化时，如果该类未初始化则会触发其初始化。</strong></p><p><strong>6、当一个接口定义了default方法，其直接或间接实现类在初始时，若该接口未初始化则会触发其初始化。</strong></p></blockquote><p><strong>上面的这6种情况也被叫作主动使用，其他的都是被动使用，即使代码中引用了对应的class，JVM也不会对类进行初始化。</strong></p><p>可以用下面方式验证接口与类是否初始化。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//验证接口是否初始初始化</span>  <span class="token keyword">int</span> a <span class="token operator">=</span> Test<span class="token punctuation">.</span><span class="token function">out</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">out</span><span class="token punctuation">(</span>String i<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Interface"</span> <span class="token operator">+</span> i <span class="token operator">+</span> <span class="token string">"init!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> v<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>  <span class="token keyword">static</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//验证类是否初始初始化</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Class B init!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：验证类是否加载与类是否初始化不要混淆，一个类可能已加载但没有初始化，类是否加载通过运行时加-verbose:class能看到，类是已初始化可以通过上面的代码看输出。</strong></p></li></ul><h4 id="2-双亲委派机制"><a href="#2-双亲委派机制" class="headerlink" title="2 双亲委派机制"></a>2 双亲委派机制</h4><p>​        ClassLoader加载资源与类时遵循代理模式，每一个ClassLoader有对应的父类加载器。当ClassLoader要加载一个类时，其会先尝试让他的父类加载器去加载该类，只有在父类加载器无法加载该类时其自己才会尝试去加载该类，而父类加载器又会按照这个规则优先让他的父类加载器去加载类，直到最上层的引导类加载器，这种JVM加载类的默认规则通常被叫作双亲委派模型。</p><h5 id="2-1-类加载器各司其职"><a href="#2-1-类加载器各司其职" class="headerlink" title="2.1 类加载器各司其职"></a>2.1 类加载器各司其职</h5><p>​        JVM运行时会存在很多种ClassLoader，不同的ClassLoader负责从不同的地方加载字节码文件。JVM内置了三个重要的类加载器分别是<strong>引导类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）与应用类加载器（App ClassLoader，也叫系统类加载器System ClassLoader</strong>。</p><p>​        引导类加载器主要负责加载 JDK中的核心类，这些类位于 <JAVA_HOME>/lib/rt.jar 文件中，日常开发常用的JDK类都在java.xxx.* 里面，比如 java.util.*、java.io.*、java.nio.<em>、java.lang.</em> 等等。引导类加载器比较特殊，它是由c语言实现的，他也被叫作<strong>根加载器</strong>。</p><p>​        扩展类加载器主要负责加载 JDK中的扩展类，这些类通常位于 <JAVA_HOME>/lib/ext/*.jar 文件中，但可以通过设置系统运行参数 <strong>-Djava.ext.dirs=你要指定的扩展类目录</strong> 进行修改，不过最好别这么做。</p><p>​        应用类加载器主要负责加载工程中自己开发的类以及依赖第三方类库，它加载在环境变量 CLASSPATH、-classpath 或 -cp 命令行选项中找到的应用程序类型类。可以通过ClassLoader 类提供的静态方法 getSystemClassLoader() 获取应用类加载器。当启动一个main函数时，应用类加载器开始加载main函数所属的类。</p><p>​        JDK中还内置了URLClassLoader用于从指定文件目录或是从网络中加载字节码文件，扩展类加载器与应用类加载器都是他的子类。扩展类加载器与应用类加载器都sun.misc.Luancher的内部类，分别对应ExtClassLoader类与AppClassLoader类。</p><p>​        上面提到的引导类加载器、扩展类加载器、应用类加载器要加载类的路径都可以通过参数配置去改变其默认行为。</p><table><thead><tr><th align="left">ClassLoader 类型</th><th align="left">参数选项</th><th>说明</th></tr></thead><tbody><tr><td align="left"><strong>Bootstrap ClassLoader</strong></td><td align="left">-Xbootclasspath: <br>-Xbootclasspath/a: <br/>-Xbootclasspath/p: <br/></td><td>设置Bootstrap ClassLoader的搜索路径<br>把路径添加到己存在Bootstrap ClassLoader搜索路径的后面<br>把路径添加到已存在Bootstrap ClassLoader搜索路径的前面<br></td></tr><tr><td align="left"><strong>ExtClassLoader</strong></td><td align="left">-Djava.ext.dirs</td><td>设置ExtClassLoader的搜索路径</td></tr><tr><td align="left"><strong>AppClassLoader</strong></td><td align="left">-Djava.class.path=<br>-cp<br>-classpath</td><td>设置AppClassLoader的搜索路径</td></tr></tbody></table><h5 id="2-2-双亲委派模型"><a href="#2-2-双亲委派模型" class="headerlink" title="2.2 双亲委派模型"></a>2.2 双亲委派模型</h5><p>​        本小节最前面就介绍过JVM加载类的过程默认遵循双亲委派模型，当前的类加载器在加载类时会优先让其父类加载器去加载，直到最上层的引导类加载器，如果父类加载器加载不了再尝试自去加载类。上面已介绍过引导类加载器、扩展类加载器、应用类加载器都具体负责加载哪些类。引导类加载器是扩展类加载器的父类加载器，其本身是用c言语实现的，他没有父类加载器在JDK中也找不到对应的类，所以像System、Thread、Integer等java.xxx.*包下面的类，通过他们的Class#getClassLoader时都会返回null。扩展类加载器是应用类加载器的父类加载器，其对应的类为sun.misc.Luancher$ExtClassLoader，而应用类加载对应的类为sun.misc.Luancher$AppClassLoader。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211118091315.png"></p><p>​        当应用类加载在尝试加载一个类时，会先尝试让他的父类加载器扩展类加载器去加载这个类，而扩展类加载器在尝试加载这个类时又会尝试让他的父类加载器引导类加载器去加载这个类。如果上层的类加载器加载类成功，则类加载完成，否则对应的下层自己再尝试去加载类。<strong>注意：父类加载器不能访问子类加载器加载的类，而子类加载却能访问父类加载器加载的类。上面说的父类加载器与子类加载器，不要与类继承关系上的父子类的概念混淆，AppClassLoader 的父类加载器是ExtClassLoader，但在的类继承上他们之间不存在父子关系，他们都是URLClassLoader的直接子类。</strong></p><h5 id="2-3-ClassLoader-loadClass源码"><a href="#2-3-ClassLoader-loadClass源码" class="headerlink" title="2.3 ClassLoader#loadClass源码"></a>2.3 ClassLoader#loadClass源码</h5><p>​        在ClassLoader#loadClass方法内基本能看到上面介绍的双亲派模型的整体工作流程。下是省略部分非核心代码后JDK8中ClassLoader#loadClass方法的源码。loadClass方法源码相对简单，这不再分析。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>  <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 从缓存中查找是否已加载类</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 存在父类加载器优先由父类加载器加载类</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 递归调用父类加载器的loadClass方法加载类</span>          c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">// 由引导类加载器加载类</span>          c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果抛出该异常说明父类加载无法加载类</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 父类加载器无法加载，自已尝试通过findClass加载类</span>        c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> c<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**ClassLoader中findClass默认会抛出ClassNotFoundException 要子类重写该方法实现自定义的类加载器**/</span><span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">findClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ClassNotFoundException</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-4-为什么要引入双亲委派模型？"><a href="#2-4-为什么要引入双亲委派模型？" class="headerlink" title="2.4 为什么要引入双亲委派模型？"></a>2.4 为什么要引入双亲委派模型？</h5><p>​        之前提到过JVM运行时要判断是否为同一个类（<strong>可能用同一个类的实现 Class实例会更恰当</strong>），必须类的全限定名相同且类由同一个类加载器加载。有了双亲派模型后就可以确保JVM中JDK的核心类在内存的唯一性。即使自己编程了一个名为java.lang.Thread类，按照双亲派模型最后Thread也是被引导类加载器加载，正常情况应用类加载器根本没机会去加载java.lang.Thread类。双亲派模型的存在保证的JDK核心类库的安全性，别人没法随意篡改核心类的实现。</p><h5 id="2-5-自定义类加载器"><a href="#2-5-自定义类加载器" class="headerlink" title="2.5 自定义类加载器"></a>2.5 自定义类加载器</h5><p>​        <strong>通常可以通过继承ClassLoader重写findClass方法来实现自定义的类加载器，这样可以保证类加载流程遵循双亲委派模型，但些情况下也可以重写loadClass方法</strong>。双亲委派模型是在JDK1.2时引入的，在这之前loadClass方法已存在，为了向后兼容引入了findClass方法。重写loadCloass会打破双亲委派模型，关于打破双亲委派机制将在后面介绍。前面了解到ClassLoader中findClass方法默认抛出ClassNotFoundException异常。重写findClass方法实现自定义ClassLoader，一般分两步：</p><ul><li><strong>在findClass内部调用私有的loadClassData方法，根据给定名字获取符合JVM规范的字节码数组</strong></li><li><strong>将获取到的字节码通过CloassLoader#defineClass方法生成对应的Class实例</strong></li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">CustomClassLoader</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> Class <span class="token class-name">findClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//1、获取符合JVM规范的字节码数组</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> b <span class="token operator">=</span> <span class="token function">loadClassData</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//2、调用defineClass方法生成Class实例</span>    <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> b<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">loadClassData</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//TODO load the class data from somewhere</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-打破双亲委派机制"><a href="#3-打破双亲委派机制" class="headerlink" title="3 打破双亲委派机制"></a>3 打破双亲委派机制</h4><p>​        前面说过正常情况下尝试加载类的路径是：<strong>引导类加载器 =〉扩展类加载器 =〉应用类加载器 =〉用户自定义类加载器，即遵循双亲委派模型</strong>。但如果引导类加载器，加载类时要用到非JDK中的类呢？这时只能选择打破类加载的双亲委派机制。</p><h5 id="3-1-打破双亲委派机制的方式"><a href="#3-1-打破双亲委派机制的方式" class="headerlink" title="3.1 打破双亲委派机制的方式"></a>3.1 打破双亲委派机制的方式</h5><p>​        先看一下打破双亲委派机制的两种方式<strong>重写ClassLoader#loadClass方法</strong>与<strong>通过Thread#getContextClassLoader获取的类加载器去加载类</strong>。</p><ul><li><p><strong>重写ClassLoader#loadClass方法</strong></p><p>前面在实现自定义类加载时就提到过重写ClassLoader#loadClass方法能会打破双亲委派机制，从上面ClassLoader#loadClass的源码分析可以看到双亲委派机制实际在这个方法中实现，一旦重写该方法就可以改变类加载的流程。</p></li><li><p><strong>通过Thread#getContextClassLoader获取的类加载器去加载类</strong></p><p>一方面Thread内部有一个类型为ClassLoader的contextClassLoader变量，该变量默认值为AppClassLoader，该变量可以通过Thread#setContextCalssLoader方法设置、通过Thread#getContextClassLoader方法获取。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Thread#setContextClassLoader方法，会根据安全管理器的策略查看是否有权限设置contextClassLoader</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setContextClassLoader</span><span class="token punctuation">(</span>ClassLoader cl<span class="token punctuation">)</span> <span class="token punctuation">{</span>  SecurityManager sm <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>sm <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    sm<span class="token punctuation">.</span><span class="token function">checkPermission</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RuntimePermission</span><span class="token punctuation">(</span><span class="token string">"setContextClassLoader"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  contextClassLoader <span class="token operator">=</span> cl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Thread#getContextClassLoader方法，会根据安全管理器的策略查看是否有权限获取contextClassLoader</span><span class="token keyword">public</span> ClassLoader <span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>contextClassLoader <span class="token operator">==</span> null<span class="token punctuation">)</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span>  SecurityManager sm <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>sm <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ClassLoader<span class="token punctuation">.</span><span class="token function">checkClassLoaderPermission</span><span class="token punctuation">(</span>contextClassLoader<span class="token punctuation">,</span>                       Reflection<span class="token punctuation">.</span><span class="token function">getCallerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> contextClassLoader<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>另一方面<strong>Class#forName</strong>可以传入指定的类加载器来加载类。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">forName</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> initialize<span class="token punctuation">,</span>                               ClassLoader loader<span class="token punctuation">)</span>  <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>  Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> caller <span class="token operator">=</span> null<span class="token punctuation">;</span>  SecurityManager sm <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>sm <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    caller <span class="token operator">=</span> Reflection<span class="token punctuation">.</span><span class="token function">getCallerClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//省略安全校验源码</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token function">forName0</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> initialize<span class="token punctuation">,</span> loader<span class="token punctuation">,</span> caller<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">native</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">forName0</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> initialize<span class="token punctuation">,</span>                                        ClassLoader loader<span class="token punctuation">,</span>                                        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> caller<span class="token punctuation">)</span>  <span class="token keyword">throws</span> ClassNotFoundException<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>重点来了，有了与Thread绑定的contextClassLoader，再结合Class#forName能指定类加载器加载类，就可以通过切换与Thread绑定的ClassLoader实现想用什么类加载器就用什么类加载器，这最终将打破双亲委派机制</strong>。</p><p><strong>有一点要注意Thread中contextClassLoader默认为AppClassLoader</strong>。Java中所有线程都是直接或间接由主线程（main方法所属线程）创建的（主线程本身除外），而主线程对应的contextClassLoader默认为AppClassLoader。通过下面Thread构建方法最终调用的init方法可以看到线程在创建时默认contextClassLoader为其父类的contextClassLoader，即所有线程默认的contextClassLoader都是AppClassLoader。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Thread构造方法最终调用的Thread#init方法，contextClassLoader赋值相关源码</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>ThreadGroup g<span class="token punctuation">,</span> Runnable target<span class="token punctuation">,</span> String name<span class="token punctuation">,</span>                  <span class="token keyword">long</span> stackSize<span class="token punctuation">,</span> AccessControlContext acc<span class="token punctuation">,</span>                  <span class="token keyword">boolean</span> inheritThreadLocals<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//...省略其他源码</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>security <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token function">isCCLOverridden</span><span class="token punctuation">(</span>parent<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>contextClassLoader <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>contextClassLoader <span class="token operator">=</span> parent<span class="token punctuation">.</span>contextClassLoader<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//...省略其他源码</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结合上面说的Thread中contextClassLoader默认为AppClassLoader与Class#forName，先来提前看一下Java内部提供的服务发现SPI机制打破双亲委派机制的核心源码：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//ServiceLoader#load加载服务</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>S<span class="token operator">></span> ServiceLoader<span class="token operator">&lt;</span>S<span class="token operator">></span> <span class="token function">load</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>S<span class="token operator">></span> service<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//获取当前线程的ClassLoader，这个ClassLoader是AppClassLoader</span>  ClassLoader cl <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> ServiceLoader<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>service<span class="token punctuation">,</span> cl<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//ServiceLoader$LazyIterator#nextService 获取下一个可用服务实现，省略无关代码</span><span class="token keyword">private</span> S <span class="token function">nextService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//外部实际接口实现类的全限定类名如exapmle.MysqlRepository</span>  String cn <span class="token operator">=</span> nextName<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//loader参数为上面的AppClassLoader</span>        c <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>cn<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> loader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//省略无关代码...</span>    <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//省略无关代码...</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        S p <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">cast</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        providers<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>cn<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//省略无关代码...</span>    <span class="token punctuation">}</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>按照之前讲的双亲委派机制java.util.ServiceLoader类最终由引导类加载器完成，而ServiceLoader本身实现又要通过Class.forName方法去加载非JDK的类如com.mysql.jdbc.Driver，直接用引导类加载器一定加载不了的，只能通过指定Class.forName的CloassLoader参数了。</strong></p></li></ul><h5 id="3-2-Service-Provider-Interface-SPI"><a href="#3-2-Service-Provider-Interface-SPI" class="headerlink" title="3.2 Service Provider Interface (SPI)"></a>3.2 Service Provider Interface (SPI)</h5><p>​        Java语言提供了一种叫作Service Provider Interface (SPI)机制，该机制能为程序提供动态的扩展点，标准与规范的定义方负责对核心功能给出接口定义，而第三方的厂商则去实现对应的接口。以JDBC为例，JDBC规范定义了Driver接口，而像mysql厂商则提供了具体的connector Jar，并在Jar中包含<code>META-INF/services</code>目录，该目录下有一个名为java.sql.Driver的文件，即JDBC规范定义的Driver接口，其内容为mysql厂商的具体实现类：</p><blockquote><p>com.mysql.jdbc.Driver<br>com.mysql.fabric.jdbc.FabricMySQLDriver</p></blockquote><p>在JDBC4规范中，作为使用者只要classpath下面有对应的mysql connector，直接用下面代码便可以获取mysql数据库的连接。</p><pre class="line-numbers language-java"><code class="language-java">Connection conn <span class="token operator">=</span>   DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token string">"jdbc:mysql://localhost:3306/mydb"</span><span class="token punctuation">,</span> <span class="token string">"test"</span><span class="token punctuation">,</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>同样如果是SQL Server的话，只要修改对应获取Connection的url参数，更改classpath下面connector为SQL Server 就可以获取SQL Server数据库的连接。这样一来就将不同厂商在数据库Driver实现上差别给屏蔽了，达到了关注点分离的目的，业务开发人员只要按照JDBC的规范去写业务逻辑，当像Mybatis、Hiberante等ORM框架又在JDBC规范上做更多的封装让操作数据库变得更加友好简单。</p><p>可以看到SPI整体可分为三步服务定义、服务提供、服务调用</p><ul><li><p><strong>服务定义</strong> 主要是为服务或功能提供接口的定义与抽象。下面代码是Repository服务的定义。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> example<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Repository</span> <span class="token punctuation">{</span>  <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span>String data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>服务提供</strong> 根据自身特点实现服务定义阶段定义的接口，并在classpath下面创建<code>META-INF/services</code>目录，该目录下有一个文件名与已定义好的接口名一致的文件(如上看到的java.sql.Driver)，文件内容为该接口的具体实现类的类名，如果有多个具体实际则换行，一行一个具体实现类的类名。下面代码是Repository服务的不同实现，以及按SPI规则将服务暴露出去。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> example<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MysqlRepository</span> <span class="token keyword">implements</span> <span class="token class-name">Repository</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span>String data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>data <span class="token operator">+</span> <span class="token string">" saved by Mysql Repository!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> example<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MongoDBRepository</span> <span class="token keyword">implements</span> <span class="token class-name">Repository</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">save</span><span class="token punctuation">(</span>String data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>data <span class="token operator">+</span> <span class="token string">" saved by MongoDB repository!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>META-INF/services/example.Repository 文件内容如下：</p><blockquote><p>example.MongoDBRepository<br>example.MysqlRepository        </p></blockquote></li><li><p><strong>服务调用</strong> 通过classpath下面引用上面服务提供方实现的具体Jar（如果服务提供与服务调用在同一工程可以直接进行使用），然后通ServiceLoader#load方法加载对应服务，并通过ServiceLoader#iterator方法遍历可用的服务。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//通过load方法加载对应服务</span>ServiceLoader<span class="token operator">&lt;</span>Repository<span class="token operator">></span> serviceLoader <span class="token operator">=</span> ServiceLoader<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>Repository<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//遍历可用的服务</span>Iterator<span class="token operator">&lt;</span>Repository<span class="token operator">></span> iterator <span class="token operator">=</span> serviceLoader<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  Repository repository <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//调用实际服务</span>  repository<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span><span class="token string">"Data"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><p>介绍完SPI机制后，再次把SPI打破双亲委派模型核心代码看一下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//ServiceLoader#load加载服务</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>S<span class="token operator">></span> ServiceLoader<span class="token operator">&lt;</span>S<span class="token operator">></span> <span class="token function">load</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>S<span class="token operator">></span> service<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//获取当前线程的ClassLoader，这个ClassLoader是AppClassLoader</span>  ClassLoader cl <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getContextClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> ServiceLoader<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span>service<span class="token punctuation">,</span> cl<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//ServiceLoader$LazyIterator#nextService 获取下一个可用服务实现，省略无关代码</span><span class="token keyword">private</span> S <span class="token function">nextService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/**以上面Repository服务的SPI为例，变量cn实际是保存在META-INF/services/example.Repository  文件中的类名example.MongoDBRepository或example.MysqlRepository每次遍历服务时获取一个**/</span>  String cn <span class="token operator">=</span> nextName<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//loader为ServiceLoader#load方法中通过contextClassLoader获取到的AppClassLoader</span>        c <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>cn<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> loader<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//省略无关代码...</span>    <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//省略无关代码...</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        S p <span class="token operator">=</span> service<span class="token punctuation">.</span><span class="token function">cast</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        providers<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>cn<span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> p<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//省略无关代码...</span>    <span class="token punctuation">}</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <strong>那面试时怎么回答”JDBC4规范是怎么打破类加载的双亲委派机制？“才更加恰当直观。</strong> 希望看完上面的源码分析对你有所启示。</p><h5 id="3-3-OSGi"><a href="#3-3-OSGi" class="headerlink" title="3.3  OSGi"></a>3.3  OSGi</h5><p>​        OSGi(Open Service Gateway Initiative) 技术是 Java 动态化模块化系统的一系列规范，在JDK9之前其实际是业界Java模块化的标准。OSGi通过自定义类加载器实现了模块化热部署。OSGi中程序程序模块被称作Bundle，每个Bundle都有自已的类加载器，当要更换模块时就将Bundle与类加载器一同更换以实现热部署。OSGi相对复杂，本人项目中还未真真接触过，但按照我的推理其改变类加载的双亲委派机制无非也是基于<strong>重写ClassLoader#loadClass方法</strong>或<strong>通过Thread#getContextClassLoader获取的类加载器去加载类</strong>。我这里就抛砖引玉了，OSGi学习曲线很高并且项目中真正用到的比较少，如果真对类似技术感兴趣，我推荐大家看看蚂蚁金服的容器隔离sofa-ark。</p><h4 id="4-关于四打破双亲委派机制"><a href="#4-关于四打破双亲委派机制" class="headerlink" title="4 关于四打破双亲委派机制"></a>4 关于四打破双亲委派机制</h4><p>​        从JDK1.2双亲委派机制提出到JDK9，双亲委派机制一次又一次的被打破。大体可以分为下面四次。</p><ul><li><strong>向后兼容Class#loadClass方法打破双亲委派机制</strong></li><li> <strong>SPI机制打破双亲委派机制</strong></li><li><strong>OSGi模块化热加载技术打破双亲委派机制</strong></li><li> <strong>JDK9 引入模块化打破双亲委派机制</strong></li></ul><p>这些都最终都可以归为第3小节介绍的两种方式<strong>重写ClassLoader#loadClass方法</strong>与<strong>通过Thread#getContextClassLoader获取的类加载器去加载类</strong>。</p><h5 id="4-1-向后兼容Class-loadClass方法打破双亲委派机制"><a href="#4-1-向后兼容Class-loadClass方法打破双亲委派机制" class="headerlink" title="4.1 向后兼容Class#loadClass方法打破双亲委派机制"></a>4.1 向后兼容Class#loadClass方法打破双亲委派机制</h5><p>​        在JDK1.2提出双亲委派机制之前，JDK之前的版本中ClassLoader#loadClass方法已存在，JDK1.2对ClassLoader#loadClass方法进行了重构将双亲委派机制的实际放入到了该方法。ClassLoader#loadClass实际是public的，为了后面兼容那些用老版本通过ClassLoader#loadClass实现自定义类加载的用户，JDK1.2引入了ClassLoader#findClass方法。后继在自定义类加载器就建议重写ClassLoader#findClass方法，来维护JDK1.2提出双亲委派机制。所以说ClassLoader#loadClass为打破双亲委派机制留入了入口。当然双亲委派机制不是在什么场景都是最合适的，所以打破他也是必然。</p><h5 id="4-2-SPI机制打破双亲委派机制"><a href="#4-2-SPI机制打破双亲委派机制" class="headerlink" title="4.2  SPI机制打破双亲委派机制"></a>4.2  SPI机制打破双亲委派机制</h5><p>​        第3小节已从SPI机制核心类ServiceLoader源码分析了，ServiceLoader类是通过引导类加载器加载的，而其内部调用的方法要通过Class#forName方法加载<code>META-INF/services/自定义接口名</code>文件中非JDK核心库中的类，即要通过引导类加载器去加载非JDK核心库中的类，按照双亲委派机制这是实现不了的。<strong>于是有了Thread#contextClassLoader，通过Thread#getContextClassLoader获取的类加载器去加载类，便可实现上面的功能</strong>。</p><h5 id="4-3-OSGi模块化热加载技术打破双亲委派机制"><a href="#4-3-OSGi模块化热加载技术打破双亲委派机制" class="headerlink" title="4.3  OSGi模块化热加载技术打破双亲委派机制"></a>4.3  OSGi模块化热加载技术打破双亲委派机制</h5><p>​        OSGi模块化技术中实现了自定义的类加载器，每一个模块都有各自的类加载器，其类加载流程没有完全遵循双亲委派机制中自下而上的委托，而是存在很多平级之间的类加载器查找。</p><h5 id="4-4-JDK9-引入模块化打破双亲委派机制"><a href="#4-4-JDK9-引入模块化打破双亲委派机制" class="headerlink" title="4.4  JDK9 引入模块化打破双亲委派机制"></a>4.4  JDK9 引入模块化打破双亲委派机制</h5><p>​         JDK9 引入模块化后，类打包与加载都是按模块来的，而不是按上面说的Bootstrap ClassLoader、Extension ClassLoader、ExtClassLoader各自加载什么目录下面的类，同时Bootstrap ClassLoader、Extension ClassLoader、ExtClassLoader的具体实现也发生了很大改变。关于JDK9中的ClassLoader的分析，后面再会专门写一篇文章。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​        本文先对ClassLoader做了整体的概述，然后介绍了JDK8中类加载的双亲委派模型，而后又介绍了打破双新委派模型的相关的内容。希望通过本文你对JDK中的ClassLoader有更加系统性的了解，而不只是停留在双亲委派模型上。后面我将再转门针对JDK9详细分析一下ClassLoader。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf">The Java® Virtual Machine Specification Java SE 8 Edition</a></p><p>《深入理解Java虚拟机：JVM高级特性与最佳实践》</p><p><a href="https://blog.mythsman.com/post/5d29b12c373f140fc98304a1/">sofa-ark类隔离技术分析调研</a></p><h4 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h4><p>​        原创不易，点赞、在看、转发是对我莫大的鼓励，关注公众号洞悉源码是对我最大的支持。同时相信我会分享更多干货，我同你一起成长，我同你一起进步。</p>]]></content>
      
      
      <categories>
          
          <category> JDK源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK源码 </tag>
            
            <tag> SPI </tag>
            
            <tag> ClassLoader </tag>
            
            <tag> Fat-Jar </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解JDK中的黑科技Unsafe类</title>
      <link href="/2021/11/03/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3JDK%E4%B8%AD%E7%9A%84%E9%BB%91%E7%A7%91%E6%8A%80Unsafe/"/>
      <url>/2021/11/03/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3JDK%E4%B8%AD%E7%9A%84%E9%BB%91%E7%A7%91%E6%8A%80Unsafe/</url>
      
        <content type="html"><![CDATA[<h3 id="一文详解JDK中的黑科技Unsafe类"><a href="#一文详解JDK中的黑科技Unsafe类" class="headerlink" title="一文详解JDK中的黑科技Unsafe类"></a>一文详解JDK中的黑科技Unsafe类</h3><h4 id="1-Unsafe类概述"><a href="#1-Unsafe类概述" class="headerlink" title="1 Unsafe类概述"></a>1 Unsafe类概述</h4><p>​        如果说<strong>Java</strong>语言之中有没有什么黑科技，那么<strong>Unsafe</strong>当之为愧。<strong>java</strong>是一种安全性很高的语言，正常情况程序中不用直接操作内存（申请内存与释放内存），<strong>JVM</strong>会按照垃圾回收机制对无用的内存自动进行回收。<strong>Unsafe</strong>类打破了这一切，其提供了一些用于执行低级别、不安全操作的<strong>native方法</strong>，如直接访问系统内存资源、自主管理内存资源等。这些方法一方提升Java运行效率、增强Java语言操作底层资源能力，另一也给java语言的健壮性、安全性带来了隐患，这应该为什么他被命名为<strong>Unsafe</strong>的原因吧。</p><p>​        <strong>JDK9</strong>引入模块化机制后，<strong>Unsafe</strong>类的功能同时存在于<strong>java.base模块的jdk.internal.misc.Unsafe</strong> 与<strong>jdk.unsupported模块的sun.misc.Unsafe</strong>中。两个<strong>Unsafe</strong>类之间有细微的差，<strong>jdk.unsupported模块的sun.misc.Unsafe</strong>主要是为了向后兼容老版本的JDK，其与<strong>JDK9</strong>之前版本的<strong>sun.misc.Unsafe</strong>基本是一样的。而<strong>java.base模块的jdk.internal.misc.Unsafe</strong>，其被分配到<strong>jdk.internal</strong>包中表明该<strong>Unsafe</strong>类主要用于<strong>JDK</strong>本身核心类的实现。<strong>JDK9</strong>开始<strong>JDK</strong>原来依赖的<strong>Unsafe</strong>类已全转由<strong>sun.misc.Unsafe</strong>转为<strong>jdk.internal.misc.Unsafe</strong>。同时在<strong>JDK9</strong>中之前版本<strong>Unsafe</strong>的一些功能已被<strong>VarHandle</strong>类替代（<strong>VarHandle</strong>的功能是在<a href="http://openjdk.java.net/jeps/193">JEP193</a>中提出的），随着时间的推移<strong>java.base模块的jdk.internal.misc.Unsafe</strong> 类与<strong>jdk.unsupported模块的sun.misc.Unsafe</strong>类终将退出历史的舞台(目前最新的<strong>JDK17</strong>中还存在)，取而代之的将是<strong>java.lang.invoke.VarHandle</strong>类。</p><p>​        在<strong>JDK11</strong>中即可以使用<strong>java.base模块的jdk.internal.misc.Unsafe</strong> 类也可以使用<strong>jdk.unsupported模块的sun.misc.Unsafe</strong>类，但最好别去使用<strong>Unsafe</strong>这个黑科技。<strong>JDK11</strong>中使用<strong>java.base模块的jdk.internal.misc.Unsafe</strong> 类时，编译与运行时要加入对应的参数，否则将会出现一些异常。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> jdk<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Unsafe<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> Integer i<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    Unsafe unsafe <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    App app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>app<span class="token punctuation">.</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> offset <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span><span class="token punctuation">(</span>App<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"i"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    unsafe<span class="token punctuation">.</span><span class="token function">putObject</span><span class="token punctuation">(</span>app<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> <span class="token number">613</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>app<span class="token punctuation">.</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以在Idea下开发为例如果未设置如下编译参数（假设项目未指定<strong>module-info.java</strong>文件，为未命名模块），</p><blockquote><p><strong>–add-exports=java.base/jdk.internal.misc=ALL-UNNAMED</strong></p></blockquote><p>Idea将提示</p><blockquote><p><strong>Package ‘jdk.internal.misc’ is declared in module ‘java.base’, which does not export it to the unnamed module</strong></p></blockquote><p>同样运行程序时，如果未设置如下<strong>VM</strong>参数</p><blockquote><p><strong>–add-opens java.base/jdk.internal.misc=ALL-UNNAMED –illegal-access=warn</strong></p></blockquote><p>控制台将抛出如下异常</p><blockquote><p><strong>Exception in thread “main” java.lang.IllegalAccessError: class org.example.App (in module jdk11.base) cannot access class jdk.internal.misc.Unsafe (in module java.base) because module java.base does not export jdk.internal.misc to module UNNAMED …</strong></p></blockquote><p>当然可以像<strong>JDK9</strong>之前那样去使用<strong>sun.misc.Unsafe</strong>类</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Field<span class="token punctuation">;</span><span class="token keyword">import</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Unsafe<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">App</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> Integer i<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>    Field f <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"theUnsafe"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    f<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Unsafe unsafe <span class="token operator">=</span> <span class="token punctuation">(</span>Unsafe<span class="token punctuation">)</span> f<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>    App app <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>app<span class="token punctuation">.</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> offset <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span><span class="token punctuation">(</span>App<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"i"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    unsafe<span class="token punctuation">.</span><span class="token function">putObject</span><span class="token punctuation">(</span>app<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> <span class="token number">613</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>app<span class="token punctuation">.</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-Unsafe类能做什么？"><a href="#2-Unsafe类能做什么？" class="headerlink" title="2 Unsafe类能做什么？"></a>2 Unsafe类能做什么？</h4><p>​        前面说过<strong>Unsafe</strong>类能做一些低级别的操作，如直接访问系统内存资源、自主管理内存资源等。那<strong>Unsafe</strong>类还能做什么？</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211103172118.png"></p><p>大致总结一下可以分为上面八大类<strong>内存屏障、内存操作、线程调度、系统操作、Class操作、对象操作、CAS操作、数组操作</strong>。</p><p><strong>注意：JDK8之后的版本中Unsafe类与之前版本中的Unsafe类有差异，下面我们基于JDK11来看一下jdk.internal.misc.Unsafe中各功能对应的方法。</strong></p><h4 id="3-内存屏障"><a href="#3-内存屏障" class="headerlink" title="3 内存屏障"></a>3 内存屏障</h4><h5 id="3-1-内存屏障简介"><a href="#3-1-内存屏障简介" class="headerlink" title="3.1 内存屏障简介"></a>3.1 内存屏障简介</h5><p>​        为了提升计算机处理效率，编译器会对编译后的指令进行重排，同时CPU会乱序执行指令。    <strong>内存屏障（Memory Barriers）</strong>技术可以在适当的位置禁止这种重排与乱序执行。<strong>内存屏障</strong>实际是一些特殊的指令，该指令使得在其之前的所有Load操作与Store操作都先于其后的Load操作与Store操作执行。</p><p>​        <strong>内存屏障（Memory Barriers）</strong>可分为<strong>读屏障（Load Barriers）</strong>和<strong>写屏障（Store Barriers）</strong>，这两者进行结合共有四种屏障<strong>Load-Load Barriers、Load-Store Barriers、Store-Store Barriers、Store-Load Barriers</strong>。下面看一下不同内存屏障的插入会达到什么要的效果。</p><pre><code>load1 LoadLoad load2</code></pre><blockquote><p>保证 load1 数据的装载优先于 load2 以及所有后续装载指令的装载。对于 Load Barrier 来说，在指令前插入 Load Barrier，可以让高速缓存中的数据失效，强制重新从主内存加载数据。</p></blockquote><pre><code>load1 LoadStore store2</code></pre><blockquote><p>保证 load1 数据装载优先于 store2 以及后续的存储指令刷新到内存。</p></blockquote><pre><code>store1 StoreStore store2</code></pre><blockquote><p>保证 store1 数据对其他处理器可见，优先于 store2 以及所有后续存储指令的存储。对于 Store Barrier 来说，在指令后插入 Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。</p></blockquote><pre><code>store1 StoreLoad load2</code></pre><blockquote><p>在load2 及后续所有读取操作执行前，保证 store1 的写入对所有处理器可见。这条内存屏障指令是一个全能型的屏障，它同时具有其他 3 条屏障的效果，而且它的开销也是四种屏障中最大的一个。</p></blockquote><h5 id="3-2-内存屏障相关方法"><a href="#3-2-内存屏障相关方法" class="headerlink" title="3.2 内存屏障相关方法"></a>3.2 内存屏障相关方法</h5><p><strong>JDK11</strong>中<strong>jdk.internal.misc.Unsafe</strong>类提供了如下方法插入对应的内存屏障。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//读内存屏障，确保屏障前的load操作不会与其后的load操作与store操作重排序。</span><span class="token comment" spellcheck="true">//相当于LoadLoad 与 LoadStore 屏障。其效果是强制读取操作从主内存中获取最新值。</span><span class="token annotation punctuation">@HotSpotIntrinsicCandidate</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">loadFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//写内存屏障，确保屏障前的store操作、load操作不会与其后的store操作重排序。</span><span class="token comment" spellcheck="true">//相当于StoreStore 与 LoadStore 屏障</span><span class="token annotation punctuation">@HotSpotIntrinsicCandidate</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">storeFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//全内存屏障，确保屏障前的store操作、load操作不会与其后的store操作、load操作重排序。</span><span class="token comment" spellcheck="true">//相当于StoreLoad 屏障</span><span class="token annotation punctuation">@HotSpotIntrinsicCandidate</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">fullFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">loadLoadFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">loadFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">storeStoreFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">storeFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面方法上**@HotSpotIntrinsicCandidate**注解表示HotSpot虚似机实现时，为提升方法运行性能可能根据具体平台对该方法进行内置的优化。作为Java应用程序开发者可以忽略这个注解。</p><h5 id="3-3-应用场景"><a href="#3-3-应用场景" class="headerlink" title="3.3 应用场景"></a>3.3 应用场景</h5><p>​        <strong>JDK8</strong>中引入了一种新类型的锁<strong>StampedLock</strong>, 该锁是对<strong>ReentrantReadWriteLock</strong>进行一步进行了优化，其之前读写锁的基础上，引入了乐观读锁的概念，这种乐观读锁类似于无锁的操作，完全不会阻塞写线程获取写锁，从而缓解读多写少时写线程“饥饿”现象，在多读几乎没写的场景下效率低高。<strong>但其不支持重入与条件等待</strong>。由于<strong>StampedLock</strong>提供的乐观读锁不阻塞写线程获取写锁，当线程共享变量从主内存load到线程工作内存时，会存在数据不一致问题，所以当使用<strong>StampedLock</strong>的乐观读锁时需要遵从一定的模式来确保数据的一致性。在<strong>StampedLock</strong>的源码中，<strong>Doug Lea</strong> 为我们提供了使用<strong>StampedLock</strong>乐观锁的示例代码，这里稍微简化一如下。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">double</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> StampedLock sl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StampedLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// an exclusively locked method</span>  <span class="token keyword">void</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token keyword">double</span> deltaX<span class="token punctuation">,</span> <span class="token keyword">double</span> deltaY<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">long</span> stamp <span class="token operator">=</span> sl<span class="token punctuation">.</span><span class="token function">writeLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      x <span class="token operator">+=</span> deltaX<span class="token punctuation">;</span>      y <span class="token operator">+=</span> deltaY<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>      sl<span class="token punctuation">.</span><span class="token function">unlockWrite</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// a read-only method, upgrade from optimistic read to read lock</span>  <span class="token keyword">double</span> <span class="token function">distanceFromOrigin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">long</span> stamp <span class="token operator">=</span> sl<span class="token punctuation">.</span><span class="token function">tryOptimisticRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// (1) 获取乐观读锁</span>    <span class="token keyword">double</span> currentX <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token keyword">double</span> currentY <span class="token operator">=</span> y<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// (2) 复制主内存数据到工作内存</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>sl<span class="token punctuation">.</span><span class="token function">validate</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// (3) 校验乐观读后数据是否发生变化</span>      <span class="token keyword">try</span> <span class="token punctuation">{</span>        stamp <span class="token operator">=</span> sl<span class="token punctuation">.</span><span class="token function">readLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//(4) 升级乐观读锁为悲观读锁</span>        currentX <span class="token operator">=</span> x<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//(5) 复制主内存数据到工作内存</span>        currentY <span class="token operator">=</span> y<span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        sl<span class="token punctuation">.</span><span class="token function">unlockRead</span><span class="token punctuation">(</span>stamp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//(6) 释放悲观读锁</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>currentX <span class="token operator">*</span> currentX <span class="token operator">+</span> currentY <span class="token operator">*</span> currentY<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//(7) 线程工作内存计算</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>StampedLock</strong>中写锁还是和<strong>ReentrantReadWriteLock</strong>写锁一致，但读锁不一样。<strong>distanceFromOrigin</strong>计算点x, y到原点的距离时，会先尝试调用<strong>StampedLock#tryOptimisticRead</strong>方法，获取乐观读锁，再将主内存的数据复制到工作内存。但此时其他线程可能调用<strong>move</strong>方法修改了x, y的值，因此要通过<strong>StampedLock#validate</strong>方法校验主内存的数据是否发生变化，如果有发生变化则将乐观读锁升级为悲观读，重新将主内存数据复制到工作内存，否则直接返回计算结果。</p><img src="https://gitee.com/0909/blog/raw/master/img/20211112153303.png" style="zoom:80%;" /><p>下面是<strong>JDK11中StampedLock#validate</strong>方法的源码，在执行校验逻辑之前会通过Unsafe的<strong>loadFence</strong>方法加入一个<strong>load内存屏障</strong>，目的是避免上面的<strong>Point示例</strong>中步骤(2)和<strong>StampedLock#validate</strong>中校验逻辑发生重排序导致校验不准确的问题。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//StampedLock#validate方法</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">validate</span><span class="token punctuation">(</span><span class="token keyword">long</span> stamp<span class="token punctuation">)</span> <span class="token punctuation">{</span>   VarHandle<span class="token punctuation">.</span><span class="token function">acquireFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> <span class="token punctuation">(</span>stamp <span class="token operator">&amp;</span> SBITS<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span>state <span class="token operator">&amp;</span> SBITS<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//VarHandle#acquireFence方法</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">acquireFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  UNSAFE<span class="token punctuation">.</span><span class="token function">loadFence</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-内存操作"><a href="#4-内存操作" class="headerlink" title="4 内存操作"></a>4 内存操作</h4><p>​        <strong>Java</strong>语言中不像c、c++那样要工程师在代码中维护内存的申请与释放，<strong>JVM</strong>中的垃圾回收机制会自动回收内存，但<strong>Unsafe</strong>提供了应用代码层面管理内存的机制，这部分内存是非JVM管理的内存，通常叫作<strong>堆外内存</strong>。</p><h5 id="4-1-内存管理相关方法"><a href="#4-1-内存管理相关方法" class="headerlink" title="4.1 内存管理相关方法"></a>4.1 内存管理相关方法</h5><p><strong>JDK11</strong>中<strong>jdk.internal.misc.Unsafe</strong>类提供了如下内存管理的方法</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//分配指定字节的内存</span><span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">allocateMemory</span><span class="token punctuation">(</span><span class="token keyword">long</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//指定地址扩充内存</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">long</span> <span class="token function">reallocateMemory</span><span class="token punctuation">(</span><span class="token keyword">long</span> address<span class="token punctuation">,</span> <span class="token keyword">long</span> bytes<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//释放内存</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">freeMemory</span><span class="token punctuation">(</span><span class="token keyword">long</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//在给定的内存块中设置值</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">setMemory</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token keyword">long</span> bytes<span class="token punctuation">,</span> <span class="token keyword">byte</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//内存拷贝</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">copyMemory</span><span class="token punctuation">(</span>Object srcBase<span class="token punctuation">,</span> <span class="token keyword">long</span> srcOffset<span class="token punctuation">,</span> Object destBase<span class="token punctuation">,</span><span class="token keyword">long</span> destOffset<span class="token punctuation">,</span> <span class="token keyword">long</span> bytes<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//根据偏移地址获取对应对象变量值，变量本身的访问修饰符限制将忽略，类似操作还有getInt、getLong、getChar等</span><span class="token keyword">public</span> <span class="token keyword">native</span> Object <span class="token function">getObject</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//根据偏移地址设置对象变量值，变量本身的访问修饰符限制将忽略，类似操作还有putInt、putLong、putChar等</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">putObject</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> Object x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取给定地址的byte类型的值（参数address值要为allocateMemory分配，否则结果正确性无法保证）</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">byte</span> <span class="token function">getByte</span><span class="token punctuation">(</span><span class="token keyword">long</span> address<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//为给定地址设置byte类型的值（参数address值要为allocateMemory分配，否则结果正确性无法保证）</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">putByte</span><span class="token punctuation">(</span><span class="token keyword">long</span> address<span class="token punctuation">,</span> <span class="token keyword">byte</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="4-2-为什么需要堆外内存"><a href="#4-2-为什么需要堆外内存" class="headerlink" title="4.2 为什么需要堆外内存"></a>4.2 为什么需要堆外内存</h5><ul><li><p><strong>改善垃圾回收停顿时长</strong></p><p>由于堆外内存是直接受操作系统管理而不是JVM，所以当我们使用堆外内存时，即可保持较小的堆内内存规模。从而在GC时减少回收停顿对于应用的影响。</p></li><li><p><strong>提升程序I/O操作的性能</strong></p><p>通常在I/O通信过程中，会存在堆内内存到堆外内存的数据拷贝操作，对于需要频繁进行内存间数据拷贝且生命周期较短的暂存数据，都建议存储到堆外内存。</p></li></ul><h5 id="4-3-堆外内存运用之DirectByteBuffer"><a href="#4-3-堆外内存运用之DirectByteBuffer" class="headerlink" title="4.3 堆外内存运用之DirectByteBuffer"></a>4.3 堆外内存运用之DirectByteBuffer</h5><p>​        JDK中<strong>ByteBuffer#allocateDirect</strong>方法能直接分配堆外内存，其实际返回的是<strong>DirectByteBuffer</strong>对象，而<strong>DirectByteBuffer</strong>类内部又通过<strong>Unsafe</strong>的<strong>allocateMemory</strong>、<strong>setMemory</strong>与<strong>freeMemory</strong>等方法管理内存。<strong>NIO</strong>框架<strong>Netty</strong>中大量使用堆外内存，提升I/O操作的性能。</p><pre><code>public static ByteBuffer allocateDirect(int capacity) &#123;    return new DirectByteBuffer(capacity);&#125;</code></pre><p>​        下面是<strong>DirectByteBuffer</strong>构造函数，创建<strong>DirectByteBuffer</strong>的时候，通过<strong>Unsafe#allocateMemory</strong>分配内存、<strong>Unsafe#setMemory</strong>进行内存初始化，而后通过<strong>Cleaner</strong>跟踪<strong>DirectByteBuffer</strong>对象的垃圾回收，以实现当<strong>DirectByteBuffer</strong>被垃圾回收时，通过<strong>Deallocator</strong>调用<strong>Unsafe#freeMemory</strong>回收之前分配的堆外内存。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token function">DirectByteBuffer</span><span class="token punctuation">(</span><span class="token keyword">int</span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// package-private</span>  <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> cap<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">boolean</span> pa <span class="token operator">=</span> VM<span class="token punctuation">.</span><span class="token function">isDirectMemoryPageAligned</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> ps <span class="token operator">=</span> Bits<span class="token punctuation">.</span><span class="token function">pageSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">long</span> size <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>1L<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>cap <span class="token operator">+</span> <span class="token punctuation">(</span>pa <span class="token operator">?</span> ps <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  Bits<span class="token punctuation">.</span><span class="token function">reserveMemory</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">long</span> base <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">try</span> <span class="token punctuation">{</span>    base <span class="token operator">=</span> UNSAFE<span class="token punctuation">.</span><span class="token function">allocateMemory</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">OutOfMemoryError</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Bits<span class="token punctuation">.</span><span class="token function">unreserveMemory</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">throw</span> x<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  UNSAFE<span class="token punctuation">.</span><span class="token function">setMemory</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">byte</span><span class="token punctuation">)</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>pa <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>base <span class="token operator">%</span> ps <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Round up to page boundary</span>    address <span class="token operator">=</span> base <span class="token operator">+</span> ps <span class="token operator">-</span> <span class="token punctuation">(</span>base <span class="token operator">&amp;</span> <span class="token punctuation">(</span>ps <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    address <span class="token operator">=</span> base<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  cleaner <span class="token operator">=</span> Cleaner<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Deallocator</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> size<span class="token punctuation">,</span> cap<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  att <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Cleaner</strong>跟踪<strong>DirectByteBuffer</strong>对象的垃圾回收，最终通过<strong>Deallocator</strong>调用<strong>Unsafe#freeMemory</strong>回收<strong>DirectByteBuffer</strong>上分配的堆外内存的整体流程如下图。当<strong>DirectByteBuffer</strong>对象不可达时，垃圾收集器会将<strong>DirectByteBuffer Reference</strong>加入的<strong>pending链表</strong>中，而守护线程<strong>ReferenceHandler</strong>，会不断地从<strong>pending链表</strong>中获取节点处理，如果节点的<strong>Reference</strong>类型为<strong>PhantomReference</strong>引用的子类<strong>Cleaner</strong>，守护线程在处理时会调用该<strong>Refence</strong>绑定的<strong>Cleaner#clean方法</strong>，即<strong>DirectByteBuffer</strong>绑定的<strong>Cleaner</strong>，这个<strong>Cleaner</strong>会通过<strong>Deallocator#run</strong>方法调用<strong>Unsafe#freeMemory</strong>，最终实现<strong>DirectByteBuffer</strong>上分配的堆外内存被回收。</p><img src="https://gitee.com/0909/blog/raw/master/img/20211112151451.png" style="zoom:80%;" /><p>具体的源码分析可以参考我之前的文章<a href="https://mp.weixin.qq.com/s/8f29ZfGvZVPe0bO-FahokQ">Java Reference核心原理分析</a>。</p><h4 id="5-线程调度"><a href="#5-线程调度" class="headerlink" title="5 线程调度"></a>5 线程调度</h4><p>​        <strong>JDK</strong>内部有一个很重要的类<strong>LockSupport</strong> ，Java锁和同步器框架的核心类<strong>AbstractQueuedSynchronizer</strong>中线程的挂起与恢复全依赖于<strong>LockSupport#park方法与LockSupport#unpark方法</strong>，而<strong>LockSupport</strong>类的<strong>park</strong>方法、<strong>unpark</strong>方法分别依赖于<strong>Unsafe</strong>类的<strong>park</strong>方法、<strong>unpark</strong>方法。</p><p><strong>JDK11</strong>中<strong>LockSupport</strong>类与<strong>Unsafe</strong>类中线程调用相关方法如下。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//LockSupport类park与unpark方法</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">park</span><span class="token punctuation">(</span>Object blocker<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">setBlocker</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> blocker<span class="token punctuation">)</span><span class="token punctuation">;</span>  U<span class="token punctuation">.</span><span class="token function">park</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> 0L<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">setBlocker</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">unpark</span><span class="token punctuation">(</span>Thread thread<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>thread <span class="token operator">!=</span> null<span class="token punctuation">)</span>    U<span class="token punctuation">.</span><span class="token function">unpark</span><span class="token punctuation">(</span>thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Unsafe类park与unpark方法</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">unpark</span><span class="token punctuation">(</span>Object thread<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">park</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> isAbsolute<span class="token punctuation">,</span> <span class="token keyword">long</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>注意：JDK8的Unsafe中还有monitorEnter、monitorExit、tryMonitorEnter方法，但在JDK11的jdk.internal.misc.Unsafe类中已将这些方法移除。</strong></p><h4 id="6-CAS操作"><a href="#6-CAS操作" class="headerlink" title="6 CAS操作"></a>6 CAS操作</h4><p>​        <strong>CAS操作</strong>是<strong>Compare And Swap</strong>的简写，其核心思想是先比较再交互，有点类似是乐观锁，通过version比较再进行更新，如果version值发生变化则更新将失败。其将预期原值与当前原值比较，如果相同则表示未发生改变，则用新值去更新原值，否则代表原值已改变<strong>CAS操作</strong>将失败。<strong>Unsafe</strong>底层实现<strong>CAS操作</strong>依赖于CPU的原子指令（<strong>cmpxchg指令</strong>)。</p><p><strong>JDK11</strong>中<strong>jdk.internal.misc.Unsafe</strong>类提供了如下<strong>CAS操作</strong>方法，<strong>JDK8</strong>以后<strong>Swap</strong> 这个单词被换成了<strong>Exchange</strong>，之前版本都是<em><strong>compareAndSwap</strong></em>***这类的方法。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 同时针对Long、Byte、Boolean等提供的类似的compareAndExchange***方法</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">compareAndExchangeInt</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> expected<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 同时针对Long、Byte、Boolean等提供的类似的compareAndSet***方法</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSetInt</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> expected<span class="token punctuation">,</span> <span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> Object <span class="token function">compareAndExchangeObject</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span>    Object expected<span class="token punctuation">,</span> Object x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSetObject</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span>Object expected<span class="token punctuation">,</span>    Object x<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        <strong>CAS操作</strong>在<strong>AtomicInteger</strong>类中大量使用，如下源码中<strong>VALUE</strong>代表<strong>AtomicInteger</strong>中存储的实际value值相对的内存地址偏移量，有了这偏移量后，便可调用<strong>Unsafe</strong>类的<strong>CAS</strong>操作。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicInteger</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span> <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> jdk<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Unsafe U <span class="token operator">=</span> jdk<span class="token punctuation">.</span>internal<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Unsafe<span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> VALUE <span class="token operator">=</span> U<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span><span class="token punctuation">(</span>AtomicInteger<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-对象操作"><a href="#7-对象操作" class="headerlink" title="7 对象操作"></a>7 对象操作</h4><p>​        对象操作主要是先通过<strong>Field</strong>或是<strong>Class</strong>与变量名获取对象成员属性相对于对象本身的内存地址的偏移量，然后再利用这个内存偏移量做一些其他的操作比如设置变量值、通过<strong>CAS操作</strong>设置值、采用<strong>volatile</strong>的存储语义写变量的值、采用<strong>volatile</strong>的加载语义读取变量的值。还一个<strong>allocateInstance</strong>方法，可以该方法可发绕过构造方法创建对象，只要传入对应的class就行，并且其不需要初始化代码、JVM安全检查等。</p><p><strong>JDK11</strong>中<strong>jdk.internal.misc.Unsafe</strong>类提供了如下对象操作方法：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//通过Field获取对象成员属性相对于对象本身的内存地址的偏移量</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">long</span> <span class="token function">objectFieldOffset</span><span class="token punctuation">(</span>Field f<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//通过Class与变量名，获取对象成员属性相对于对象本身的内存地址的偏移量</span><span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">objectFieldOffset</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> c<span class="token punctuation">,</span> String name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获得给定对象的指定地址偏移量的值，还有基于int、long、char等类似的操作</span><span class="token keyword">public</span> <span class="token keyword">native</span> Object <span class="token function">getObject</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//给定对象的指定地址偏移量设值，还有基于int、long、char等类似的操作</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">putObject</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> Object x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//从对象的指定偏移量处获取变量的引用，采用volatile的加载语义，还有基于int、long、char等类似的操作</span><span class="token keyword">public</span> <span class="token keyword">native</span> Object <span class="token function">getObjectVolatile</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//存储变量的引用到对象的指定的偏移量处，采用volatile的存储语义，还有基于int、long、char等类似的操作</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">putObjectVolatile</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> Object x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//有序、延迟版本的putObjectVolatile方法，不保证值的改变被其他线程立即看到。</span><span class="token comment" spellcheck="true">// 只有在field被volatile修饰符修饰时有效，还有基于int、long、char等类似的操作</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">putOrderedObject</span><span class="token punctuation">(</span>Object o<span class="token punctuation">,</span> <span class="token keyword">long</span> offset<span class="token punctuation">,</span> Object x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//绕过构造方法、初始化代码来创建对象</span><span class="token keyword">public</span> <span class="token keyword">native</span> Object <span class="token function">allocateInstance</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> cls<span class="token punctuation">)</span> <span class="token keyword">throws</span> InstantiationException<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="8-数组操作"><a href="#8-数组操作" class="headerlink" title="8 数组操作"></a>8 数组操作</h4><p>​        数组相关的操作主要有<strong>arrayBaseOffset</strong>与<strong>arrayIndexScale</strong>这两个方法，<strong>arrayBaseOffset</strong>用于获取数组首个元素相对的内存地址偏移量，而<strong>arrayIndexScale</strong>用于获取数组中一个元素占用内存的大小，两者配合起来使用，便可定位数组中每个元素在内存地址中的位置。然后结合上面的对象操作方法，设置获取、更改数组元素的值。</p><p><strong>JDK11</strong>中<strong>jdk.internal.misc.Unsafe</strong>类提供了如下数组操作方法：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//获取数组首个元素相对的内存地址偏移量</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">arrayBaseOffset</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> arrayClass<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//取数组中一个元素占用内存的大小</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">arrayIndexScale</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> arrayClass<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>​        <strong>JDK8</strong>中<strong>AtomicIntegerArray、AtomicLongArray</strong>便结合这个方法来操作其内存存储数据的数组。<strong>JDK9</strong>后已改用<strong>VarHandler</strong>内部的方法。</p><p><strong>JDK8</strong>中的<strong>AtomicIntegerArray</strong>部分源码</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicIntegerArray</span> <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Unsafe unsafe <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获取数组首个元素相对的内存地址偏移量</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> base <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">arrayBaseOffset</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> shift<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//取数组中一个元素占用内存的大小</span>        <span class="token keyword">int</span> scale <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">arrayIndexScale</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>scale <span class="token operator">&amp;</span> <span class="token punctuation">(</span>scale <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"data type scale not a power of two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        shift <span class="token operator">=</span> <span class="token number">31</span> <span class="token operator">-</span> Integer<span class="token punctuation">.</span><span class="token function">numberOfLeadingZeros</span><span class="token punctuation">(</span>scale<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//通过下标计算index为i的元素，相对的内存地址偏移量</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">byteOffset</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> i <span class="token operator">&lt;&lt;</span> shift<span class="token punctuation">)</span> <span class="token operator">+</span> base<span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token keyword">private</span> <span class="token keyword">long</span> <span class="token function">checkedByteOffset</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> i <span class="token operator">>=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token string">"index "</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">byteOffset</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//通过上面7小节中的对象操作，在指定内存地址中采用volatile的存储语义写入值</span>      <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        unsafe<span class="token punctuation">.</span><span class="token function">putIntVolatile</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token function">checkedByteOffset</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>Unsafe</strong>类中有<strong>Class</strong>与系统的操作就不一一看了，感兴趣的同学可以自己看一下<strong>Unsafe</strong>的源码。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​        本文介绍了<strong>JDK</strong>中的黑科技<strong>Unsafe</strong>类，按功能进行了归类划分，并介绍了这些方法的使用场景，部分功能还结合了源码进行了简单地分析。还是那句话<strong>Unsafe</strong>类提供了一些用于执行低级别、不安全操作的<strong>native方法</strong>，如直接访问系统内存资源、自主管理内存资源等，不会用千万别乱用（它是<strong>unsafe</strong>的），但作为黑科技不了解怎么算得算是Java工程师呢。</p><h4 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h4><p>​        原创不易，点赞、在看、转发是对我莫大的鼓励，关注公众号洞悉源码是对我最大的支持。同时相信我会分享更多干货，我同你一起成长，我同你一起进步。</p>]]></content>
      
      
      <categories>
          
          <category> JDK源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Unsafe </tag>
            
            <tag> StampedLock </tag>
            
            <tag> DirectByteBuffer </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入浅出Java内存模型</title>
      <link href="/2021/11/03/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAJava%20Memory%20Model/"/>
      <url>/2021/11/03/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAJava%20Memory%20Model/</url>
      
        <content type="html"><![CDATA[<h3 id="深入浅出Java内存模型"><a href="#深入浅出Java内存模型" class="headerlink" title="深入浅出Java内存模型"></a>深入浅出Java内存模型</h3><h4 id="Java-内存模型概述"><a href="#Java-内存模型概述" class="headerlink" title="Java 内存模型概述"></a>Java 内存模型概述</h4><p>​        <strong>Java 内存模型</strong>（<strong>Java Memory Model，JMM</strong>）其主要的目标是定义程序中各个变量的访问规则，即虚似机中将变量储存到内存与从内存中取出变量这样的底层细节。<strong>JMM</strong> 是一个抽象的概念，它描述了一系列的规则或者规范，用来解决多线程的共享变量访问问题。这里所说的变量，包括实例字段、静态字段，但<strong>不包括局部变量和方法参数，因为后者是线程私有的，不存在数据竞争问题，即没有线程安全问题</strong>。</p><p>​        从<strong>JMM</strong>本身角度理解，可以分为二方面，一方面其抽象了<strong>主内存（Main Memory ）与工作内存（Work Memory）</strong>的概念，另一方面其定义了<strong>一组保障内存可见性与正确性的规范</strong>。<strong>JMM</strong>抽象出了<strong>主内存</strong>与<strong>工作内存</strong>的概念，<strong>主内存</strong>中存储了线程之间的共享变量，<strong>工作内存</strong>是通过对缓存、寄存器、写缓冲区等的抽象，每个线程都有一个私有的<strong>工作内存</strong>，<strong>工作内存</strong>中存储了<strong>主内存</strong>中共享变量对应的副本。线程在执行时先从<strong>主内存</strong>加载数据<strong>工作内存</strong>，然后执行逻辑后再将数据刷新回<strong>主内存</strong>，使该数据对其他线程可见。如果没有一定的规范与约束，这种模型明显存在数据一致性的问题（由于Java编译器指令重排序优化和CPU乱序执行优化的存在，使得问题变得更加复杂）。所以<strong>JMM</strong>基于内存屏障（<strong>Memory-Barrier</strong>）提供了类似<strong>as if serial</strong>与<strong>happens-before</strong>的保障，最终保障了多线程之间操作的可见性与正确性。</p><p>​        而从<strong>JMM</strong>使用者的角度理解，<strong>JMM</strong>平衡了<strong>JVM</strong>工程师、编译器工程师在性能上的需求与<strong>Java</strong>程序员开发安全的简单性上的渴望。<strong>JMM在保证正确性的同时会最大限度的放宽对指令重排和乱序执行的限制</strong>。对于<strong>Java</strong>程序员，<strong>JDK</strong>提供了如<strong>volatile</strong>关键字、<strong>synchronized</strong>关键字、<strong>final</strong>关键字、<strong>Java</strong>并发类这样的顶层机制，为程序员提供简单的编程模型。</p><h4 id="Java为什么需要内存模型"><a href="#Java为什么需要内存模型" class="headerlink" title="Java为什么需要内存模型"></a>Java为什么需要内存模型</h4><p>​        为了提升计算机的运行效率，编译器、内存系统通常会对指令进行重排，处理器会对指令进行乱序/并行执行，处理器与主内存之间存在高速缓存以减少CPU的等待时间。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211109113941.png"></p><p>​        处理器优化其实也是重排序的一种类型，重排序可分三大类</p><ul><li><strong>编译器优化的重排序</strong> ， 编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。</li><li><strong>指令级并行的重排序</strong> ，现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li><strong>内存系统的重排序</strong>，由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ul><p>​        类似上面的这些优化给并发编程带来了<strong>一致性</strong>、<strong>可见性</strong>、<strong>有序性</strong>等问题。这些问题从深层次来看与<strong>缓存一致性</strong>、<strong>处理器优化</strong>、<strong>指令重排序</strong>有关。<strong>JMM</strong>就是为了解决这些问题而提出的，其通过抽象内存模型，制定类似<strong>as if serial</strong>与<strong>happens-before</strong>的规则来屏蔽底层编译器、内存系统、处理器重排的细节，最终为<strong>Java</strong>工程师提供更加清晰、简单的编程模型。</p><p>​        编译器/JVM工程师，会根据<strong>Java</strong>语言规范中对<strong>JMM</strong>的规定，去处理不同平台、不同处理器架构上的差异，通过使用类似<strong>内存屏障（Memory-Barrier）</strong>之类技术，保证执行结果符合 <strong>JMM</strong> 的推断。而<strong>Java</strong>工程师，则不用关心这些细节，通过遵守 <strong>happens-before 规则</strong>、<strong>volatile</strong>语义、<strong>synchronized</strong>语义、<strong>final</strong> 语义以及合理地使用<strong>Java</strong>并发包下的相关类，便可写出可靠的多线程应用。虽然单线程下面也会出现上面说的编译器重排，处理器乱序执行等问题，但其都遵守<strong>as-if-serial语义</strong>，即编译器与处理器怎么优化后都能保证单线程下面程序执行结果的可预测性与正确性。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211108133444.png"></p><p>​        从上面可以很直观的看到，<strong>JMM</strong>的引入使得<strong>Java</strong>工程师、编译器/<strong>JVM</strong>工程师、处理器工程师之间的关注点进行有效的分层隔离，不同架构的CPU对最上层的应用程序的<strong>Java</strong>工程师而言已是透明的，<strong>Java</strong>工程师将更聚焦于业务逻辑的开发。</p><h4 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h4><p>​        前面说到JMM抽象了<strong>主内存</strong>与<strong>工作内存</strong>，<strong>主内存</strong>中存储了线程间的共享变量，通过对缓存、寄存器、写缓冲区等的抽象每个线程都有一个私有的<strong>工作内存</strong>，<strong>工作内存</strong>中存储了主内存对应的副本。线程对变量的读写操作都发生在其自身的<strong>工作内存</strong>中，而不能直接操作<strong>主内存</strong>中的变量。线程不能直接读写其他线程私有<strong>工作内存</strong>中的数据，线程间的变量传必须通过<strong>主内存</strong>完成。<strong>JMM</strong>规定了线程应该何时从<strong>主内存</strong>中加载数据到<strong>工作内存</strong>，何时又该将<strong>工作内存</strong>中的副本数据刷新到<strong>主内存</strong>，使数据对其他线程可见。这种可见性机制在<strong>JMM</strong>中是通过<strong>happens-before规则</strong>定义的，而具体<strong>JVM</strong>实现上则是通类似<strong>内存屏障（Memory-Barrier）</strong>之类的技术。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211108172615.png"></p><p>​        如上图，如果线程A在<strong>工作内存</strong>中修改变量X要对线程B可见的话，其首先要将变量X刷新回<strong>主内存</strong>，当变量X被刷新回<strong>主内存</strong>时，线程B立刻能感知到（底层实现上是通过<strong>总线嗅探</strong>）其<strong>工作内存</strong>中的变量X对应<strong>主内存</strong>的值已被修改，于是线程B会将其<strong>工作内存</strong>变量X设置为失效，当线程B后继的操作如果要用户变量X时又会重新从<strong>主内存</strong>加载最新的值。</p><p>​        <strong>JMM</strong>抽象出的<strong>主内存</strong>与<strong>工作内存</strong>的概念，很容易让人想起多核<strong>CPU</strong>架构下的硬件内存模型。<strong>JMM</strong>中的主内存可以理解为计算机的主内存，而<strong>JMM</strong>中的工作内存可以理解为<strong>CPU</strong>中集成的高缓存缓存（<strong>L1 Cache</strong>、<strong>L2 Cache</strong>、<strong>Register</strong>等）。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211109140026.png"></p><p>​        硬件内存模型中，各核高速缓存、主内存之间存在<strong>缓存一致性</strong>问题，然后通过缓存一致性协议、总线加锁等方式去解决该问题。类似的<strong>JMM</strong>为解决<strong>缓存一致性</strong>问题，提出了<strong>happens-before规则</strong>，同时采用保<strong>内存屏障技术</strong>实现<strong>happens-before规则</strong>。</p><h4 id="happens-before规则"><a href="#happens-before规则" class="headerlink" title="happens-before规则"></a>happens-before规则</h4><p>​        <strong>JMM</strong>中最重要的概念是<strong>happens-before规则</strong>，其描述了两个操作的内存可见性。如果要保证操作X的结果对操作Y可见（如果操作X与操作Y是否在同一个线程中），那么操作 X要 <strong>happens-before</strong> 操作 Y。如果操作X与操作Y之间不存在 <strong>happens-before</strong> 关系，则JVM可以对操作X与操作Y任意重排。</p><p>​        当一个共享变量被多个线程读写时，如果在读操作与写操作之间没有依照<strong>happens-before规则</strong>，那就会发生<strong>数据竞争</strong>（发生<strong>数据竞争</strong>时程序的执行结果将不可预测）。<strong>JMM</strong>中有如下的<strong>happens-before规则</strong>：</p><ul><li><strong>程序顺序规则</strong>：一个线程中的每个操作，<strong>happens-before</strong>于该线程中的任意后续操作。</li><li><strong>volatile变量规则</strong>：对一个<strong>volatile</strong>变量的写，<strong>happens-before</strong>于任意后续对这个<strong>volatile</strong>变量的读。</li><li><strong>监视器锁定规则</strong>：对对象的<strong>unLock</strong>操作<strong>happens-before</strong>于后面对同一个对象的<strong>lock</strong>操作。</li><li><strong>线程中断规则</strong>：对线程 <strong>interrupt()</strong> 的调用<strong>happens-before</strong>于线程代码中检测到中断事件的发生，可以通过 <strong>Thread.interrupted()</strong> 方法检测是否发生中断。</li><li><strong>线程启动规则</strong>：对线程 <strong>start()</strong> 的操作<strong>happens-before</strong>于线程内的任何操作。</li><li><strong>对象终结规则</strong>：一个对象的初始化完成<strong>happens-before</strong>于它的 <strong>finalize()</strong> 方法的开始。</li><li><strong>传递规则</strong>：如果操作 A <strong>happens-before</strong>于操作 B，而操作 B 又<strong>happens-before</strong>于操作 C，则可以得出操作 A <strong>happens-before</strong>于操作 C。</li></ul><p>​        来看一下平时开发中经常用到的<strong>volatile关键字</strong>与<strong>synchronized关键字</strong>，在<strong>happens-before</strong>规则下的效果。<strong>volatile关键字遵守volatile变量规则</strong>，<strong>其效果是一个线程对taskRunningFlag类型变量的写操作的结果，立刻对其他任意线程对同一个变量的读操作可见</strong>。</p><pre class="line-numbers language-Java"><code class="language-Java">public class App {  private volatile boolean taskRunningFlag = true;  public static void main(String[] args) {    new App().runTask();  }  public void runTask() {    Runnable task = () -> {      long startTime = System.currentTimeMillis();      while (taskRunningFlag) {        System.out.println("Task is running !");        try {          Thread.sleep(100);        } catch (InterruptedException e) {          e.printStackTrace();        }      }      System.out.println("Task run " + (System.currentTimeMillis() - startTime) + "ms !");    };    new Thread(task).start();    Runnable taskController = () -> {      try {        Thread.sleep(500);      } catch (InterruptedException e) {        e.printStackTrace();      }      System.out.println("After 500 ms stop task !");      taskRunningFlag = false;    };    new Thread(taskController).start();  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><blockquote><p>Task is running !<br>Task is running !<br>Task is running !<br>Task is running !<br>Task is running !<br>After 500 ms stop task !<br>Task run 520ms !</p></blockquote><p>可以看到任务线程一直在进行，直到500ms后任务控制线程将taskRunningFlag设置为false，由于任务控制线程与任务线程在并行运行，任务最终运行时间会略微超过500ms，这里任务运行了520ms，但volatile类型的taskRunningFlag的写操作是对其他线程立即可见的。<strong>注意</strong>：<strong>volatile关键字可以保障单条指令操作的可见性，但不保障多个指令操作的可见性即不保障操作原子性，x++，++x，–x，x–这类操作编译后都对应多个指令所以使用volatile关键字也不能保证操作的可见性，要用AtomicInteger，synchronized关键字等替代。</strong></p><p>​        <strong>synchronized关键字遵守监视器锁定规则，其效果是一个已获得锁的代码块或方法在释放锁之前，其内部的所有操作的结果，对于即将获得到同一把锁的其他线程可见。</strong></p><img src="https://gitee.com/0909/blog/raw/master/img/20211110094418.png" style="zoom:80%;" /><p>​    </p><p>​        <strong>视器锁定规则的可见性，实际将原子性涵盖进来了，因为其保证的是unlock Monitor 之前的所有操作对于lock Monitor 之后的操作都可见</strong>。如上图线程X中对变量y与变量z的赋值操作，对于后继锁定同一个Monitor的线程Y都是可见的。<strong>注意：线程X与线程Y一定要锁同一个对象的Monitor，才能保障这种可见性规则。别外，JMM在保证正确性的同时会最大限度的放宽对指令重排和乱序执行的限制了。这意味着线程X同步代码块内 y= 7与z = 3是可以进行重排的，只是整个同步代码块内部的操作不会与同步代码块外部的操作重排，理解这点非常重要。</strong></p><h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>​        <strong>happens-before规则属于JMM保证可见性的规范，而非具体实现</strong>。编译器工程师、JVM工程师在实现编译器与<strong>JVM</strong>时，会根据这个规范在适当的位置利用<strong>内存屏障（Memory Barrier）</strong>技术禁止指令重排保证可见性。<strong>内存屏障</strong>可分为<strong>读屏障（Load Barriers）</strong>和<strong>写屏障（Store Barriers）</strong>，<strong>JMM</strong> 中对这两者进行结合共有四种屏障<strong>Load-Load Barriers、Load-Store Barriers、Store-Store Barriers、Store-Load Barriers</strong>。下面看一下不同内存屏障的插入会达到什么要的效果。</p><pre class="line-numbers language-c"><code class="language-c">load1 LoadLoad load2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>保证 load1 数据的装载优先于 load2 以及所有后续装载指令的装载。对于 Load Barrier 来说，在指令前插入 Load Barrier，可以让高速缓存中的数据失效，强制重新从主内存加载数据。</p></blockquote><pre class="line-numbers language-c"><code class="language-c">load1 LoadStore store2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>保证 load1 数据装载优先于 store2 以及后续的存储指令刷新到内存。</p></blockquote><pre class="line-numbers language-c"><code class="language-c">store1 StoreStore store2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>保证 store1 数据对其他处理器可见，优先于 store2 以及所有后续存储指令的存储。对于 Store Barrier 来说，在指令后插入 Store Barrier，能让写入缓存中的最新数据更新写入主内存，让其他线程可见。</p></blockquote><pre class="line-numbers language-c"><code class="language-c">store1 StoreLoad load2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><blockquote><p>在load2 及后续所有读取操作执行前，保证 store1 的写入对所有处理器可见。这条内存屏障指令是一个全能型的屏障，它同时具有其他 3 条屏障的效果，而且它的开销也是四种屏障中最大的一个。</p></blockquote><h4 id="Double-Check-Lock-问题"><a href="#Double-Check-Lock-问题" class="headerlink" title="Double-Check Lock 问题"></a>Double-Check Lock 问题</h4><p>​        单例模式中经常会通过 <strong>Double-Check Lock</strong> 实现实例的惰性加载。单不正确的使用 <strong>Double-Check Lock</strong> 却会带来线程安全问题。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonInstance</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> SingletonInstance instance<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonInstance <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>SingletonInstance<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>          instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> instance<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>​        上面的代码，看似能通过<strong>synchronized关键</strong>字保证了顺序性，达到获取正确的SingletonInstance实例，实际却有可能获取到未完全构建的SingletonInstance实例。原因在于 **instance = new SingletonInstance();**这行代码实际可以分为三条指令:</p><blockquote><p>memory = allocate(); // 1：分配对象的内存空间 </p><p>ctorInstance(memory); // 2：初始化对象 </p><p>instance = memory; // 3：设置instance指向刚分配的内存地址 </p></blockquote><p>前面强调过<strong>JMM在保证正确性的同时会最大限度的放宽对指令重排和乱序执行的限制了，这意味着同步代码块/方法内可以进行重排的，只是整个同步代码块/方法内部的操作不会与同步代码块/方法外部的操作重排</strong>。所以在编译器、CPU重排优化后，最后的同步块内的指令执行顺序可能如下：</p><blockquote><p>memory = allocate(); // 1：分配对象的内存空间 </p><p>instance = memory; // 3：设置instance指向刚分配的内存地址 </p><p>ctorInstance(memory); // 2：初始化对象 </p></blockquote><p>现在再来看看线程A与线程B同时调用**SingletonInstance.getInstance()**方法可能出现的结果。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211110151913.png"></p><p>如上图紫色为线程A的操作，橙色为线程B的操作。当instance初始为null时，线程A与线程B交替执行后会出现上面的先后执行顺序。最终导致线程B获取到了线程A未完成构建的对象。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211110151722.png"></p><p>如何处理该问题呢？可以用<strong>volatile关键字</strong>修饰instance变量，达到禁示分配对象的内存空间、初始化对象、设置instance指向内存地址这三步重排的。正确<strong>Double-Check Lock</strong> 实现的单例模式如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SingletonInstance</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">volatile</span> SingletonInstance instance<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> SingletonInstance <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>SingletonInstance<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>          instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingletonInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> instance<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h4><p>​        翻译不易，点赞、在看、转发是对我莫大的鼓励，关注公众号洞悉源码是对我最大的支持。同时相信我会分享更多干货，我同你一起成长，我同你一起进步。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="http://gee.cs.oswego.edu/dl/cpj/jmm.html">Synchronization and the Java Memory Model</a></p><p><a href="https://www.cs.umd.edu/~pugh/Java/memoryModel/jsr-133-faq.html">JSR 133 (Java Memory Model) FAQ</a></p><p><a href="http://www.cs.umd.edu/~pugh/Java/memoryModel/DoubleCheckedLocking.html">The “Double-Checked Locking is Broken” Declaration</a></p><p>《Java Concurrency in Practice》</p><p><a href="https://www.infoq.cn/minibook/Java_memory_model">深入理解Java内存模型</a></p><p>《深入理解Java虚似机》</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
            <tag> synchronized </tag>
            
            <tag> JMM </tag>
            
            <tag> double-check </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解ThreadLocal</title>
      <link href="/2021/10/25/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3ThreadLocal/"/>
      <url>/2021/10/25/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3ThreadLocal/</url>
      
        <content type="html"><![CDATA[<h3 id="一文详解JDK中的ThreadLocal"><a href="#一文详解JDK中的ThreadLocal" class="headerlink" title="一文详解JDK中的ThreadLocal"></a>一文详解JDK中的ThreadLocal</h3><h4 id="1-ThreadLocal概述"><a href="#1-ThreadLocal概述" class="headerlink" title="1 ThreadLocal概述"></a>1 ThreadLocal概述</h4><p>​        <strong>ThreadLocal</strong> 提供了<strong>一种变量与线程绑定的机制</strong>，通常把这种机制称为<strong>线程本地变量</strong>，在线程调用栈（方法调用链）的入口或中间可以让一些重要的变量与线程绑定，在后继的调用栈（方法调用链）可使用该变量。这个特性使得<strong>ThreadLocal适用于方法调用链上参数透传</strong>，如APM、日志、权限框架中透传上游重要的参数到下游。</p><p>​        <strong>ThreadLocal不支持不同线程间变量的透传</strong>，即如果在线程A中设置了一个变量ThreadLocalA 其中存储的值为AA，在线程B中想拿到ThreadLocalA 中存储的AA是拿不到的（结果将是null）。这也导致了使用线程池的线程，不能通过<strong>ThreadLocal</strong>将<strong>线程本地变量</strong>传递到线程池中供其使用（线程池中执行任务的线程通常不是提交任务对应的线程），同样类似线程间的异步操作<strong>ThreadLocal</strong>也不支持。线程间<strong>线程本地变量</strong>的透传可以通过阿里开源的<strong>TrasmittableThreadLocal</strong>来实现。当子线程要获取父线程中的<strong>线程本地变量</strong>，通过ThreadLocal同样无法获取，但可能通过其子类<strong>InheritableThreadLocal</strong>实现。</p><p>​        在高并发场景下，JDK自带的<strong>ThreadLocal</strong>性能不如<strong>Netty</strong>框架中实现的<strong>FastThreadLocal</strong>，<strong>FastThreadLocal</strong> 获取其中保证的变量值时，使用内部的index变量便可定位对应变量值，而不用像ThreadLocal那样通过<strong>开放地址法</strong>去定位对应变量值。</p><p>​        <strong>ThreadLocal</strong> 的线程本地变量机制实际是通过 <strong>Thread</strong>类中的<strong>ThreadLocalMap</strong>成员变量实现的。每一个<strong>Thread</strong>实例都维护了一个<strong>ThreadLocalMap</strong>实例。<strong>ThreadLocalMap</strong>通过<strong>开放地址法</strong>实现，其<strong>Key</strong>为<strong>ThreadLocal</strong>，<strong>Value</strong>为<strong>ThreadLocal</strong>中保存的变量。其<strong>开放地址法</strong>底层对应的数组为<strong>Entry数组</strong>，<strong>Entry</strong>类持有了<strong>ThreadLocal</strong>的<strong>WeakReference</strong>，持有了<strong>ThreadLocal</strong>中保存变量的强引用，这导致了不恰当的使用ThreadLocal容易引发内存泄漏问题。</p><h4 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h4><p><strong>注意：下面的ThreadLocal的源码分析基本JDK8</strong></p><h5 id="2-1-引用类型"><a href="#2-1-引用类型" class="headerlink" title="2.1 引用类型"></a>2.1 引用类型</h5><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <strong>ThreadLocal</strong>类本身比较简单其支持泛型，一共没有几行代码，其set与get方法上复杂的处理最终都到了内部类类<strong>ThreadLocalMap</strong>上，并且<strong>ThreadLocalMap</strong>使用<strong>WeakReference</strong>所涉及的东西比较多。<strong>Reference</strong>的源码分析参考之前的文章<a href="https://mp.weixin.qq.com/s/8f29ZfGvZVPe0bO-FahokQ">Java Reference核心原理分析</a>。</p><p>​            这里先简单介绍一下java语言中的引用类型。java语言中引用类型分为<strong>强引用、软引用（SoftReference）、弱引用（WeakReference）、虚引用（PhantomReference）</strong>。</p><ul><li><p><strong>强引用</strong></p><p>通常代码中看到的变量引用关系如下面的 threadLocalData，variable对对象的引用都是强引用</p><pre class="line-numbers language-java"><code class="language-java">ThreadLocal<span class="token operator">&lt;</span>Integer<span class="token operator">></span> threadLocalData <span class="token operator">=</span> ThreadLocal<span class="token punctuation">.</span><span class="token function">withInitial</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String variable <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>软引用 （SoftReference）</strong></p><p>垃圾回收器会根据内存需求酌情回收软引用指向的对象。普通的GC并不会回收软引用，只有在即将<strong>OOM</strong>的时候(也就是最后一次<strong>Full GC</strong>)如果被引用的对象只有<strong>SoftReference</strong>指向的引用，才会回收。如下<strong>SoftValueReference</strong>便持有其值V的软引用。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SoftValueReference</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token keyword">extends</span>   <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">ValueReference</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>   <span class="token keyword">final</span> ReferenceEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> entry<span class="token punctuation">;</span>   <span class="token function">SoftValueReference</span><span class="token punctuation">(</span>ReferenceQueue<span class="token operator">&lt;</span>V<span class="token operator">></span> queue<span class="token punctuation">,</span> V referent<span class="token punctuation">,</span>                                                  ReferenceEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> entry<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">super</span><span class="token punctuation">(</span>referent<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>entry <span class="token operator">=</span> entry<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>弱引用（WeakReference）</strong></p><p>当发生GC时，如果当前对象只有<strong>WeakReference</strong> 类型的引用，则会被GC给回收掉。如下<strong>ThreadLocalMap</strong> map中的<strong>Entry</strong>便持有<strong>ThreadLocal</strong>的软引用。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/** The value associated with this ThreadLocal. */</span>  Object value<span class="token punctuation">;</span>  <span class="token function">Entry</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> k<span class="token punctuation">,</span> Object v<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    value <span class="token operator">=</span> v<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>虚引用（PhantomReference）</strong></p><p>他是一种特殊的引用类型，不能通过虚引用获取到其关联的对象，但当GC时如果其引用的对象被回收，这个事件程序可以感知，这样我们可以做相应的处理。其最常用的场景是GC回收<strong>DirectByteBuffer</strong>对象时，利用<strong>Cleaner</strong>调用Unsafe类回收其对应的堆外内存。具体源码分析可参考<a href="https://mp.weixin.qq.com/s/8f29ZfGvZVPe0bO-FahokQ">Java Reference核心原理分析</a>。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Cleaner</span> <span class="token keyword">extends</span> <span class="token class-name">PhantomReference</span><span class="token operator">&lt;</span>Object<span class="token operator">></span> <span class="token punctuation">{</span>         <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>​        前面简单地介绍了对象的引用类型，GC决定一个对象是否能被回收与当对象具有的引用类型有很大的关系。一般会从GC Root开始向下搜索，如果对象与GC Root之间存在直接或间接的强引用有关系，则当前对象强可到达，不能被回收。如对象与GC Root之间只存在直接或间接的软引用有关系，则当前对象软可到达，GC时会视当前内存情况确定是否回收该对象。如对象与GC Root之间只存在直接或间接的弱引用有关系，则当前对象弱可到达，GC时不管内存如何该对象将都被回收，但在GC前可以再次强引用该对象达到让该对象不被回收。如对象与GC Root之间只存在直接或间接的虚引用有关系，则当前对象虚可到达，GC时该对象将被回收。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211026153107.png"></p><p>​        上面ObjectA、ObjectB、ObjectC、ObjectD、ObjectE、ObjectF、ObjectG 7个对象。</p><ul><li>与GC Root存在直接或间接强引用关系的对象有 ObjectA，GC时ObjectA一定不会被回收。</li><li>与GC Root存在直接或间接软引用关系的对象有 ObjectB、ObjcetE，GC时ObjectB与ObjectE可能会被回收。</li><li>与GC Root存在直接或间接弱引用关系的对象有 ObjectC、ObjectF，GC时ObjectC与ObjectF一定会被回收。</li><li>与GC Root存在直接或间接虚引用关系的对象有 ObjectD、ObjectG，GC时ObjectD与ObjectG一定会被回收。</li></ul><h5 id="2-2-ThreadLocal-get、-set、-remove方法"><a href="#2-2-ThreadLocal-get、-set、-remove方法" class="headerlink" title="2.2 ThreadLocal#get、#set、#remove方法"></a>2.2 ThreadLocal#get、#set、#remove方法</h5><p>​    <strong>ThreadLocal#get</strong>整体逻辑相对简单，具体分析见下面代码的注解。当未给<strong>ThreadLocal</strong>设置值时，<strong>get</strong>方法将调用<strong>setInitialValue</strong>方法返回<strong>initialValue</strong>方法指定的<strong>ThreadLocal</strong>的初始值，默认<strong>ThreadLocal</strong>的<strong>initialValue</strong>为null。<strong>ThreadLocal#get</strong>方法实际是用其自身作为Key通过开放寻址法在其所属线程的<strong>ThreadLocalMap</strong>上查找对应的value（与线程绑定的变量）。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//获取当前线程</span>  Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//从线程中获取成员变量ThreadLocalMap，此时ThreadLocalMap可能没被初始化</span>  ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//当前线程成员变量ThreadLocalMap已初始化</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//用this(当前ThreadLocal)为Key从ThreadLocalMap的Entry数组中找到对应的value</span>    ThreadLocalMap<span class="token punctuation">.</span>Entry e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//entry存在直接从其中拿出对应的值，然后返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>      T result <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>      <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//当前线程成员变量ThreadLocalMap未初始化或者在其Entry数组中未找到对应的value, 设置value值</span>  <span class="token keyword">return</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//设置ThreadLocal初始化值</span><span class="token keyword">private</span> T <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//获取ThreadLocal的初始化值</span>  T value <span class="token operator">=</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//获取当前线程</span>  Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//从线程中获取成员变量ThreadLocalMap，此时ThreadLocalMap可能没被初始化</span>  ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//在ThreadLocalMap上设置当前ThreadLocal对应值</span>    map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>      <span class="token comment" spellcheck="true">//为当前线程设置成员变量ThreadLocalMap值</span>    <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//为线程成员变量ThreadLocalMap设置值，同时将当前的TheadLocal对的值绑定到ThreadLocalMap上</span><span class="token keyword">void</span> <span class="token function">createMap</span><span class="token punctuation">(</span>Thread t<span class="token punctuation">,</span> T firstValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>  t<span class="token punctuation">.</span>threadLocals <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalMap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> firstValue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//默认ThreadLocal的initialValue为null，创建ThreadLocal对象时可以覆盖该方法指定初始值</span><span class="token keyword">protected</span> T <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ThreadLocal#set</strong>整体逻辑相对简单，具体分析见下面代码的注解。<strong>ThreadLocal#set</strong>方法实际是用其自身作为Key通过开放寻址法在其所属线程的<strong>ThreadLocalMap</strong>上将value与线程绑定。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//获取当前线程</span>    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//从线程中获取成员变量ThreadLocalMap，此时ThreadLocalMap可能没被初始化</span>    ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">//在ThreadLocalMap上设置当前ThreadLocal对应值</span>        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>          <span class="token comment" spellcheck="true">//为当前线程设置成员变量ThreadLocalMap值</span>        <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ThreadLocal#remove</strong>整体逻辑相对简单，<strong>ThreadLocal#remove</strong>方法实际是用其自身作为Key通过开放寻址法，将当前<strong>ThreadLocal</strong>与其所属线程解绑。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  ThreadLocalMap m <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">!=</span> null<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//将当前ThreadLocal与其对应的线程解绑</span>    m<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-3-ThreadLocalMap类"><a href="#2-3-ThreadLocalMap类" class="headerlink" title="2.3 ThreadLocalMap类"></a>2.3 ThreadLocalMap类</h5><p>​        从上面的<strong>ThreadLocal#get、#set、#remove</strong>方法分析可以看到，最终这些操作都是在<strong>ThreadLocalMap</strong>上完成。文中最开始已介绍过<strong>ThreadLocalMap</strong>实际是通过<strong>开放地址法</strong>实现的，其内部的<strong>Entry</strong>数据组table用于存储<strong>ThreadLocal</strong>与保存在<strong>ThreadLocal</strong>的值，最终实现<strong>ThreadLocal</strong>内保存的值与线程绑定。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// map的初始容量</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Entry数组</span>  <span class="token keyword">private</span> Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Entry元素个数</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 阈值，用于扩容降低开放寻址时的冲突</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> threshold<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//ThreadLocalMap中的Entry持有ThreadLocal的弱引用。</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ThreadLocal上关联的值</span>  Object value<span class="token punctuation">;</span>  <span class="token function">Entry</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> k<span class="token punctuation">,</span> Object v<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    value <span class="token operator">=</span> v<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ThreadLocalMap</strong>构造函数</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//创建ThreadLocalMap并在其上绑定第一个线程局部变量</span><span class="token function">ThreadLocalMap</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> firstKey<span class="token punctuation">,</span> Object firstValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>INITIAL_CAPACITY<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//取模获取引用ThreadLocal的Entry的下标</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> firstKey<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>INITIAL_CAPACITY <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>firstKey<span class="token punctuation">,</span> firstValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//设置扩容的阈值</span>    <span class="token function">setThreshold</span><span class="token punctuation">(</span>INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ThreadLocalMap#getEntry</strong>方法以<strong>ThreadLocal</strong>作为<strong>Key</strong>从<strong>ThreadLocalMap</strong>采用<strong>开放寻址法</strong>从<strong>Entry</strong>数组中寻找引用<strong>ThreadLocal</strong>对应的<strong>Entry</strong>。<strong>ThreadLocal#get</strong>方法会调用该方法，获取保存在Entry内的Value，即<strong>实际与当前线程绑定的变量值</strong>。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> Entry <span class="token function">getEntry</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//取模试探性获取引用ThreadLocal的Entry的下标</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>table<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Entry e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> key<span class="token punctuation">)</span>        <span class="token keyword">return</span> e<span class="token punctuation">;</span>    <span class="token keyword">else</span>          <span class="token comment" spellcheck="true">//发生冲突，采用开放寻址法从Entry数组中找引用ThreadLocal的Entry</span>        <span class="token keyword">return</span> <span class="token function">getEntryAfterMiss</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> i<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//发生冲突，采用开放寻址法从Entry数组中找引用ThreadLocal的Entry</span><span class="token keyword">private</span> Entry <span class="token function">getEntryAfterMiss</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> Entry e<span class="token punctuation">)</span> <span class="token punctuation">{</span>   Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>   <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>   <span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>     ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 找到引用ThreadLocal的Entry返回</span>       <span class="token keyword">return</span> e<span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//找到之前引用ThreadLocal的Entry，但ThreadLocal的引用已被remove方法清理掉或被GC清理掉</span>       <span class="token comment" spellcheck="true">//通过重新哈希，清理已被remove或被GC回收的ThreadLocal上关联的value</span>       <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">else</span> <span class="token comment" spellcheck="true">// 继续向前寻找引用ThreadLocal的Entry</span>       i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>     e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> null<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//开放寻址，获取元素下标</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token operator">?</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ThreadLocalMap#set</strong>方法以<strong>ThreadLocal</strong>作为<strong>Key</strong>采用开放寻址法将value与其所属线程绑定。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> key<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//取模试探性获取引用ThreadLocal的Entry的下标</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//尝试用开放寻址的方法在Entry数组中找到之前引用ThreadLocal的Entry</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>         e <span class="token operator">!=</span> null<span class="token punctuation">;</span>         e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//找到之前引用ThreadLocal的Entry，重置value值并返回</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">//找到之前引用ThreadLocal的Entry，但ThreadLocal的引用已被remove方法清理掉或被GC清理掉</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//重新将引用ThreadLocal的Entry放入到Entry数组中并清理已被remove或被GC回收的ThreadLocal上关联的value</span>            <span class="token function">replaceStaleEntry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//未找到之前引用ThreadLocal的Entry，创建Entry并放入Entry数组</span>    tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token operator">++</span>size<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//清理槽位失败且Entry数组长度超过阈值，重新rehash对Entry数组扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">cleanSomeSlots</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> sz<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sz <span class="token operator">>=</span> threshold<span class="token punctuation">)</span>        <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ThreadLocalMap#remove</strong>方法以<strong>ThreadLocal</strong>作为<strong>Key</strong>采用开放寻址法将value与其所属线程绑定。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>  <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//取模试探性获取引用ThreadLocal的Entry的下标</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//用开放寻址法找到引用ThreadLocal的Entry，并将其清除</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//清除Entry上的弱引用ThreadLocal</span>      e<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//通过重新哈希，清理已被remove或被GC回收的ThreadLocal上关联的value</span>      <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ThreadLocalMap#getEntry、#set、#remove</strong>方法内部最终都会尝试调用<strong>expungeStaleEntry</strong>方法。</p><p><strong>expungeStaleEntry</strong>通过重新哈希，清理已被remove或被<strong>GC</strong>回收的<strong>ThreadLocal</strong>上关联的value， 该方法可以保证由于只与Entry存在弱引用关系的<strong>ThreadLocal</strong>被<strong>GC</strong>回收后，Entry上的Value（与<strong>ThreadLocal</strong>上关联的value）能被及时清理，而<strong>不会因为Entry上的Value一直存在强引用最终导致的内存泄漏</strong>。实际<strong>ThreadLocal#set、#get、#remove</strong>方法最终都会调用<strong>expungeStaleEntry</strong>方法。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 通过重新哈希，清理已被remove或被GC回收的ThreadLocal上关联的value</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> staleSlot<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>  <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 清理当前位置上已被remove或被GC回收的ThreadLocal上关联的value</span>  tab<span class="token punctuation">[</span>staleSlot<span class="token punctuation">]</span><span class="token punctuation">.</span>value <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 清理当前位置上的Entry</span>  tab<span class="token punctuation">[</span>staleSlot<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>  size<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 向后重新哈希，直到对应位置上没有Entry。</span>  Entry e<span class="token punctuation">;</span>  <span class="token keyword">int</span> i<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>staleSlot<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">;</span>i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//清理当前位置上已被remove或被GC回收的ThreadLocal上关联的value</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      e<span class="token punctuation">.</span>value <span class="token operator">=</span> null<span class="token punctuation">;</span>      tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>      size<span class="token operator">--</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//用开放寻址法，重新调整当前Entry在数组中的位置</span>      <span class="token keyword">int</span> h <span class="token operator">=</span> k<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//ThreadLocal初始位置h与i不一致，尝试将其放回始位置或开放寻址法后的位置</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>tab<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>                h <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        tab<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3 使用场景"></a>3 使用场景</h4><p>​        本文开篇已介绍过，<strong>ThreadLocal</strong>适用方法调用链上参数的透传，但要注意是同线程间，但不适合异步方法调用的场景。对于异步方法调用，想做参数的透传可以采用阿里开源的<strong>TransmittableThreadLocal</strong>。权限、日志、事务等框架都可以利用<strong>ThreadLocal</strong>透传重要参数。</p><p>​        在使用<strong>Spring Security</strong>时，当用户认证通过后，业务逻辑处理中经常会去获取用户认证时的用户信息，通过会将这个功能封装在工具类中，如下的<strong>SecurityUtils#getAuthUser</strong>方法用于获取用户的认证信息，如果用户认证过返回用户信息，否则返回null。业务逻辑中直接通过<strong>SecurityUtils#getAuthUser</strong>方法便能方便的获取用户的认证信息。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SecurityUtils</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> User <span class="token function">getAuthUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 通过Srping Security 上下文获取用户的认证信息</span>      Authentication auth <span class="token operator">=</span> SecurityContextHolder<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAuthentication</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span>  Objects<span class="token punctuation">.</span><span class="token function">nonNull</span><span class="token punctuation">(</span>auth<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>User<span class="token punctuation">)</span> auth<span class="token punctuation">.</span><span class="token function">getPrincipal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Get user auth info fail"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CustomException</span><span class="token punctuation">(</span><span class="token string">"获取用户信息异常"</span><span class="token punctuation">,</span> HttpStatus<span class="token punctuation">.</span>UNAUTHORIZED<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>SecurityContextHolder</strong>采用策略模式实现，实默认策略便是通过ThreadLocal存储Spring Security的上下文信息，这个上下文信息中包括认证信息。<strong>ThreadLocalSecurityContextHolderStrategy</strong>源码如下。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalSecurityContextHolderStrategy</span> <span class="token keyword">implements</span> <span class="token class-name">SecurityContextHolderStrategy</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//采用ThreadLocal存储线程上下文信息</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> ThreadLocal<span class="token operator">&lt;</span>SecurityContext<span class="token operator">></span> contextHolder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clearContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        contextHolder<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> SecurityContext <span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//从ThreadLocal获取线程上下文信息</span>        SecurityContext ctx <span class="token operator">=</span> contextHolder<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ctx <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ctx <span class="token operator">=</span> <span class="token function">createEmptyContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            contextHolder<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ctx<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setContext</span><span class="token punctuation">(</span>SecurityContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Assert<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token string">"Only non-null SecurityContext instances are permitted"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        contextHolder<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-内存泄漏问题分析"><a href="#4-内存泄漏问题分析" class="headerlink" title="4 内存泄漏问题分析"></a>4 内存泄漏问题分析</h4><h5 id="4-1-内存漏泄示例"><a href="#4-1-内存漏泄示例" class="headerlink" title="4.1 内存漏泄示例"></a>4.1 内存漏泄示例</h5><p>下面通过代码模拟ThreadLocal内存漏泄，注意运行指定的VM参数 -Xms大于50MB。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalOOM</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    ThreadLocal tl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CustomThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    tl<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Value50MB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//清理 CustomThreadLocal 对象的强引用</span>    tl <span class="token operator">=</span> null<span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Call System.gc method to trigger Full GC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//GC线程优先级较低，休眠3秒确保Full GC已完成</span>    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CustomThreadLocal</span> <span class="token keyword">extends</span> <span class="token class-name">ThreadLocal</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// Full GC 如果对象被回收，该方法会被调用</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"CustomThreadLocal 1 MB finalized."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Value50MB</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// Full GC 如果对象被回收，该方法会被调用</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Value50MB 50 MB finalized."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>控制台输出：</p><blockquote><p><strong>Call System.gc method to trigger Full GC</strong><br><strong>My threadLocal 1 MB finalized.</strong></p></blockquote><p>​        从上面的输出可以知道，发生<strong>Full GC</strong>后<strong>CustomThreadLocal</strong> 对象对应的<strong>1MB</strong>内存被回收，但其上面关联的值<strong>Value50MB</strong>对应的<strong>50MB</strong>内存并没有被<strong>GC</strong>回收，出现了<strong>内存漏泄</strong>。如果应用中存在大量的这类<strong>ThreadLocal</strong>关联的值没被<strong>GC</strong>回收到，内存不断漏泄，最终将导致应用程序整体<strong>OOM</strong>，程序崩溃。</p><p><strong>4.2 原因分析</strong></p><p>​        在第2节部分源码分析中，已知道实际<strong>ThreadLocal</strong>与其保存的值都是被放在<strong>ThreadLocalMap</strong>内部<strong>Entry</strong>对应的实例上。而<strong>Entry</strong>持有<strong>ThreadLocal</strong>的弱引用，当<strong>ThreadLocal</strong>只被<strong>Entry</strong>引用时，<strong>ThreadLocal</strong>对象将在<strong>GC</strong>时被无条件的回收掉。</p><p>​        上面<strong>ThreadLocal</strong>内存漏泄的示例中，强弱引用关系如下。</p><p><strong>强引用：</strong></p><ul><li>**ThreadLocalRef  =&gt;ThreadLocal **</li><li><strong>ThreadRef  =&gt; Thread  =&gt; ThreadLocalMap =&gt; Entry数组 =&gt; Entry =&gt; Value50MB</strong></li></ul><p><strong>弱引用：</strong></p><ul><li>**Entry =&gt; ThreadLocal **</li></ul><p><img src="https://gitee.com/0909/blog/raw/master/img/20211027153948.png"></p><pre><code> tl = null;</code></pre><p>执行 t1 = null后，强弱引用关系如下。</p><p><strong>强引用：</strong></p><ul><li><strong>ThreadRef  =&gt; Thread  =&gt; ThreadLocalMap =&gt; Entry数组 =&gt; Entry =&gt; Value50MB</strong></li></ul><p><strong>弱引用：</strong></p><ul><li>**Entry =&gt; ThreadLocal **</li></ul><p><img src="https://gitee.com/0909/blog/raw/master/img/20211027154315.png"></p><p><strong>GC</strong>时发现 <strong>TheadLocal</strong>上只存在 <strong>Entry</strong>对其的弱引用，于是无条件将<strong>ThreadLocal</strong>对应的内存回收，示例中是<strong>CustomThreadLocal</strong>对应的<strong>1M</strong>内存。</p><p><strong>4.3  如何避内存漏泄</strong></p><p>​        从第2节中的源码分析中已知道，<strong>ThreadLocal#remove</strong>方法实际会调用<strong>ThreadLocalMap#expungeStaleEntry <strong>方法，达到将已被</strong>GC</strong>回收的<strong>ThreadLocal</strong>上关联的Value的强引断开，避免内存泄漏。所以在每次使用完<strong>ThreadLocal</strong>后，只要调用其对应的<strong>remove</strong>方法，就可以避内存漏泄。</p><h5 id="4-4-为什么Entry不强引用ThreadLocal"><a href="#4-4-为什么Entry不强引用ThreadLocal" class="headerlink" title="4.4 为什么Entry不强引用ThreadLocal"></a>4.4 为什么Entry不强引用ThreadLocal</h5><p><strong>ThreadLocalMap</strong>源码上的注解</p><blockquote><p>To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys. However, since reference queues are not used, stale entries are guaranteed to be removed only when the table starts running out of space.</p></blockquote><p>可以看到主要是为了避免大的<strong>ThreadLocal</strong>与长时间存活的使用场景。如果不采用<strong>Entry</strong>弱引用<strong>ThreadLocal</strong>，<strong>ThreadLocal</strong>将一直与<strong>Thread</strong>共存，这更加容易引起内存漏泄。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​        本文首先对ThreadLocal做出了整体的概述，简要地说明其使用场景、不足、业界的改进方案。然后对<strong>ThreaLocal</strong>的源码进行了详细地分析，接着介绍了其具体的使用场景、日常使用中可能会遇到的问题与问题的解决方案。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://github.com/alibaba/transmittable-thread-local">TransimittableThreadLocal</a></p><p><a href="https://mp.weixin.qq.com/s/8f29ZfGvZVPe0bO-FahokQ">Java Reference核心原理分析</a></p><h4 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h4><p>​        原创不易，点赞、在看、转发是对我莫大的鼓励，关注公众号洞悉源码是对我最大的支持。同时相信我会分享更多干货，我同你一起成长，我同你一起进步。</p>]]></content>
      
      
      <categories>
          
          <category> JDK源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK源码 </tag>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Spring的事件机制</title>
      <link href="/2021/10/25/%E6%B5%85%E8%B0%88Spring%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2021/10/25/%E6%B5%85%E8%B0%88Spring%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="浅谈Spring的事件机制"><a href="#浅谈Spring的事件机制" class="headerlink" title="浅谈Spring的事件机制"></a>浅谈Spring的事件机制</h3><h4 id="1-java中的事件机制"><a href="#1-java中的事件机制" class="headerlink" title="1 java中的事件机制"></a>1 java中的事件机制</h4><p>​        java 在JDK中提供了定义事件机制的两个重要类，分别是EventObject与EventListener。事件机制与设计模型中的观察者模式类似。事件机制通常有三个参与者，分别是Event、EventPublisher、EventListener，EventPublisher负责发布Event，EventPublisher具体实现内部持有了多个EventListener，当Event发布后EventPublisher会通知所有的观察者。但察者模式通常只有观察者（Observer）与被观察者（Subject）两者参与，被观察者具体实现内部持有了多个观察者，同时被观察者提供注册观察者与取消观察者的入口，当被观察者状态发生改变时，其会通知所有的观察者。可以看到事件机制中的Event相当于观察者模式中Subject的状态，而EventPublisher相当于观察者（Subject），EventListener相当于观察者（Observer）。本质上事件机制与察者模式是一样的。</p><p>​        那事件机制有什么好处呢？来看一个简单的例子，以用户注册为例，当用户注册完后，会给用户发送对应的短信通知，同时也会发送邮件通知。后来产品说要搞积分体系，新注册的用户还得增加积分。那这个时候用户注册的那段代码，就得改一下加上给用户增加积分的逻辑，这样就违反了设计原则中的开闭原则（对扩展开放，对修改关闭）。有了事件机制后，我们可以怎么做呢？来看看下面的例子。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> org<span class="token punctuation">.</span>knight<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>EventObject<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用户注册Event</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RegisterEvent</span> <span class="token keyword">extends</span> <span class="token class-name">EventObject</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token function">RegisterEvent</span><span class="token punctuation">(</span>String payload<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//用户注册Event监听器</span><span class="token keyword">package</span> org<span class="token punctuation">.</span>knight<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>EventListener<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserRegisterListener</span> <span class="token keyword">extends</span> <span class="token class-name">EventListener</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//自定义监听事件的方法</span>  <span class="token keyword">void</span> <span class="token function">onRegisterEvent</span><span class="token punctuation">(</span>RegisterEvent event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//用户注册Event发布者</span><span class="token keyword">package</span> org<span class="token punctuation">.</span>knight<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashSet<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Set<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserRegisterPublisher</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//持有多个Event监听器</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> Set<span class="token operator">&lt;</span>UserRegisterListener<span class="token operator">></span> listeners <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//增加Event监听器</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addListener</span><span class="token punctuation">(</span>UserRegisterListener listener<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> listeners<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//删除Event监听器</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">removeListener</span><span class="token punctuation">(</span>UserRegisterListener listener<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> listeners<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//发布事件</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">publishEvent</span><span class="token punctuation">(</span>RegisterEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>UserRegisterListener listener <span class="token operator">:</span> listeners<span class="token punctuation">)</span> <span class="token punctuation">{</span>      listener<span class="token punctuation">.</span><span class="token function">onRegisterEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//发送短信</span><span class="token keyword">package</span> org<span class="token punctuation">.</span>knight<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ToSendMessageListener</span> <span class="token keyword">implements</span> <span class="token class-name">UserRegisterListener</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onRegisterEvent</span><span class="token punctuation">(</span>RegisterEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"User "</span> <span class="token operator">+</span> event<span class="token punctuation">.</span><span class="token function">getSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" register, send message!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//发送邮件</span><span class="token keyword">package</span> org<span class="token punctuation">.</span>knight<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ToSendMailListener</span> <span class="token keyword">implements</span> <span class="token class-name">UserRegisterListener</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onRegisterEvent</span><span class="token punctuation">(</span>RegisterEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"User "</span> <span class="token operator">+</span> event<span class="token punctuation">.</span><span class="token function">getSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" register, send email!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//用户注册服务</span><span class="token keyword">package</span> org<span class="token punctuation">.</span>knight<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserRegisterService</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">final</span> UserRegisterPublisher publisher <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserRegisterPublisher</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">userRegister</span><span class="token punctuation">(</span>String username<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"用户"</span><span class="token operator">+</span>username<span class="token operator">+</span><span class="token string">"注册成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    publisher<span class="token punctuation">.</span><span class="token function">publishEvent</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RegisterEvent</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//注册Event监听器</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">regiserListener</span><span class="token punctuation">(</span>UserRegisterListener listener<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> publisher<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//删除Event监听器</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">removeListener</span><span class="token punctuation">(</span>UserRegisterListener listener<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> publisher<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>listener<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//主函数</span><span class="token keyword">package</span> org<span class="token punctuation">.</span>knight<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainUserCenter</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    UserRegisterService registerService <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UserRegisterService</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//注册相应的listener</span>    registerService<span class="token punctuation">.</span><span class="token function">regiserListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ToSendMessageListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    registerService<span class="token punctuation">.</span><span class="token function">regiserListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ToSendMailListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    registerService<span class="token punctuation">.</span><span class="token function">userRegister</span><span class="token punctuation">(</span><span class="token string">"叶易"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面定义了用户注册事件RegisterEvent，RegisterEvent扩展了JDK中的Event类；UserRegisterListener负责监听RegisterEvent，其扩展了JDK中的EventListener接口，同时定义了听事件的onRegisterEvent方法，其有两个具体实现分别负责用户注册后发送信息与发送邮件，分别是ToSendMessageListener与ToSendMailListener；UserRegisterPublisher为事件发布类，内部持有多个UserRegisterListener，同时定了addListener与removeListener用以维护内部持有的UserRegisterListener，当然其还定义了事件发布方法publishEvent。上面代码的MainUserCenter#main执行后结果如下。</p><blockquote><p>用户叶易注册成功<br>User 叶易 register, send email!<br>User 叶易 register, send message!</p></blockquote><p>上面提到要新增增加用户积分的功能，有了事件监听机制后就可以实现对扩展开放对修改关闭。只要新增一个用户注册后增加积分的监听器，然后在MainUserCenter中将其注册一下便可以。当然用户注册这个场景，真实业务上不会不会这么做，而是通过MQ发送用户注册的消息，然后需要的业务服务再监听对应主题下的这个消息执行业务逻辑。</p><h4 id="2-Spring中的事件机制"><a href="#2-Spring中的事件机制" class="headerlink" title="2 Spring中的事件机制"></a>2 Spring中的事件机制</h4><h5 id="2-1-Spring中的事件机制使用"><a href="#2-1-Spring中的事件机制使用" class="headerlink" title="2.1 Spring中的事件机制使用"></a>2.1 Spring中的事件机制使用</h5><p>​    Spring定义了ApplicationEvent、ApplicationEventListener、ApplicationEventPublisher来支撑其内部的事件机制。同时还提供了EventListener注解，方便将方法对应类直接转换为监听器。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//事件定义，扩展了JDK中的EventObject，增加事件发生时间</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ApplicationEvent</span> <span class="token keyword">extends</span> <span class="token class-name">EventObject</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** System time when the event happened. */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">long</span> timestamp<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ApplicationEvent</span><span class="token punctuation">(</span>Object source<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>timestamp <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">long</span> <span class="token function">getTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>timestamp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//事件监听器定义，扩展了JDK中的EventListener，增加自定义的onApplicationEvent方法</span><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ApplicationListener</span><span class="token operator">&lt;</span>E <span class="token keyword">extends</span> <span class="token class-name">ApplicationEvent</span><span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">EventListener</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span>E event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//事件发布者定义，Spring中典型的事件发布者是ApplicationContext</span><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ApplicationEventPublisher</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//该方法会发布事件后会通知所有注册事件监听器</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">publishEvent</span><span class="token punctuation">(</span>ApplicationEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">publishEvent</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Object<span class="token punctuation">)</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//该方法会发布事件后会通知所有注册事件监听器，事件监听器内部具体执行时可是同步或是异步，原则上越快越好</span>    <span class="token keyword">void</span> <span class="token function">publishEvent</span><span class="token punctuation">(</span>Object event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Spring中和事件相关的另外一个重要的接口是ApplicationEventMulticaster，其内部持有多个ApplicationListener，并定义注册ApplicationListener与删除ApplicationListener的方法。Spring中的ApplicationEventPublisher发布事件将由其代理完成。来看一下将上面的介绍的用户注册的例子改为Spring中的事件后具体的代码。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> org<span class="token punctuation">.</span>knight<span class="token punctuation">.</span>spring<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ApplicationEvent<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//用户注册事件，扩展了Spring的ApplicationEvent</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RegisterEvent</span> <span class="token keyword">extends</span> <span class="token class-name">ApplicationEvent</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token function">RegisterEvent</span><span class="token punctuation">(</span>String payload<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//发送短信</span><span class="token keyword">package</span> org<span class="token punctuation">.</span>knight<span class="token punctuation">.</span>spring<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ApplicationListener<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Component<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//加上Component注解，让Spring能将该ApplicationListener注册</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ToSendMessageListener</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationListener</span><span class="token operator">&lt;</span>RegisterEvent<span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span>RegisterEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"User "</span> <span class="token operator">+</span> event<span class="token punctuation">.</span><span class="token function">getSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" register, send message!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//发送邮件</span><span class="token keyword">package</span> org<span class="token punctuation">.</span>knight<span class="token punctuation">.</span>spring<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ApplicationListener<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Component<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//加上Component注解，让Spring能将该ApplicationListener注册</span><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ToSendMailListener</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationListener</span><span class="token operator">&lt;</span>RegisterEvent<span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onApplicationEvent</span><span class="token punctuation">(</span>RegisterEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"User "</span> <span class="token operator">+</span> event<span class="token punctuation">.</span><span class="token function">getSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" register, send email!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//用度注册服务</span><span class="token keyword">package</span> org<span class="token punctuation">.</span>knight<span class="token punctuation">.</span>spring<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ApplicationContext<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ApplicationContextAware<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ApplicationEventPublisher<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>ApplicationEventPublisherAware<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>stereotype<span class="token punctuation">.</span>Service<span class="token punctuation">;</span><span class="token annotation punctuation">@Service</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserRegisterService</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationContextAware</span><span class="token punctuation">,</span> ApplicationEventPublisherAware <span class="token punctuation">{</span>  <span class="token keyword">private</span> ApplicationContext applicationContext<span class="token punctuation">;</span>  <span class="token keyword">private</span> ApplicationEventPublisher applicationEventPublisher<span class="token punctuation">;</span>  <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">userRegister</span><span class="token punctuation">(</span>String username<span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"用户"</span><span class="token operator">+</span>username<span class="token operator">+</span><span class="token string">"注册成功"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    applicationEventPublisher<span class="token punctuation">.</span><span class="token function">publishEvent</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">RegisterEvent</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//也可以用applicationContext发送事件</span>    <span class="token comment" spellcheck="true">//applicationContext.publishEvent(new RegisterEvent(username));</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setApplicationContext</span><span class="token punctuation">(</span>ApplicationContext applicationContext<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext <span class="token operator">=</span> applicationContext<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setApplicationEventPublisher</span><span class="token punctuation">(</span>ApplicationEventPublisher applicationEventPublisher<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>applicationEventPublisher <span class="token operator">=</span> applicationEventPublisher<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//主函数</span><span class="token keyword">package</span> org<span class="token punctuation">.</span>knight<span class="token punctuation">.</span>spring<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>context<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>AnnotationConfigApplicationContext<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainUserCenter</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    AnnotationConfigApplicationContext context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AnnotationConfigApplicationContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//扫描对应包</span>    context<span class="token punctuation">.</span><span class="token function">scan</span><span class="token punctuation">(</span><span class="token string">"org.knight.spring"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    context<span class="token punctuation">.</span><span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获取用户注册服务</span>    UserRegisterService userRegisterService <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>UserRegisterService<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    userRegisterService<span class="token punctuation">.</span><span class="token function">userRegister</span><span class="token punctuation">(</span><span class="token string">"叶易"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到能很方便地利用Spring的事件扩展机制，只要定义对应事件RegisterEvent扩展ApplicationEvent，然后再定义对应的ApplicationListener就行，自定义的ApplicationListener一定要加上@Component、@Service之类的注解以便Spring能将ApplicationListener注册。上面的UserRegisterService实现了ApplicationContextAware与ApplicationEventPublisherAware，以便Spring分别能将ApplicationContext与ApplicationEventPublisher注入到UserRegisterService中，在发布事件时可以采用ApplicationContext或ApplicationEventPublisher。ApplicationContext接口扩展了ApplicationEventPublisher接口，同样具体事件发布的能力，这主要是为支撑容器启动、容器刷新、容器暂停时发布对应的事件。提前提到过可以通过EventListener注解，定义监听器类，同时通知监听器去执行具体的业务逻辑时可以采用同步或异步的方式。</p><h5 id="2-2-ApplicationContext如何异步执行事件"><a href="#2-2-ApplicationContext如何异步执行事件" class="headerlink" title="2.2 ApplicationContext如何异步执行事件"></a>2.2 ApplicationContext如何异步执行事件</h5><p>​        来简要地看一下Srping事件机制中重要的实现ApplicationContext。Spring源码中ApplicationContext扩展了ApplicationEventPublisher接口，Spring给ApplicationContext定义其必须具备事件发布的能力。</p><blockquote><p>The ability to publish events to registered listeners. Inherited from the ApplicationEventPublisher interface.</p></blockquote><p>在ApplicationContext的子类AbstractApplicationContext中可以看到具体事件发布能力实现的代码。其中的成员变量 applicationEventMulticaster，代理了ApplicationEventPublisher 完成了事件发布。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Helper class used in event publishing</span>ApplicationEventMulticaster applicationEventMulticaster<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>AbstractApplicationContext中发布事件的方法最终调用如下方法。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">publishEvent</span><span class="token punctuation">(</span>Object event<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> ResolvableType eventType<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 省略部分代码</span>        ApplicationEvent applicationEvent<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>event <span class="token keyword">instanceof</span> <span class="token class-name">ApplicationEvent</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            applicationEvent <span class="token operator">=</span> <span class="token punctuation">(</span>ApplicationEvent<span class="token punctuation">)</span> event<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            applicationEvent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PayloadApplicationEvent</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>eventType <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                eventType <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>PayloadApplicationEvent<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span> applicationEvent<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getResolvableType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// Multicast right now if possible - or lazily once the multicaster is initialized</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>earlyApplicationEvents <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>earlyApplicationEvents<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>applicationEvent<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//applicationEventMulticaster代理完成事件发布</span>            <span class="token function">getApplicationEventMulticaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">multicastEvent</span><span class="token punctuation">(</span>applicationEvent<span class="token punctuation">,</span> eventType<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// Publish event via parent context as well...</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token keyword">instanceof</span> <span class="token class-name">AbstractApplicationContext</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>AbstractApplicationContext<span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span>parent<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">publishEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span> eventType<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">this</span><span class="token punctuation">.</span>parent<span class="token punctuation">.</span><span class="token function">publishEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    ApplicationEventMulticaster <span class="token function">getApplicationEventMulticaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalStateException <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>applicationEventMulticaster <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"ApplicationEventMulticaster not initialized - "</span> <span class="token operator">+</span>                    <span class="token string">"call 'refresh' before multicasting events via the context: "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>applicationEventMulticaster<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从上面源可以看到ApplicationEventMulticaster#multicastEvent方法代理了ApplicationEventPublisher 完成了事件发布。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ApplicationEventMulticaster</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">addApplicationListener</span><span class="token punctuation">(</span>ApplicationListener<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">addApplicationListenerBean</span><span class="token punctuation">(</span>String listenerBeanName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">removeApplicationListener</span><span class="token punctuation">(</span>ApplicationListener<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> listener<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">removeApplicationListenerBean</span><span class="token punctuation">(</span>String listenerBeanName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">removeAllListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">multicastEvent</span><span class="token punctuation">(</span>ApplicationEvent event<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">void</span> <span class="token function">multicastEvent</span><span class="token punctuation">(</span>ApplicationEvent event<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> ResolvableType eventType<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>ApplicationEventMulticaster接口定义增加与删除ApplicationListener的相关方法，同时提供了事件发布的multicastEvent方法。其有抽象类AbstractApplicationEventMulticaster与具体实现SimpleApplicationEventMulticaster。AbstractApplicationEventMulticaster只提供了维护与检索ApplicationListener的相关方法，而发布事件的multicastEvent方法的具体实现则在具体实现类SimpleApplicationEventMulticaster上完成，该类实现代码也相对简明。</p><pre><code>public class SimpleApplicationEventMulticaster extends AbstractApplicationEventMulticaster &#123;    //真正执行listener中任务的Executor，实现异步通知listener处理的关键    private Executor taskExecutor;    public void setTaskExecutor(@Nullable Executor taskExecutor) &#123;        this.taskExecutor = taskExecutor;    &#125;    protected Executor getTaskExecutor() &#123;        return this.taskExecutor;    &#125;    //省略部分源码...&#125;</code></pre><p>SimpleApplicationEventMulticaster中的Executor是实现异步通知listener处理的关键。当taskExecutor不为空时，会采用Executor对应的线程池异步通知listener执行任务，否则同步遍历所有listener并通知listener执行任务。</p><pre><code>public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) &#123;  ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event));  //获取具体的执行者  Executor executor = getTaskExecutor();  for (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;  if (executor != null) &#123;      executor.execute(() -&gt; invokeListener(listener, event));  &#125; else &#123;      invokeListener(listener, event);  &#125; &#125;&#125;</code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​        本文从结合具体例子与代码从JDK中的事件机制谈起，逐步介绍了如何使用Spring中的事件机制，同时简要地分析了ApplicationContext中事件异步执行的相关源码。本文源码分析并不深入，感兴趣的读者可以结合上面的介绍深入分析Spring中的事件机制。</p><h4 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h4><p>​        原创不易，点赞、在看、转发是对我莫大的鼓励，关注公众号洞悉源码是对我最大的支持。同时相信我会分享更多干货，我同你一起成长，我同你一起进步。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> ApplicationContext </tag>
            
            <tag> 观察者模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解分布式事务之可靠消息最终一致性</title>
      <link href="/2021/10/19/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8B%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/"/>
      <url>/2021/10/19/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8B%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="一文详解分布式事务之基于消息投递与消费的最终一致性"><a href="#一文详解分布式事务之基于消息投递与消费的最终一致性" class="headerlink" title="一文详解分布式事务之基于消息投递与消费的最终一致性"></a>一文详解分布式事务之基于消息投递与消费的最终一致性</h3><h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h4><p>​        微服务架构中，服务的细分，导致原来在单一服务中的模块拆分为多个服务，同时数据存储也从单一的数据源，变为按服务划分的多数据源。单一服务单数据源时，可以通过数据库本身的<strong>ACID机制</strong>（<strong>Atomicity 原子性</strong>、<strong>Consistency 一致性</strong>、<strong>Isolation 隔离性</strong>、<strong>Durability 持久性</strong>）保证业务数据的一致性（通常称作<strong>本地事务</strong>），微服务架构下通常采用<strong>BASE机制</strong>（<strong>Basically Available 基本可用</strong>、**Soft State 软状态 <strong>、</strong>Eventual Consistency 最终一致性 **）来保证系统间数据的最终一致性。</p><p>​        分布式事务通常可采用<strong>2PC</strong>、<strong>3PC</strong>、<strong>TCC</strong>、<strong>SAGA</strong>、<strong>最大努力通知</strong>与本文将要介绍的<strong>基于消息投递与消费的最终一致性</strong>实现。2PC 与 3PC 依赖于数据库的事务能力，在一阶段开始事务后不进提交会严重影响应用程序的并发性能 ，实际业务中基本不会采用。TCC 相于2PC与3PC而言并发性能更高，是一种柔性事务，但要求业务侵入性较大且实现复杂，要求业务侧实现<strong>Try、Cancel、Confirm</strong>方法，同时为了解决网络通信失败或超时带来的异常情况，要求业务方在设计实现要<strong>允许空回滚、操作幂等性、防止资源悬挂</strong>，其比较适合数据一致性要求较高的业务场景，如组合支付，订单减库存。SAGA 其支持的并发性相对TCC而言更高，业务侵入性较低，适合长事务的业务场景。</p><h4 id="2-基于消息投递与消费的最终一致性"><a href="#2-基于消息投递与消费的最终一致性" class="headerlink" title="2  基于消息投递与消费的最终一致性"></a>2  基于消息投递与消费的最终一致性</h4><p>​            <strong>基于消息投递与消费的最终一致性</strong>  这类实现方案可以细分为<strong>本地消息表、可靠消息服务、事务消息（可靠消息服务的特例）</strong>，由于这些方案本质上都是<strong>将跨系统的业务操作变成可靠的消息投递与消费，达到将分布式事务拆分为多个本地事务的目地，实现系统间数据的最终一致性</strong>，就将这类方案统称为<strong>基于消息投递与消费的最终一致性</strong>。</p><h5 id="2-1-本地消息表"><a href="#2-1-本地消息表" class="headerlink" title="2.1 本地消息表"></a>2.1 本地消息表</h5><p>​        本地消息表该方案，由 eBay 的系统架构师 Dan Pritchett 在 2008 年在 ACM 发表的论文《<a href="https://queue.acm.org/detail.cfm?id=1394128">Base: An Acid Alternative</a>》中提出的，BASE机制也是他在该论文中提出的。先看一下直接用本地事务能否保证系统间数据的最终一致性。</p><p>​        以常见的电商平台，用户购买商品创建订单为例，订单系统在创建订单时，通常会采用预扣减库存的方式来避免超售，用户支付成功后再真正扣减库存，对于配置时间内超时未支付的订单，会将预扣减的库存归还。为了提高订单创建的效率，将订单系统中订单生成与预扣减库存二者异步解耦，即订单系统内生成订单再向MQ投递预扣减库存的消息。</p><img src="https://gitee.com/0909/blog/raw/master/img/20211021171244.png" style="zoom:80%;" /><p>订单系统内部分为4步，分别是</p><ul><li><p><strong>用户ID加锁防止用户重复下单</strong></p><p>通常会指定锁的自动释放时间，如1秒正常情况用户1秒内不可能真正下多单，这种情况更多是由于重复下单导致的，出现这种情况直接返回请误重复下单。</p></li><li><p><strong>Lua脚本校验库存预扣库存</strong></p><p>这一步主要是在缓存中校验与预扣库存</p></li><li><p><strong>创建订单</strong></p><p>真正创建业务订单</p></li><li><p><strong>投递订单创建消息</strong></p><p>订单系统向MQ投递订单创建消息</p></li></ul><p>​       讨论分布式事务时，我们将<strong>用户ID加锁防止用户重复下单</strong> 与 <strong>Lua脚本校验库存预扣库存</strong>这两步直接跳过，只关心与事务相关的 <strong>创建订单</strong> 与 <strong>投递订单创建消息</strong> 。</p><p>​        <font color ='red'> <strong>常见的错误作法有下面两种:</strong> </font></p><ul><li><font color = 'red'><strong>在本地事务中先创建订单，后投递订单创建消息</strong> </font></li></ul><pre class="line-numbers language-java"><code class="language-java">本地事务开始<span class="token number">1</span><span class="token punctuation">.</span> 创建订单<span class="token number">2</span><span class="token punctuation">.</span> 投递订单创建消息本地事务结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这种作法存在的问题如下，第二步<strong>投递订单创建消息</strong>由于网络抖动出现超时，整个本地事务回滚，此时业务订单创建回滚，但订单创建的消息可能已投递到MQ中，最终导致商品库存被错误的预扣。</p><ul><li><font color = 'red'><strong>在本地事务中先投递订单创建消息，后创建订单</strong> </font></li></ul><pre class="line-numbers language-java"><code class="language-java">本地事务开始<span class="token number">1</span><span class="token punctuation">.</span> 投递订单创建消息<span class="token number">2</span><span class="token punctuation">.</span> 创建订单本地事务结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这种作法同样存在，<strong>投递订单创建消息</strong>由于网络抖动出现超时，整个本地事务回滚，此时业务订单未创建，但订单创建的消息可能已投递到MQ中，最终导致商品库存被错误的预扣。</p><p>​        <strong>那如何保证创建订单与投递订单创建消息要么一起成功，要么一起失败？</strong> 本地消息就是解决该问题，其做法如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token number">1</span>、上游系统在本地事务中新增或更新业务记录，同时新增本地消息记录，消息状态为待发送<span class="token number">2</span>、上游系统中定时任务扫描本地消息表中状态为待发送的记录，将该记录投递到MQ中，MQ返回成功再更新本地消息表的状态为已发送<span class="token number">3</span>、MQ推送消息供下游系统消费<span class="token number">4</span>、下游系统消费MQ推着的消息，执行业务逻辑，返回ACK给MQ<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><img src="https://gitee.com/0909/blog/raw/master/img/20211022113826.png" style="zoom:80%;" /><p>​    <strong>注意：第2步可能出现定时任务向MQ投递重复消息的情况，第3步可能出现MQ重复推送消息的情况，所以下游在做业务处理时一定要通过一定机制保证操作的幂等性，像上面的例子不能出现重复消费创建订单消息而导致多次预扣减库存的情况，业务操作的幂等性可以参考之前的文章 <a href="https://mp.weixin.qq.com/s/3A0hFpfxPinIq2trvCkvOw">分布式系统下面业务操作幂等的必要性</a>。</strong></p><img src="https://gitee.com/0909/blog/raw/master/img/20211022124420.png" style="zoom:80%;" /><p>​    本地消息表方案增加了业务系统维护消息表的成本使得事务处理部分与业务系统耦合，不能成为通用的解决方案，高并发时本地消息表的读写操作会成为系统的瓶颈，同时定时任务扫描本地消息表会增加系统之间的延时。</p><h5 id="2-2-可靠消息最终一致性"><a href="#2-2-可靠消息最终一致性" class="headerlink" title="2.2 可靠消息最终一致性"></a>2.2 可靠消息最终一致性</h5><p>​        本地消息表方案对业务的侵入性很大，不合适作为通用的解决方案。通过将本地消息的处理，转由单独的服务去完成，可以得到通用的<strong>可靠消息最终一致性</strong>解决方案。</p><p>​        <strong>可靠消息最终一致性</strong>方案由<strong>上游服务、可靠消息服务、下游服务</strong>组成。</p><p><strong>可靠消息服务</strong></p><p>​        可靠消息服务专门负责存储消息、投递消息、更新消息状态的独立服务。消息一般由<strong>待确认、已发送、已取消、已完成</strong>组成。</p><ul><li><p><strong>待确认</strong></p><p>上游服务发送给可靠消息服务的待确认消息，上游服务在执行完本地事务的业务逻辑，后会对该消息进行确认或取消</p></li><li><p><strong>已发送</strong></p><p>上游服务本地事务执行成功，后会向可靠消息服务发送确认消息，可靠消息服务收到消息后，将消息状态由待确认更新为已发送</p></li><li><p><strong>已取消</strong> </p><p>上游服务本地事务执行失败，后会向可靠消息服务发送取消消息，可靠消息服务收到消息后，将消息状态由待确认更新为已取消</p></li><li><p><strong>已完成</strong></p><p>下游服务消费完MQ中的消息完后，会向MQ投递已完成消费消息，可靠消息服务消费该消息，将消息状态由已发送更新为已完成</p></li></ul><p><strong>上游服务</strong></p><p>上游服务，主动发起事务的一方，一般是指分布式事务中最先开始执行的那个服务。其在需要调用下游服务时，不直接通过RPC之类的方式调用，而是先生成一条消息，具体步骤如下：</p><ul><li>上游服务执行业务逻辑前，先发送一条待确认消息（一般称为half-msg，包含接口调用信息）给可靠消息服务，可靠消息服务会将这条记录存储到自己的数据库（或本地磁盘）状态为【<strong>待确认</strong>】（<strong>下图中第1步与第2步</strong>）。</li><li>上游服务在本地事务中执行业务逻辑，如果本地事务执行成功，侧可靠消息服务发送一条确认消息；如果本地执行失败，则向消息服务发送一条取消消息 （<strong>下图中第3步与第4步</strong>）。</li><li>可靠消息服务，根据收到消息为确认消息或取消消息，修改本地数据库对应消息记录的状态为【<strong>已发送</strong>】或【<strong>已取消</strong>】。如果是确认消息，同时还要将消息投递到MQ消息队列中，<strong>修改消息状态和投递MQ必须在一个事务里，保证要么都成功要么都失败</strong>（<strong>下图中第 5.1 步与第5.2步</strong>）。</li></ul><p><img src="https://gitee.com/0909/blog/raw/master/img/20211022165646.png"></p><p><strong>注意：</strong>为了防止出现生产者的本地事务执行成功，但是发送<strong>确认/取消</strong>消息超时的情况。可靠消息服务，内部一般会提供一个后台定时任务，不停的扫描消息表中消息状态为【<strong>待确认</strong>】的消息，然后回调上游服务的一个接口，由上游服务决定该消息应该确认还是取消，并发送对应消息。</p><p><strong>下游服务</strong></p><p>下游服务，订阅MQ消息，收到MQ的消息后执行本地事务。执行成功后会对消息进行ACK确认，同时会向MQ投递已完成消费的消息，可靠消息服务收到该消息后会更新消息表中的消息状态为【<strong>已完成</strong>】，然后再对消息进行ACK确认。</p><p>下游服务，订阅MQ消息，收到MQ的消息后执行对应的业务逻辑。 </p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211022165518.png"></p><p><strong>注意：</strong> 为了防止重复消息消费，下游服务业务逻辑处理要保证幂等。同时第8、第9步、每10步都可能由于系统或网络原因出现异常。第8失败，消息会再次推送（主流的MQ都会保障消息至少投递一次），下游服务业务逻辑处理要保证幂等。第9步失败，则要通过可靠消息服务中的定时任务对扫描已超时的【<strong>已发送</strong>】消息，并重新向MQ投递消息。第10步失败，同样消息会再次推送，若消息表中消息状态为【<strong>已完成</strong>】则直接再次ACK消息就好。<strong>业务操作的幂等性可以参考之前的文章 <a href="https://mp.weixin.qq.com/s/3A0hFpfxPinIq2trvCkvOw">分布式系统下面业务操作幂等的必要性</a>。</strong></p><h5 id="2-3-事务消息"><a href="#2-3-事务消息" class="headerlink" title="2.3 事务消息"></a>2.3 事务消息</h5><p>​        事务消息，该方案也叫可靠消息最终一致性，很多开源的消息中间件都支持分布式事务，比如RocketMQ、Kafka。其核心其思想和本地消息表、可靠消息服务是一样的，只不过是将可靠消息服务和MQ功能封装在一起，屏蔽了底层细节，从而更方便用户的使用。</p><p>​        RocketMQ在4.3.0已经支持分布式事务消息，这里RocketMQ采用了2PC的思想来实现了提交事务消息，同时增加一个补偿逻辑来处理二阶段超时或者失败的消息，如下图所示。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211022224637.png"></p><p>上图说明了事务消息的大致方案，其中分为两个流程：<strong>正常事务消息的发送及提交</strong>、<strong>事务消息的补偿流程</strong>。</p><ul><li><strong>事务消息发送及提交</strong></li></ul><p>(1) 上游服务向MQ Server 发送half消息。</p><p>(2) MQ Server 服务端响应消息写入结果 (此时half消息对下游消息订阅者不可见)。</p><p>(3) 上游服务根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。</p><p>(4) 上游服务根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）</p><ul><li><strong>补偿流程</strong></li></ul><p>(5) 对没有Commit/Rollback的事务消息（pending状态的消息），MQ Server向上游服务发起一次“回查”</p><p>(6) 上游服务收到回查消息，检查回查消息对应的本地事务的状态</p><p>(7) 上游服务根据本地事务状态，重新Commit或者Rollback</p><p>其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​        本文总结了基于消息投递与消费的最终一致性实现分布式事务的主要方案本地消息表、可靠消息服务、事务消息，这些方案本质上都是<strong>将跨系统的业务操作变成可靠的消息投递与消费，达到将分布式事务拆分为多个本地事务的目地，实现系统间数据的最终一致性</strong>。</p><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://mp.weixin.qq.com/s/s20KWuG88LGgWTShcUKJgg">分布式理论之分布式事务：可靠消息最终一致性方案</a></p><p><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/design.md#5-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF">RocketMQ 事务消息设计</a></p><h4 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h4><p>​        原创不易，点赞、在看、转发是对我莫大的鼓励，关注公众号洞悉源码是对我最大支持。同时相信我会分享更多干货，我同你一起成长，我同你一起进步。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> BASE </tag>
            
            <tag> CAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解mysql InnoDB存储引擎中的锁</title>
      <link href="/2021/10/13/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3mysql%20InnoDB%20%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E9%94%81/"/>
      <url>/2021/10/13/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3mysql%20InnoDB%20%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h3 id="一文详解mysql-InnoDB存储引擎中的锁"><a href="#一文详解mysql-InnoDB存储引擎中的锁" class="headerlink" title="一文详解mysql InnoDB存储引擎中的锁"></a>一文详解mysql InnoDB存储引擎中的锁</h3><h4 id="1-InnoDB-存储引擎锁分类"><a href="#1-InnoDB-存储引擎锁分类" class="headerlink" title="1 InnoDB 存储引擎锁分类"></a>1 InnoDB 存储引擎锁分类</h4><p>​        mysql官网上介绍了InnoDB中7种所 **<code>Shared and Exclusive Locks</code><strong>（共享与排他锁）、</strong><code>Intention Locks</code><strong>（意向锁）、</strong><code>Record Locks</code><strong>（记录锁）、</strong><code>Gap Locks</code><strong>（间隙锁）、</strong><code>Next-Key Locks</code><strong>（临键锁） 、</strong><code>Insert Intention Locks</code><strong>（插入意向锁）、</strong><code>AUTO-INC Locks</code> **（自增锁），这7种配合MVCC机制，使得mysql在高并发的读写业务场景上有较好的表现。</p><p>​        mysql InnoDB 支持不同粒度的锁，如表锁与行锁，同时支持表锁与行锁的共存。为更高效地支持不同粒度的锁，而引入<strong>Intention Locks</strong>（意向锁）。<strong>Shared and Exclusive Locks</strong>（共享与排他锁）主要是为了提高加行锁时读写的并发性。<strong>Record Locks</strong>（记录锁）用于控制带索引记录的操作性能。<strong>Gap Locks</strong>（间隙锁）+ <strong>Next-Key Locks</strong>（临键锁）避免<strong>Repeatable Read</strong>级别下面出现幻读。<strong>Intention Locks</strong>（插入意向锁）保证多个事务，在同一个索引，同一个范围区间插入记录时，如果插入的位置不冲突，不会阻塞彼此。<strong>AUTO-INC Locks</strong> （自增锁）保证同一事务中利用数据库自增ID插入数据时ID的连续性。</p><h4 id="2-Shared-and-Exclusive-Locks（共享与排他锁）"><a href="#2-Shared-and-Exclusive-Locks（共享与排他锁）" class="headerlink" title="2 Shared and Exclusive Locks（共享与排他锁）"></a>2 Shared and Exclusive Locks（共享与排他锁）</h4><p>​        InnoDB内实现了标准的行锁，其中包括两类锁<strong>Shared Locks (共享锁 S)</strong> 与 <strong>Exclusive Locks （排他锁 X）</strong>。</p><ul><li><strong>Shared Locks (共享锁 S) 允许获取锁的事务读取数据。</strong></li><li><strong>Exclusive Locks （排他锁 X）允许获取锁的事务修改、删除数据。</strong></li></ul><h5 id="2-1-共享锁-S-与-排他锁-X兼容互斥性"><a href="#2-1-共享锁-S-与-排他锁-X兼容互斥性" class="headerlink" title="2.1 共享锁 S 与 排他锁 X兼容互斥性"></a>2.1 共享锁 S 与 排他锁 X兼容互斥性</h5><pre><code>     如果事务A获取数据行Data上的共享锁 S，其他事务也可以获取数据行Data上的共享锁 S。如果事务A获取数据行Data上的排他锁 X，则其他事务不能获取数据行Data上的排他锁 X，同样也不能获取数据行Data上的共享锁 S，必须待到事务A**释放**数据行Data上的排他锁 X。共享锁 S与排他锁 X之间的兼容互斥性如下图。</code></pre><img src="https://gitee.com/0909/blog/raw/master/img/SX锁兼容性.png" style="zoom:80%;" /><h5 id="2-2-共享锁-S-与-排他锁-X兼容互斥性示例"><a href="#2-2-共享锁-S-与-排他锁-X兼容互斥性示例" class="headerlink" title="2.2 共享锁 S 与 排他锁 X兼容互斥性示例"></a>2.2 共享锁 S 与 排他锁 X兼容互斥性示例</h5><p>​        下面看一下在user表上，共享锁 S 与 排他锁 X兼容互斥性示例。user表中user_id 为<strong>primary key</strong>。</p><p><strong>一、Session1加共享锁S</strong></p><p>​        在Session1中 执行 select * from user where user_id = 1 lock in share mode 语句，此时user_id = 1 的行上加了<strong>共享锁 S</strong>。由于user_id的行上没有其他锁，查询结果如下。</p><img src="https://gitee.com/0909/blog/raw/master/img/20211014100110.png" style="zoom:80%;" /><p><strong>二、Session2再加共享锁s（可再次读取数据）</strong></p><p>​        在Session2中 执行 select * from user where user_id = 1 lock in share mode 语句，此时上面的Session1已加共享锁，由于<strong>共享锁S之间兼容</strong>可再次在user_id = 1 的行上加<strong>共享锁 S</strong>。Session2查询结果如下。</p><img src="https://gitee.com/0909/blog/raw/master/img/20211014100017.png" style="zoom:80%;" /><p><strong>三、Session3再加排他锁X（出现锁等待超时）</strong></p><p>​        在Session3中 执行 select * from user where user_id = 1 for upate 语句，此时user_id = 1 的行已被上次两个Session加<strong>共享锁 S</strong>。由于<strong>共享锁S与之排他锁X之间互斥</strong>，Session3要等待user_id = 1 的行上<strong>共享锁 S</strong>  释放才能获取结果，否则出现<strong>锁等待超时</strong>，查询结果如下。</p><img src="https://gitee.com/0909/blog/raw/master/img/20211014100211.png" style="zoom:80%;" /><p>​        共享锁 S 与 排他锁 X兼容互斥性其他情况不一一分析了。</p><h4 id="3-Intention-Locks（意向锁）"><a href="#3-Intention-Locks（意向锁）" class="headerlink" title="3 Intention Locks（意向锁）"></a>3 Intention Locks（意向锁）</h4><p>​        意向锁，表示未来的某个时刻，事务可能要加共享/排它锁了，先提前声明一个意向。InnoDB 支持**<code>多粒度锁（multiple granularity locking）</code><strong>，他允许</strong><code>行级锁</code><strong>与</strong><code>表级锁</code><strong>共存，为更高效地支持不同粒度的锁，而引入</strong>Intention Locks（意向锁）<strong>，而实际是一种</strong><code>表锁</code><strong>。Intention Locks（意向锁）分为</strong>意向共享锁（intention shared lock, IS）** 与<strong>意向排他锁（intention exclusive lock, IX）</strong>两种。</p><ul><li><p><strong>意向共享锁</strong>（intention shared lock, IS）：事务有意向对表中的某些行加<strong>共享锁</strong>（S锁）</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。</span><span class="token keyword">SELECT</span> <span class="token keyword">column</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">LOCK</span> <span class="token operator">IN</span> <span class="token keyword">SHARE MODE</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>意向排他锁</strong>（intention exclusive lock, IX）：事务有意向对表中的某些行加<strong>排他锁</strong>（X锁）</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span><span class="token keyword">SELECT</span> <span class="token keyword">column</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>意向锁是一种比较弱的锁，他们之间相互兼容</p><img src="https://gitee.com/0909/blog/raw/master/img/IS与IX兼容性.png" style="zoom:80%;" /><p><strong>注意：</strong> 意向锁是一种与<em>行锁不冲突</em> 的表锁，意向锁是用来提高表级加锁判断效率的，看完下面<strong>意向锁解决的问题</strong>便会明白。重要的事重复三遍</p><p><strong>意向锁不会与行级的共享 / 排他锁互斥</strong></p><p><strong>意向锁不会与行级的共享 / 排他锁互斥</strong></p><p><strong>意向锁不会与行级的共享 / 排他锁互斥</strong></p><h5 id="3-1-意向锁解决的问题"><a href="#3-1-意向锁解决的问题" class="headerlink" title="3.1 意向锁解决的问题"></a>3.1 意向锁解决的问题</h5><p>​        来看看如果没有意向锁时，一个事务想向表加表锁的整体处理流程。假设事务想向表加共享锁比如执行如下操作，</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">LOCK</span> <span class="token keyword">TABLES</span> <span class="token keyword">user</span> <span class="token keyword">READ</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于共享锁S与排他锁X互斥，所以当前事务试图为表加共享锁时，必须保证：</p><ul><li>当前没有其他事务持有user表的排他锁。</li><li>当前没有其他事务持有user表中任意一行的排他锁。</li></ul><p>所以当前事务在试图对表加共享锁前，会去检测上面的两个条件是否满足，即要检测user表每一行是否加了排他锁，没有意向锁时只能一行一行的检测，这种作法必然效率低下。<strong>意向锁是如何解决这种检测效率低下的问题的呢？</strong></p><p>​        上面已说到过事务要获取某些行的 S 锁，必须先获得表的 IS 锁，事务要获取某些行的 X 锁，必须先获得表的 IX 锁。同样事务想对表加共享锁，必须先获得表的 IS 锁，事务想对表加排他锁，必须先获得表的 IX 锁。这样事务试图对表加共享锁时，只要检测表上有没有已加 IX 锁就行，而不用一行行去检测表中所有记录存没存在加行排他锁（只要表中某一行要加行排他锁，必然要先加IX 锁），如果表上已加IX锁，事务试图对表加共享锁的事务将被阻塞。</p><h5 id="3-2-S锁-X锁-IS锁-IX锁之间的兼容互斥性"><a href="#3-2-S锁-X锁-IS锁-IX锁之间的兼容互斥性" class="headerlink" title="3.2 S锁 X锁 IS锁 IX锁之间的兼容互斥性"></a>3.2 S锁 X锁 IS锁 IX锁之间的兼容互斥性</h5><p>​        前面已了解S锁与X锁，IS锁与 IX锁之间的兼容互斥性，现在看一下S锁 X锁 IS锁 IX锁之间的兼容互斥性。意向锁之间互相兼容。</p><img src="https://gitee.com/0909/blog/raw/master/img/锁兼容性.png" style="zoom:80%;" /><p>注意：上面所说的S锁与X锁是针对于表锁，而不是行锁，意向锁只针对表，不针对行进行锁定，意向锁是用来提高表级加锁判断效率的，其不会影响多个事务并发对不同的行数据加行排他锁。重要的事再重复三遍</p><p><strong>意向锁不会与行级的共享 / 排他锁互斥</strong></p><p><strong>意向锁不会与行级的共享 / 排他锁互斥</strong></p><p><strong>意向锁不会与行级的共享 / 排他锁互斥</strong></p><h5 id="3-3-示例分析"><a href="#3-3-示例分析" class="headerlink" title="3.3 示例分析"></a>3.3 示例分析</h5><p><strong>一、事务 A 先获取了<code>user</code>表 (user_id为主键)某一行的排他锁（并未提交）</strong></p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> user_id <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1、事务A会先获取了 <code>user</code> 表上的<strong>意向排他锁（IX）</strong>。</p><p>2、事务A会先获取了 <code>user</code> 表中，user_id=1对应行上的**排他锁(X)**。</p><p><strong>二、事务B尝试获取user表上的表共享锁（S）</strong></p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">lock</span> <span class="token keyword">tables</span> <span class="token keyword">use</span> <span class="token keyword">read</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1、事务B检测事务A持有use表上的<strong>意向排他锁（IX）</strong>。</p><p>2、事务B对user表加锁请求处理阻塞等待</p><p><strong>三、事务C想获取user表中另一行的排他锁</strong></p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> user_id <span class="token operator">=</span> <span class="token number">7</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1、事务C申请获取user表上的<strong>意向排他锁（IX）</strong>。</p><p>2、事务C检测到事务A已持有user表的<strong>意向排他锁（IX）</strong>。</p><p>3、因为意向排他锁（IX）之间不互斥，事务C成功获取user表上的<strong>意向排他锁（IX）</strong>。</p><p>4、因为user_id = 7对应行记录上没有排他锁，事务C成功user表上user_id=7的行上对应的<strong>行排它锁</strong>。</p><h4 id="4-Record-Locks（记录锁"><a href="#4-Record-Locks（记录锁" class="headerlink" title="4 Record Locks（记录锁)"></a>4 Record Locks（记录锁)</h4><p>​        Record Locks（记录锁）他锁定索引对应的数据行记录。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> user_id <span class="token operator">=</span> <span class="token number">7</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个词句有保证user表上user_id = 7 的记录被锁定，在当前事务没提交前，其他事务对该记录的当前读操作会被阻塞（当前读具体介绍可见我之的文章<a href="https://mp.weixin.qq.com/s/026g7KHA4ZbjsoIUf9fXNg">一文了解mysql InnDB中MVCC的今世前生</a>）。</p><h4 id="5-Gap-Locks（间隙锁）"><a href="#5-Gap-Locks（间隙锁）" class="headerlink" title="5 Gap Locks（间隙锁）"></a>5 Gap Locks（间隙锁）</h4><p>​        Gap Locks（间隙锁）用于锁定某一区间范围内的记录。它封锁索引记录中的间隔，或者第一条索引记录之前的范围，又或者最后一条索引记录之后的范围。其主要用于<strong>防止其他事务在索引记录中的间隔内部插入数据，而引起的幻读</strong>。对于<strong>读已提交</strong>(Read Committed, RC) 事务隔离级别，Gap Locks会自动失效。</p><h5 id="5-1-数据锁定范围分析"><a href="#5-1-数据锁定范围分析" class="headerlink" title="5.1 数据锁定范围分析"></a>5.1 数据锁定范围分析</h5><p>假设user表中<strong>user_id</strong>为<strong>主键(Primary Key)<strong>且为</strong>unsigned int</strong> 类型。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> user_id <span class="token operator">&lt;</span> <span class="token number">7</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        上面的操作锁定的记录范围为 user_id &gt;= 0 到 user_id = 6 的记录，只有事务提交后，其他事务才能操作该范围的记录。注意即使 user_id=3对应的记录不存在，事务没提交前，插入user_id=3记录也是不允许的，不然就没办法解决幻读问题。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> user_id <span class="token operator">></span> <span class="token number">7</span> <span class="token operator">and</span> user_id <span class="token operator">&lt;</span> <span class="token number">1000</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        上面的操作锁定的记录范围为 user_id &gt; 7 到 user_id &lt; 10000 的记录，只有事务提交后，其他事务才能操作该范围的记录。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> user_id <span class="token operator">></span> <span class="token number">1000</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        上面的操作锁定的记录范围为 user_id &gt; 1000 到 int 最大值之间的记录，只有事务提交后，其他事务才能操作该范围的记录。</p><h4 id="6-Next-Key-Locks（临键锁）"><a href="#6-Next-Key-Locks（临键锁）" class="headerlink" title="6 Next-Key Locks（临键锁）"></a>6 Next-Key Locks（临键锁）</h4><p>​        <strong>Next-Key Locks（临键锁）</strong>是 <strong>Recod Locks（记录锁）</strong>与<strong>Gap Locks（间隙锁）</strong>的组合，它的封锁范围，既包含索引记录，又包含索引区间。同样其主要用于<strong>防止其他事务在索引记录中的间隔内部插入数据，而引起的幻读</strong>。</p><p>​        假设user表中<strong>user_id</strong>为<strong>主键(Primary Key)<strong>且为</strong>unsigned int</strong> 类型，表中已有use_id 为 3，5，6，9，1000的记录。则对user_id而言可能的Next-Key Locks（临键锁）范围有</p><ul><li>[0，3]</li><li>（3，5]</li><li>（5，9]</li><li>（9，1000]</li><li>（1000，int最大值]</li></ul><h4 id="7-Insert-Intention-Locks（插入意向锁）"><a href="#7-Insert-Intention-Locks（插入意向锁）" class="headerlink" title="7 Insert Intention Locks（插入意向锁）"></a>7 Insert Intention Locks（插入意向锁）</h4><p>​        <strong>Insert Intention Locks（插入意向锁）</strong>是间隙锁(Gap Locks)的一种，其专门针对插入操作，其能提高多个事务并发向锁区间的范围内插入不同数据的并发效率，<strong>插入意向锁提高了并发插入的效率</strong>。</p><p>​        假设user表中<strong>user_id</strong>为<strong>主键(Primary Key)<strong>且为</strong>unsigned int</strong> 类型且非自增，表中已有use_id 为 7，99，1000的记录。</p><p>​        事务A先执行，在user_id=7与user_id=99两条记录中插入了一行包含user_id = 9的记录，还未提交</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token keyword">user</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> xxx<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        事务B后执行，也在user_id=7与user_id=99两条记录中插入了一行包含user_id = 97的记录，提交。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token keyword">user</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">97</span><span class="token punctuation">,</span> xxx<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此事务A与事务B分别会加user_id=9与user_id=97的    <strong>Insert Intention Locks（插入意向锁）</strong>， 事务B不会被事务B给阻塞。</p><h4 id="8-AUTO-INC-Locks（自增锁）"><a href="#8-AUTO-INC-Locks（自增锁）" class="headerlink" title="8 AUTO-INC Locks（自增锁）"></a>8 AUTO-INC Locks（自增锁）</h4><p>​        <strong>AUTO-INC Locks（自增锁）</strong>是一种特殊的表级别锁（table-level lock），专门针对事务插入AUTO_INCREMENT类型的列。最简单的情况，如果一个事务正在往表中插入记录，所有其他事务的插入必须等待，以便第一个事务插入的行，是连续的主键值。InnoDB 提供了 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_autoinc_lock_mode"><code>innodb_autoinc_lock_mode</code></a> 参数用于控制AUTO-INC Locks（自增锁）。其允许选择如何在可预测的自动增量值序列和插入操作的最大并发之间进行权衡。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​        本文介绍了mysql InnoDB存储引擎中常见的锁，并通过部分示例对锁进行简要地分析。mysql InnoDB 支持不同粒度的锁，如表锁与行锁，同时支持表锁与行锁的共存。为更高效地支持不同粒度的锁，而引入<strong>Intention Locks</strong>（意向锁）。<strong>Shared and Exclusive Locks</strong>（共享与排他锁）主要是为了提高加行锁时读写的并发性。<strong>Record Locks</strong>（记录锁）用于控制带索引记录的操作性能。<strong>Gap Locks</strong>（间隙锁）+ <strong>Next-Key Locks</strong>（临键锁）避免<strong>Repeatable Read</strong>级别下面出现幻读。<strong>Intention Locks</strong>（插入意向锁）保证多个事务，在同一个索引，同一个范围区间插入记录时，如果插入的位置不冲突，不会阻塞彼此。<strong>AUTO-INC Locks</strong> （自增锁）保证同一事务中利用数据库自增ID插入数据时ID的连续性。</p><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-shared-exclusive-locks">InnoDB Locking</a></p><p><a href="https://mp.weixin.qq.com/s/f4_o-6-JEbIzPCH09mxHJg">这次终于懂了，InnoDB的七种锁（收藏）</a></p><h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><p>​        原创不易，点赞、在看、转发是对我莫大的鼓励，关注公众号洞悉源码是对我最大支持。同时相信我会分享更多干货，我同你一起成长，我同你一起进步。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> InnoDB </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解mysql MVCC的今世前身</title>
      <link href="/2021/10/12/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3mysql%20MVCC%E7%9A%84%E4%BB%8A%E4%B8%96%E5%89%8D%E8%BA%AB/"/>
      <url>/2021/10/12/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3mysql%20MVCC%E7%9A%84%E4%BB%8A%E4%B8%96%E5%89%8D%E8%BA%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="一文详解mysql-MVCC的今世前身"><a href="#一文详解mysql-MVCC的今世前身" class="headerlink" title="一文详解mysql MVCC的今世前身"></a>一文详解mysql MVCC的今世前身</h3><h4 id="1-为什么需求MVCC"><a href="#1-为什么需求MVCC" class="headerlink" title="1 为什么需求MVCC"></a>1 为什么需求MVCC</h4><p>​        MVCC全称为<a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">Multi-Version Concurrency Control</a>（多版本并发控制），是一种数据库并发访问无锁的优化方案。其无锁优化是针对于读取时不需要加锁，其基本思路是数据库的任何修改都不会直接覆盖原来的数据，而是生成新的副本，并通过链表将新老版本副本串连，每个副本中都会包含修改数据记录的版本号，读取数据时根据版本号的对比确定链表上哪个版本的数据对当前事务可见。在该技术出现前，只有读-读之间可以并发，引入多版本控制之后，读-读、读-写、写-读都可以并发，实现读无需加锁、读写不冲突，极大提高了数据库系统的并发性。</p><p>​        在mysql InnoDB中，只有<strong>READ COMMITE</strong> 和 <strong>REPEATABLE READ</strong> 二个隔离级别下面，MVCC才会工作。READ UNCOMMITED 总读取最新版本的数据不需求MVCC进行多版本并发的控制，而SERIALIZABLE会对所有读取操作加锁，同样不需求MVCC。mysql InnoDB 存储引擎中 MVCC 机制简单的来说是通过<strong>隐式列 + undo log + read view</strong> 实现的。</p><h4 id="2-隐式列、undo-log-、-read-view、快照读和当前读"><a href="#2-隐式列、undo-log-、-read-view、快照读和当前读" class="headerlink" title="2 隐式列、undo log 、 read view、快照读和当前读"></a>2 隐式列、undo log 、 read view、快照读和当前读</h4><h5 id="2-1-隐式列"><a href="#2-1-隐式列" class="headerlink" title="2.1 隐式列"></a>2.1 隐式列</h5><p>​        InnoDB 会为第一行数据加三列，分别是<strong>DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID</strong>（ <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html">InnoDB Multi-Versioning</a>）。</p><ul><li><p><strong>DB_TRX_ID 代表最近更新或新增该行数据事务的事务标识，也可叫事务ID(删除操作也被看作一种特殊的更新)</strong></p></li><li><p><strong>DB_ROLL_PTR 表示回滚指针，其指向当前记录上一次更新或新增操作对应的undo log，undo log 能还原数据到之前的状态</strong></p></li><li><p>**DB_ROW_ID 在无聚簇索引时 innodb内部自动创建的自增id  **</p><img src="https://gitee.com/0909/blog/raw/master/img/隐式列.png" style="zoom:80%;" /></li></ul><h5 id="2-2-undo-log"><a href="#2-2-undo-log" class="headerlink" title="2.2 undo log"></a>2.2 undo log</h5><p>​        undo log 主要有两大用途一是实现InnoDB中事务的原子性，保障已部分落盘的数据可以被回滚，另外其用于实现MVCC机制中多版本数据的变向存储。undo log 是逻辑日志，其记录了上一次操作的逆向操作。</p><img src="https://gitee.com/0909/blog/raw/master/img/20211012145919.png" style="zoom:80%;" /><h5 id="2-3-read-view"><a href="#2-3-read-view" class="headerlink" title="2.3 read view"></a>2.3 read view</h5><p>​        <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_read_view">read veiw</a> 是InnoDB在进行快照读时产生时产生的<strong>读视图</strong>（后面介绍快照读，也叫一致性读 <strong>consistent read</strong> ）。当执行快照读时，系统会为其创建一个read view,  并通过最新数据与undo log链上数据中的DB_TRX_ID 与read view 进行比较，来决定<strong>当前事务</strong>（<strong>创建read view对应的事务</strong>）能够看到undo log上哪个版本的数据。</p><h5 id="2-4-快照读和当前读"><a href="#2-4-快照读和当前读" class="headerlink" title="2.4 快照读和当前读"></a>2.4 快照读和当前读</h5><p>​        <strong>快照读</strong></p><p>​        简单的select 语句（不包含 select … lock in share model, select … for update）都快照读。mysql官网的叫<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html">consistent read</a>，因为一致性读是基于快照的，通常会叫快照读，这类读不用加读锁，而是通过**隐式列 +  undo log + read view **来获取所要的数据。快照读实际就是InnoDB中MVCC机制的实现。</p><p>​        <strong>当前读</strong></p><p>​        所有的需要加锁的涉及读取的操作（可以参考mysql官网中的<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html">innodb locking reads</a> ）如</p><ul><li>select … lock in share model</li><li>select … for update</li><li>update …</li><li>insert …</li><li>delect …</li></ul><h4 id="3-Innodb-MVCC-快照读处理流程"><a href="#3-Innodb-MVCC-快照读处理流程" class="headerlink" title="3 Innodb MVCC 快照读处理流程"></a>3 Innodb MVCC 快照读处理流程</h4><p>​        通过前面简单的介绍已了解到快照读实际就是InnoDB中MVCC机制的实现。现在来看一下MVCC快照读的整体处理流程。快照读时数据可见的判断依赖于ReadView 这个数据结构，其包含关键属性如下。</p><ul><li><strong><code>m_ids</code></strong> 当前快照被创建时，活跃（已启动但未提交）的事务集合。</li><li><strong><code>m_low_limit_id</code></strong> 高水位，当前系统中的事务的最大ID值加一，即下一个开启的事务的ID。</li><li><strong><code>m_up_limit_id</code></strong>  低水位，当前活跃事务的最小ID，小于该ID的事务都是已经提交的事务。</li><li><strong><code>m_creator_trx_id</code></strong> 创建该read view的事务ID。</li></ul><img src="https://gitee.com/0909/blog/raw/master/img/事务ReadView1.png" style="zoom:80%;" /><p>​        InnoDB在处理快照读（consistent read 一致性读时），只要拿出数据中的DB_TRX_ID（隐式列中最近更新或新增该行数据事务的事务标识，事务ID）然后与ReadView中的m_ids、m_low_limit_id、m_up_limit_id、m_creator_trx_id进行比较，就可确定当前版本的数据对ReadView读视图是否可见。处理算法大体流程如下：</p><p>**1、如果DB_TRX_ID = m_creator_trx_id, DB_TRX_ID 对应数据对当前事务可见，表示这条数据是由当前事务m_creator_trx_id 创建的。 **</p><p><strong>2、DB_TRX_ID ≥ m_low_limit_id （高水位）， DB_TRX_ID 对应数据对当前事务不可见，表示这条数据是由将来的事务更新的。</strong></p><p><strong>3、DB_TRX_ID &lt; m_up_limit_id （低水位） ，DB_TRX_ID 对应数据对当前事务可见，表示这条数据是由已经提交的事务更新的。</strong></p><p><strong>4、DB_TRX_ID 介于高水位与低水位之间，如果DB_TRX_ID在m_ids（活跃事务集合）中，表示尚未提交的事务， DB_TRX_ID 对应数据对当前事务不可见;  如果DB_TRX_ID不在m_ids（活跃事务集合）中，表示事务已经提交了， DB_TRX_ID 对应数据对当前事务可见。</strong></p><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html">The InnoDB Storage Engine</a></p><p><a href="https://github.com/mysql/mysql-server/blob/5.7/storage/innobase/include/read0types.h">mysql5.7 ReadView 源码</a></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> MVCC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统下面业务操作幂等的必要性</title>
      <link href="/2021/10/01/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%9D%A2%E4%B8%9A%E5%8A%A1%E6%93%8D%E4%BD%9C%E5%B9%82%E7%AD%89%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/"/>
      <url>/2021/10/01/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%9D%A2%E4%B8%9A%E5%8A%A1%E6%93%8D%E4%BD%9C%E5%B9%82%E7%AD%89%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="幂等性的常见实现方法"><a href="#幂等性的常见实现方法" class="headerlink" title="幂等性的常见实现方法"></a>幂等性的常见实现方法</h3><h4 id="1-为什么分布式系统要求业务操作的幂等性"><a href="#1-为什么分布式系统要求业务操作的幂等性" class="headerlink" title="1 为什么分布式系统要求业务操作的幂等性"></a>1 为什么分布式系统要求业务操作的幂等性</h4><p>幂等（idempotent）的概念源于数学，幂等的特点是任意多次执行所产生的影响均与一次执行产生的影响相同，不会因为多次的操作产生别的副作用。分布式系统由多个系统与节点组成，系统与节点在进行通信时由于网络、系统或节点的不稳定性导致一次系统与系统之间接口调用结果的三态，成功、失败、未知（请求已发出，但出现超时返回异常，此时下游系统可能已处理成功也可能处理失败）。系统在处理未知状态的调用结果时，通常会通过定时任务进行重试，这也就导致了位于下游的系统其接口可能会被相同的请求重复调用多次的情况。如果分布式系统没有保证各业务操作的幂等，必然导致由于多次相同操作带来的业务副作用（用户同一笔订单支付了多次，用户收到多条相同的发货通知、商品下面展示了多条用户同一时间的相同评论记录）。</p><h4 id="2-实现业务操作幂等性的常用方法"><a href="#2-实现业务操作幂等性的常用方法" class="headerlink" title="2 实现业务操作幂等性的常用方法"></a>2 实现业务操作幂等性的常用方法</h4><h5 id="2-1-业务Token"><a href="#2-1-业务Token" class="headerlink" title="2.1 业务Token"></a>2.1 业务Token</h5><p>​        业务Token通常的作法是在请求实际的业务操作前先去获取对应的业务Token，下游业务根据请求参数与时间生成Token，然后将Token写入缓存并设置一定的过期时间。真正发起业务请求时，请求发起方会将业务Token加入到请求参数中。下游业务收到业务请求后会先判段缓存中Token是否存在，如果存在则删除缓存中的业务Token并执行业务逻辑，如果不存则直接返回错误。<strong>这种做法实际是防重而非真正意思上的幂等</strong>。</p><img src="https://gitee.com/0909/blog/raw/master/img/幂等.png" style="zoom:80%;" /><p>​        <strong>方案优点、缺点、合适业务场景</strong>：业务Token方案整体实现简单，但实际为防重策略，Token过期时间要根据业务情况去确定。对于新增数据的业务场景比较适合，比如用户在支付订单前，在进入支付订单页面时交易系统可以先根据用户与订单的信息从支付系统获取业务Token，然后在支付时再将支付信息、订单信息、业务Token一起传给支付系统，支付系统再去校验业务Token，存在则调用支付渠道执行支付逻辑，不存在直接返回支付失败。</p><h5 id="2-2-乐观锁-状态机或版本号"><a href="#2-2-乐观锁-状态机或版本号" class="headerlink" title="2.2 乐观锁 + 状态机或版本号"></a>2.2 乐观锁 + 状态机或版本号</h5><p>​        乐观锁+状态机或版本号，通常的作法是在执行业务逻辑时将对应的SQL加上乐观锁，SQL的条件一般是有现在状态或版本号。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">update</span> <span class="token keyword">order</span> <span class="token keyword">set</span> order_status <span class="token operator">=</span> ${next_status} <span class="token keyword">where</span> order_status <span class="token operator">=</span> ${current_status}<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有些场景也会直接通过版本号使用乐观锁。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">update</span> post_detail <span class="token keyword">set</span> title <span class="token operator">=</span> ${title}<span class="token punctuation">,</span> content <span class="token operator">=</span> ${content}<span class="token punctuation">,</span> version <span class="token operator">=</span> ${current_version} <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">where</span> version <span class="token operator">=</span> ${current_version}<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <strong>方案优点、缺点、合适业务场景</strong>：实现简单，不依赖外部系统，效率高，但不适合新增数据的业务场景只适合数据更新场景。这种方式不仅适合处理并发请求量很大的场景同时，同时适时一些请求量很小的场景。比如一些运营后台。</p><img src="https://gitee.com/0909/blog/raw/master/img/version.png" style="zoom:80%;" /><p>​        多运营人员同时操作一内容导致，最后运营人员A以为最终内容是title为t2，content为c1，运营人员B以为最终内容是title为t1，content为c2。而实际数据库中的数据为运营人员A与运营人员B操作的之和，<strong>还有一种可能是运营人员B直接把运营人员A的操作内容给覆盖了</strong>，再运营人员B与A完全不知情时。这种场景更好的处理方式是通过乐观锁+版本号。直接让后继的操作运营人员感知，之前的内容以被修改。</p><img src="https://gitee.com/0909/blog/raw/master/img/fail_with_version.png" style="zoom:80%;" /><h5 id="2-3-悲观锁"><a href="#2-3-悲观锁" class="headerlink" title="2.3 悲观锁"></a>2.3 悲观锁</h5><p>​        悲观锁实现分为单进程与多进程。单进程要么是在应用层加锁要么是在BD层面加锁。应用层加锁Java语言中可以通过synchronize关键字或是并发包下面的Lock子类实现。BD层面加锁可以采用select for update实现，但要避免锁表的情况。多进程场景的话要通过分布式锁来实现，主流的实现思路有Redis,  Zookeeper。Redis实现上可以直接使用Redisson实现的RedLock。Zookeeper可以通过其watch机制实现分布式锁。</p><p>​        <strong>方案优点、缺点、合适业务场景</strong>：悲观锁应该是在没有其他合适方案时才会采取的兜底方案。悲观锁会降低系统整体的并发量。采用select for update 能保证BD层面数据的一致性，但存在锁表的风险。                    </p><h5 id="2-4-去重表-唯一索引"><a href="#2-4-去重表-唯一索引" class="headerlink" title="2.4 去重表(唯一索引)"></a>2.4 去重表(唯一索引)</h5><p>​        去重表的实现思路是请求自身带唯一的ID，或是根据请求参数与时间等特性生成唯一的ID，下游服务在处理请求时，先将唯一ID插入去重表中(唯一ID是去重表的唯一索引)，成功则执行业务逻辑，DB层面抛出DuplicateKeyException时则直接返回失败或是检索历史处理结果返回。去重表（唯一索引）非常<strong>适合处理MQ消费消息场景时的幂等性问题。通常MQ都不会保证消息投递的唯一性，下游在消费消息时一定要根据业务场景的不同考虑是否要保证消费消息的幂等性</strong>。</p><h4 id="3-业务场景分析"><a href="#3-业务场景分析" class="headerlink" title="3 业务场景分析"></a>3 业务场景分析</h4><p>​        实际的业务场景中通常会结合多种方式来保证业务操作的幂等性。下面简要的介绍一下支付业务场景的幂等实现。</p><h5 id="3-1-支付业务场景"><a href="#3-1-支付业务场景" class="headerlink" title="3.1 支付业务场景"></a>3.1 支付业务场景</h5><p><img src="https://gitee.com/0909/blog/raw/master/img/%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86.png" alt="支付流程"></p><p>​        上面是用户支付订单场景时业务系统、支付中心、支付通道之间整体交互的时序图（同业务应用APP与业务服系统交互部分统一划到业务系统/应用，同支付通道与支付通道APP交互部分统一划到支付通道）。 整个流程可分为三大步 <strong>一、用户发起订单支付进入收银台 ，二、用户选定支付产品，确认支付 ，三、应用通过SDK调用支付通道，展示支付结果。</strong>这三大步中业务系统与支付中心交互的接口共有三个分别是<strong>统一下单接口（createPayOrder 1.2步）、支付接口（pay 2.3步）、支付结果查询接口（queryPayResult 3.3 步）</strong>。在整体流程中业务系统与支付中心比较重要的数据模型有<strong>业务订单（业务系统）、支付订单（支付中心）、支付流水单（支付中心），比较重要的状态有业务订单支付状态、支付订单支付状态、支付流水支付状态。业务订单支付状态：待支付、支付中、支付成功、支付失败，支付订单支付状态：待支付、支付中、支付成功、支付失败，支付流水支付状态：待支付、支付中、支付成功、支付失败。</strong></p><p><strong>一、统一下单接口（createPayOrder）幂等</strong></p><p>​       用户从业务APP订单页面，点击去支付会进入收银台页面。<strong>在实现每次进入收银台页面前或是重新切换到收银台页面，业务APP实际会先根据业务订单号调用支付结果查询接口，如果已支付成功则提示不能重复支付，后跳会之前的页面。</strong> 支付中心的统一下单接口（createPayOrder）会根据业务标识与业务订单号去创建支付订单并返回支付单号。实际上业务系统在获取收银支付产品列表时支付系统内会调统一下单接口（createPayOrder）。如果在这个过程中发面支付中心已存在对应订单号的支付订单且支付状态为支付成功，则不会返回支付产品列表，而且提示该订单已支付成功。<strong>统一下单接口（createPayOrder）通过支付订单表中业务标识与业务订单组成的唯一锁引防重与处理幂等。</strong></p><img src="https://gitee.com/0909/blog/raw/master/img/支付统一下单幂等.png" style="zoom:80%;" /><p><strong>二、支付接口（pay ）幂等</strong></p><p>​        用户进入收银台页面后，选中某一支付产品后，点击确认支付时。业务APP实际会通过业务系统调用支付中心的支付接口(pay)。支付中心内部会根据支付单号、支付产品编码去创建支付流水，并根据支付产吕编码调用支付通道统一下单接口返回预支付标识，支付中心再根据不同的支付通道组装并加密支付参数，然后返回给业务APP，APP根据返回的支付参数通过SDK调对应支付通道的支付方法。</p><p>​        </p><img src="https://gitee.com/0909/blog/raw/master/img/支付接口幂等.png" style="zoom:80%;" /><p>上面整体流程上有几点要注意：</p><p>​        <strong>1、为了降低用户重复支付的概率，支付中心应该对支付订单进行锁单，业务系统第一次调pay支付接口后用支付中心会用支付单号对支付订单进行锁单，同时会设置一个较短的释放时间如2s，当用户频繁操作时如果支付订单处理锁单状态直接提示用户操作过于频繁请误重复支付。</strong></p><p>​        <strong>2、在创建支付流水前要检查支付流水记录中否存在同一支付单号的其他支付中的支付流水，如果存在要支付中心应主动调用对应支付通道支付结果查询接口进行处理。如果支付通道侧返回支付成功，则提用户请误重复支付。</strong></p><p>​        <strong>3、按上面的流程处理还是可以出现重复支付的情况，在支付单未被锁单或之前的锁单已释放后，可能出现用户多次支付的情况。当同一支付单号有多笔支付状态为支付成功的支付流水时，应做相应的原路退款处理。</strong></p><p>​        <strong>4、在用户支付的过程中，如果业务订单刚好超时自动关闭，最终导致业务系统无法正常处理支付中心支付成功的消息，对这种特殊情况一定要做好处理。</strong></p><p><strong>三、支付结果查询接口（queryPayResult ）幂等</strong></p><p>​        支付结果查询接口，主要用于业务则APP在SDK调用支付通道支付接口后，并同步收到支付结果，后进行主动查询当前业务订单是否支付成，并展示对应的支付结果给用户。</p><img src="https://gitee.com/0909/blog/raw/master/img/支付结果查询接口幂等.png" style="zoom:80%;" /><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​        本文简要地总结了常见的处理幂等手段与其适用的场景，这些处理手段的本质共性可归纳为<strong>让请求串行或唯一化，某一时间只处一请求</strong>。<strong>悲欢锁实际是在让请求串行化，业务Token、乐观锁 + 状态机或版本号、去重表(唯一索引)实际是在让请求唯一化</strong>。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://it.deepinmind.com/distributed/2019/06/30/avoiding-double-payments-in-a-distributed-payments-system.html">Avoiding Double Payments in a Distributed Payments System</a></p><p><a href="https://www.codenong.com/js93dfce882bf5/">Airbnb支付系统如何在分布式环境下避免重复打款</a></p><p><a href="https://tech.meituan.com/2016/09/29/distributed-system-mutually-exclusive-idempotence-cerberus-gtis.html">分布式系统互斥性与幂等性问题的分析与解决</a></p><p><a href="https://mp.weixin.qq.com/s/9Z-N3cfWu7oMVJsTDkbb-Q">基于有限状态机与消息队列的三方支付系统补单实践</a></p><p><a href="https://www.jianshu.com/p/2c8cf162cf62">第三方支付微服务幂等设计</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 幂等 </tag>
            
            <tag> 支付 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存常见风险(缓存穿透、缓存击穿、缓存雪崩、缓存污染)与应对方法</title>
      <link href="/2021/09/06/%E7%BC%93%E5%AD%98%E5%B8%B8%E8%A7%81%E9%A3%8E%E9%99%A9(%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93)%E4%B8%8E%E5%BA%94%E5%AF%B9%E6%96%B9%E6%B3%95/"/>
      <url>/2021/09/06/%E7%BC%93%E5%AD%98%E5%B8%B8%E8%A7%81%E9%A3%8E%E9%99%A9(%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93)%E4%B8%8E%E5%BA%94%E5%AF%B9%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="缓存常见风险-缓存穿透、缓存击穿、缓存雪崩、缓存污染-与应对方法"><a href="#缓存常见风险-缓存穿透、缓存击穿、缓存雪崩、缓存污染-与应对方法" class="headerlink" title="缓存常见风险(缓存穿透、缓存击穿、缓存雪崩、缓存污染)与应对方法"></a>缓存常见风险(缓存穿透、缓存击穿、缓存雪崩、缓存污染)与应对方法</h3><h4 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1 缓存穿透"></a>1 缓存穿透</h4><p>​ 缓存穿透是指由于请求要获取的数据不在实际的数据源中（数据库），导致每次请求都会穿透缓存，直接落在实际的数据源（数据库）上。这类请求使得缓存层无法缓解真实数据源上的 CUP 或 I/O 压力，最终使得服务可用性与稳定性下降。产生这类问题通常是业务逻辑本身不合理或存在问题，或者可能是被恶意攻击。解决缓存穿透常用的方法有下面三种。</p><h5 id="1-1-接口校验"><a href="#1-1-接口校验" class="headerlink" title="1.1 接口校验"></a>1.1 接口校验</h5><p>​ 正常业务流程中可能会存在少量访问不存在 key 的情况，如果有但的不存 key 的情况，很有可能系统遭受了恶意的攻击。对应这种问题有效的方法之一就是在服务调用的最外层对基本的数据合法性、用户访问权限进行校验。例如对于商品查询中，商品 ID 通过是正整数，对于负数业务层可以直接返回参数非法。</p><h5 id="1-2-存储空值-业务合适的默认值"><a href="#1-2-存储空值-业务合适的默认值" class="headerlink" title="1.2 存储空值/业务合适的默认值"></a>1.2 存储空值/业务合适的默认值</h5><p>​ 虽然数据源（数据库）中，没有请求所要的数据，但可以考虑缓存空值或是业务合适的默认值来便向处理该问题。这么做要注意两点：<strong>一对应的缓存值要约定一个比较短的过期时间，使得一段时间内缓存最多被击穿一次。</strong> <strong>二后继业务在数据中新增了该 key 对应的数据，那应当在插入之后主动清理掉缓存的 Key 值。</strong></p><h5 id="1-3-布隆过滤器（Bloom-Filter）"><a href="#1-3-布隆过滤器（Bloom-Filter）" class="headerlink" title="1.3 布隆过滤器（Bloom Filter）"></a>1.3 布隆过滤器（Bloom Filter）</h5><p>​ 对于恶意攻击导致的缓存穿透，通常会在缓存之前设置一个布隆过滤器来解决。这类恶意攻击者通常会刻意制造数据库中肯定不存在的 key 值，然后发送大量的请求。布隆过滤器可以将不存在的 key 值拦截在缓存层之外，让到达缓存层的流量，几乎在数据源（数据库）中都是存在 key 值的。布隆过滤器由一个 bitSet 和 一组 Hash 函数（算法）组成，是一种空间效率极高的概率型算法和数据结构，主要用来判断一个元素是否在集合中存在。通常会将数据源（数据库）中存在的 key 值全量放入布隆过滤器中。如果请求的 key 值布隆过滤器中找不到，那么将直接返回，这类 key 值在源数据源（数据库中）中一定不存在，但<strong>要注意请求的 key 在布隆过滤器中，也有可以最后 key 值在数据源中找不到</strong>，因为布隆过滤器可能存在漏判的情况，但经过多次 hash 后这种情况的概率通常会很低。下面给一个误判示例。</p><img src="https://gitee.com/0909/blog/raw/master/img/bloomfilter.png" alt="bloomfilter" style="zoom:80%;" /><p>如上图，假设数据库中有 a 和 b 两条记录，通过布隆过滤器的 h1、h2、h3 三个散列函数得到 bitset 的位下标然后标记为 1，最后 a 与 b 两条记录在布隆过滤器中保存成功。然后查询请求要获取值为 c 的记录。c 虽然没有在数据库中但由于 c 的 h1(c)、h2(c)、h3(c) ,分别已数据 a 和 b 两条记录的 h2(a)、h1(b)、h3(a)值相同，最终导致误判。<strong>注意布隆过滤器有一个比较大的弊端就是存在其中的数据不支持删除。那么如果有数据要从隆过滤器剔除应该如何处理呢，剔除了又要存回隆过滤器该如何处理？</strong> 如果删除频率比较低且数据量少的话，可以用一个 HashMap 维护删除的记录，用于标记其不在隆过滤器内。请求时先走一下 HashMap，再走隆过滤器。那如果删除频率比较高且数据量很大的话，使用 HashMap 就不合适了。这个问题就先放这里吧。_ v _</p><h4 id="2-缓存击穿"><a href="#2-缓存击穿" class="headerlink" title="2 缓存击穿"></a>2 缓存击穿</h4><p>​ 缓存击穿是指由于某种原因缓存中的数据已失效（如缓存过期），而此时有大量的请求来获取该数据，最终由于缓存中没有数据，所有请求都落在实际的数据源（数据库）上。通常热点 key 的失效，容易导致缓存击穿。</p><h5 id="2-1-热点数据管理"><a href="#2-1-热点数据管理" class="headerlink" title="2.1 热点数据管理"></a>2.1 热点数据管理</h5><p>​ 热点数据由代码来手动管理，缓存击穿是仅针对热点数据被自动失效才引发的问题，对于这类数据，可以直接由开发者通过代码来有计划地完成更新、失效，避免由缓存的策略自动管理。极端情况可能设置热点永不过期。</p><h5 id="2-2-加锁同步"><a href="#2-2-加锁同步" class="headerlink" title="2.2 加锁同步"></a>2.2 加锁同步</h5><p>​ 以请求该数据的 Key 值为锁，使得只有第一个请求可以流入到真实的数据源中，其他线程采取阻塞或重试策略。当第一个请求从数据源中获取到数据后，在将数据写入到缓存中。如果是进程内缓存出现问题，施加普通互斥锁即可，如果是分布式缓存中出现的问题，就施加分布式锁，这样数据源就不会同时收到大量针对同一个数据的请求了。下面给出伪代码的实现，这里没有区分进程内的情况与分布式的情况。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getData</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//从缓存中获取数据</span>    String data <span class="token operator">=</span> <span class="token function">getDataFromCache</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//缓存中存在数据直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> data<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//尝试获取锁，并成功</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//再次尝试从缓存中获取数据</span>            data <span class="token operator">=</span> <span class="token function">getDataFromCache</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//缓存中存在数据直接返回</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> data<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//从DB中获取数据</span>            data <span class="token operator">=</span> <span class="token function">getDataFromDB</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//数据存在设置缓存</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setCache</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> data<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 释放获取到的锁</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//尝试获取锁，但失败。线程sleep 100毫秒后，再次调用获取数据方法。</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">getData</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3 缓存雪崩"></a>3 缓存雪崩</h4><p>​ 缓存击穿是针对单个热点数据失效，由大量请求击穿缓存而给真实数据源带来压力。而缓存雪崩侧是由于大量不同数据在短时间内一起失效，导致这些数据对应的大量请求在缓存层上无法命中，直接达到了真实的数据源，最终导致数据源在短时间内压力剧增。通常这种情况产生的原因有两种，一是由于缓存服务因某些原因崩溃后重启，此时也会造成大量数据同时失效;另外一种是由于大量公共数据从一次操作加载的，这样都可能出现由此载入缓存的大批数据具有相同的过期时间，在同一时刻一起失效。</p><h5 id="3-1-增强缓存层可用性"><a href="#3-1-增强缓存层可用性" class="headerlink" title="3.1 增强缓存层可用性"></a>3.1 增强缓存层可用性</h5><p>​ 为了避免由于缓存层自崩溃后重启，大量请求导致缓存雪崩。缓存层应集群化部署，同时缓存系统前应该做相应的流量控制，超过阈值部分的流量直接丢弃或者先缓存在 MQ 中（流量高风过后在逐步处理请求）。</p><h5 id="3-2-分散缓存过期时间"><a href="#3-2-分散缓存过期时间" class="headerlink" title="3.2 分散缓存过期时间"></a>3.2 分散缓存过期时间</h5><p>​ 为了避免大量热点数据在某个时间段内集中失效，我们在在设置失效时间时可以在原时间的基础上加上或者减去一个范围内的随机值。比如原本是一个小时过期，在缓存不同数据时，设置生存期为 55 分钟到 65 分钟之间的某个随机时间。</p><h4 id="4-缓存污染"><a href="#4-缓存污染" class="headerlink" title="4 缓存污染"></a>4 缓存污染</h4><p>​ 所谓的缓存污染是指缓存中的数据与真实数据源中的数据不一致的情况。虽然缓存通常不追求强一致性，但这我们应当最大程度上保证缓存中的数据与真实数据源中的数据一致，并通过某种手段保证数据的最终的一致性。</p><p>​ 缓存污染大多数是由开发者更新缓存不规范造成的，比如执行某类业务操作，先更新了缓存中某些值，然后再执行业务逻辑更新数据源中的数据，但由于某些原因（后继业务发生异常回滚了）最终没有成功写入到数据源，此时缓存的数据是新的，而数据源中的数据却是旧的。<strong>另外一种常见的不规范的操作是先更新 BD，再更新缓存</strong>。</p><img src="https://gitee.com/0909/blog/raw/master/img/updateCacheInvalid.png" alt="错误更新缓存" style="zoom:80%;" /><p>​ 时间轴的顺是 T1、T2、T3、T4、T5，执行的业务逻辑分别是进程 A 更新 DB 数据 V 为 1、进程 B 更新 DB 数据 V 为 2、进程 B 更新缓存数据 V 为 2、进程 A 更新缓存数据 V 为 1、进程 C 读取缓存数据 V 为 1。可以看到 DB 中数据 V 对应的实际为 2，而缓存中存储的值为进程 A 更新的值 1，最终导致进程 C 读取到的缓存数据 V 的值为 1，该值与数据库中 V 的真实值不一致。</p><p>​ 为了提高数据的最终一致性，业界提出了很多缓存更新的模式，如 Read/Write Through、Write Behind Caching 、 Cache Aside 等。</p><h5 id="4-1-Read-Write-Through"><a href="#4-1-Read-Write-Through" class="headerlink" title="4.1 Read/Write Through"></a>4.1 Read/Write Through</h5><p>​ Read/Write Through 简单的来讲就是通过读写来去更新缓存，而真实数据源层对业务操作来说是透明的，这样种模式的个显著特点就是业务代码与缓存、真实数据源之间的耦合度低，代码简洁。但缓存层要单独去实现与维护。</p><p>​ Read Through 业务层直接从缓存中读取数据，不关心缓存中数据获取的逻辑。</p><img src="https://gitee.com/0909/blog/raw/master/img/Cache-Read-through.png" alt="Cache-Read-through" style="zoom:80%;" /><p>​ Write Through 写缓存与真实数据源在同一个事务中执行，要么同时成功要么同时失败。这样一定程度上增加了请求处理的时间，但保证了缓存与真实数据源中数据的一致性。</p><img src="https://gitee.com/0909/blog/raw/master/img/Cache-Write-through.png" alt="Cache-Write-through" style="zoom:80%;" /><h5 id="4-2-Write-Behind-Caching"><a href="#4-2-Write-Behind-Caching" class="headerlink" title="4.2 Write Behind Caching"></a>4.2 Write Behind Caching</h5><p>​ Write Behind Caching 是指先写缓存，然后再按一定的策略去更新真实数据源。可以同步刷新、也可以是异步刷新。对于一些大批量写的业务场景，该模式能极大<strong>提高系统处理能力、降低系统的延时性</strong>。该模式的缺点是<strong>可能导致缓存中的数据与真实数据源中的数据不一致</strong>。Write Behind Caching 内部可以将这些批量操作在缓存中做一定的聚合，然后再按某种策略写到真实的数据源中。这种模式 Write Behind Caching 与 Write Through 共同点是缓存层与真实数据源之间的交互对应业务层面来说都是透明的。与 Write Through 对比能发现该模式适合<strong>处理大批量的写操作，同时允许存在一定的数据不一致性的业务场景</strong>，比如非关键业务的日志处理。</p><h5 id="4-3-Cache-Aside"><a href="#4-3-Cache-Aside" class="headerlink" title="4.3 Cache Aside"></a>4.3 Cache Aside</h5><p>​ 该模式简单同时实现成本低，而且能较好的保证数据一致性。其获取数据整体流程可以分为以下几步：</p><p>1、业务层请求获取某个 key 对应的数据。</p><p>2、业务层检查缓存中是否存在请求 key 对应的值。如果缓存存在（缓存命中），从缓存中拿出对应值，如果缓存不存在先再从实际数据源（数据库）中获取对应的数据，在将数据写入缓存中。</p><p>3、业务层返回 key 对应的值。</p><img src="https://gitee.com/0909/blog/raw/master/img/cache-aside.png" alt="cache-aside" style="zoom:80%;" /><p>其更新流程总体可分为以下步骤：</p><p>1、业务层更新数据源（数据库）对应的数据。</p><p>2、如果更新数据源（数据库）中的数据成功，设置缓存层数据失效。</p><p>注意<strong>第二步骤中如果更新数据源（数据库）中的数据成功，接着是要让缓存层数据失效，而不是去更新缓存中的数据</strong>。前面已分析了先更新数据源（数据库）再更新缓存可能导致的数据不一致问题。<strong>那么是不是遵循 Cache Aside 的模式处理数据就不会存在数据不一致性的问题呢？</strong>实际上还是有数据还是有可能存在不一致只是这种情况的概率很小。</p><img src="https://gitee.com/0909/blog/raw/master/img/cache-aside-fail.png" style="zoom:80%;" /><p>时间轴的顺是 T1、T2、T3、T4、T5、T6，执行的业务逻辑分别是进程 A 获取缓存数据 V 不存在、进程 A 获取 DB 中数据 V 为 1、进程 B 更新 DB 数据 V 为 2、进程 B 设置数据 V 缓存失效、进程 A 设置缓存数据 V 为 1、进程 C 读取缓存数据 V 为 1。可以看到 DB 中数据 V 对应的实际为 2，而缓存中存储的值为进程 A 更新的值 1，最终导致进程 C 读取到的缓存数据 V 的值为 1，该值与数据库中 V 的真实值不一致。但这种情况的概率很小，理论上进程 B 在执行更新 DB 数据 V 为 2 与进程 B 设置数据 V 缓存失效两步（操作 DB 与操作缓存）所要花费的时间运大于进程 A 设置缓存数据 V 为 1（操作缓存）时间。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​ 本文总结了缓存常见风险(缓存穿透、缓存击穿、缓存雪崩、缓存污染)与应对方法。跟这个话题相关的文章应该是到处都是，而且面试也经常会被问到，但个人觉得很多东西还是要系统性地去总结一下，然后再总结的过程中去更多的思考一些自己平时忽视的关键性点。这些关键性点往往也是别人容易忽视的。在写总结性文章时不能去找出一些关键性点意义可能就没那么大了。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://catsincode.com/caching-strategy/">Caching Strategies Overview</a></p><p><a href="http://icyfenix.cn/architect-perspective/general-architecture/diversion-system/cache-middleware.html#%E7%BC%93%E5%AD%98%E9%A3%8E%E9%99%A9">缓存风险</a></p><p><a href="https://coolshell.cn/articles/17416.html">缓存更新的套路</a></p>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
