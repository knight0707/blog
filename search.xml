<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一文详解ThreadLocal内存泄漏问题原因</title>
      <link href="/2021/10/25/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3ThreadLocal/"/>
      <url>/2021/10/25/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3ThreadLocal/</url>
      
        <content type="html"><![CDATA[<h3 id="一文详解JDK中的ThreadLocal"><a href="#一文详解JDK中的ThreadLocal" class="headerlink" title="一文详解JDK中的ThreadLocal"></a>一文详解JDK中的ThreadLocal</h3><h4 id="1-ThreadLocal概述"><a href="#1-ThreadLocal概述" class="headerlink" title="1 ThreadLocal概述"></a>1 ThreadLocal概述</h4><p>​        <strong>ThreadLocal</strong> 提供了<strong>一种变量与线程绑定的机制</strong>，通常把这种机制称为<strong>线程本地变量</strong>，在线程调用栈（方法调用链）的入口或中间可以让一些重要的变量与线程绑定，在后继的调用栈（方法调用链）可使用该变量。这个特性使得<strong>ThreadLocal适用于方法调用链上参数透传</strong>，如APM、日志、权限框架中透传上游重要的参数到下游。</p><p>​        <strong>ThreadLocal不支持不同线程间变量的透传</strong>，即如果在线程A中设置了一个变量ThreadLocalA 其中存储的值为AA，在线程B中想拿到ThreadLocalA 中存储的AA是拿不到的（结果将是null）。这也导致了使用线程池的线程，不能通过<strong>ThreadLocal</strong>将<strong>线程本地变量</strong>传递到线程池中供其使用（线程池中执行任务的线程通常不是提交任务对应的线程），同样类似线程间的异步操作<strong>ThreadLocal</strong>也不支持。线程间<strong>线程本地变量</strong>的透传可以通过阿里开源的<strong>TrasmittableThreadLocal</strong>来实现。当子线程要获取父线程中的<strong>线程本地变量</strong>，通过ThreadLocal同样无法获取，但可能通过其子类<strong>InheritableThreadLocal</strong>实现。</p><p>​        在高并发场景下，JDK自带的<strong>ThreadLocal</strong>性能不如<strong>Netty</strong>框架中实现的<strong>FastThreadLocal</strong>，<strong>FastThreadLocal</strong> 获取其中保证的变量值时，使用内部的index变量便可定位对应变量值，而不用像ThreadLocal那样通过<strong>开放地址法</strong>去定位对应变量值。</p><p>​        <strong>ThreadLocal</strong> 的线程本地变量机制实际是通过 <strong>Thread</strong>类中的<strong>ThreadLocalMap</strong>成员变量实现的。每一个<strong>Thread</strong>实例都维护了一个<strong>ThreadLocalMap</strong>实例。<strong>ThreadLocalMap</strong>通过<strong>开放地址法</strong>实现，其<strong>Key</strong>为<strong>ThreadLocal</strong>，<strong>Value</strong>为<strong>ThreadLocal</strong>中保存的变量。其<strong>开放地址法</strong>底层对应的数组为<strong>Entry数组</strong>，<strong>Entry</strong>类持有了<strong>ThreadLocal</strong>的<strong>WeakReference</strong>，持有了<strong>ThreadLocal</strong>中保存变量的强引用，这导致了不恰当的使用ThreadLocal容易引发内存泄漏问题。</p><h4 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2 源码分析"></a>2 源码分析</h4><p><strong>注意：下面的ThreadLocal的源码分析基本JDK8</strong></p><h5 id="2-1-引用类型"><a href="#2-1-引用类型" class="headerlink" title="2.1 引用类型"></a>2.1 引用类型</h5><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>​        <strong>ThreadLocal</strong>类本身比较简单其支持泛型，一共没有几行代码，其set与get方法上复杂的处理最终都到了内部类类<strong>ThreadLocalMap</strong>上，并且<strong>ThreadLocalMap</strong>使用<strong>WeakReference</strong>所涉及的东西比较多。<strong>Reference</strong>的源码分析参考之前的文章<a href="https://mp.weixin.qq.com/s/8f29ZfGvZVPe0bO-FahokQ">Java Reference核心原理分析</a>。</p><p>​            这里先简单介绍一下java语言中的引用类型。java语言中引用类型分为<strong>强引用、软引用（SoftReference）、弱引用（WeakReference）、虚引用（PhantomReference）</strong>。</p><ul><li><p><strong>强引用</strong></p><p>通常代码中看到的变量引用关系如下面的 threadLocalData，variable对对象的引用都是强引用</p><pre class="line-numbers language-java"><code class="language-java">ThreadLocal<span class="token operator">&lt;</span>Integer<span class="token operator">></span> threadLocalData <span class="token operator">=</span> ThreadLocal<span class="token punctuation">.</span><span class="token function">withInitial</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String variable <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>软引用 （SoftReference）</strong></p><p>垃圾回收器会根据内存需求酌情回收软引用指向的对象。普通的GC并不会回收软引用，只有在即将<strong>OOM</strong>的时候(也就是最后一次<strong>Full GC</strong>)如果被引用的对象只有<strong>SoftReference</strong>指向的引用，才会回收。如下<strong>SoftValueReference</strong>便持有其值V的软引用。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">SoftValueReference</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token keyword">extends</span>   <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">ValueReference</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>   <span class="token keyword">final</span> ReferenceEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> entry<span class="token punctuation">;</span>   <span class="token function">SoftValueReference</span><span class="token punctuation">(</span>ReferenceQueue<span class="token operator">&lt;</span>V<span class="token operator">></span> queue<span class="token punctuation">,</span> V referent<span class="token punctuation">,</span>                                                  ReferenceEntry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> entry<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">super</span><span class="token punctuation">(</span>referent<span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>entry <span class="token operator">=</span> entry<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>弱引用（WeakReference）</strong></p><p>当发生GC时，如果当前对象只有<strong>WeakReference</strong> 类型的引用，则会被GC给回收掉。如下<strong>ThreadLocalMap</strong> map中的<strong>Entry</strong>便持有<strong>ThreadLocal</strong>的软引用。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">/** The value associated with this ThreadLocal. */</span>  Object value<span class="token punctuation">;</span>  <span class="token function">Entry</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> k<span class="token punctuation">,</span> Object v<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    value <span class="token operator">=</span> v<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p><strong>虚引用（PhantomReference）</strong></p><p>他是一种特殊的引用类型，不能通过虚引用获取到其关联的对象，但当GC时如果其引用的对象被回收，这个事件程序可以感知，这样我们可以做相应的处理。其最常用的场景是GC回收<strong>DirectByteBuffer</strong>对象时，利用<strong>Cleaner</strong>调用Unsafe类回收其对应的堆外内存。具体源码分析可参考<a href="https://mp.weixin.qq.com/s/8f29ZfGvZVPe0bO-FahokQ">Java Reference核心原理分析</a>。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Cleaner</span> <span class="token keyword">extends</span> <span class="token class-name">PhantomReference</span><span class="token operator">&lt;</span>Object<span class="token operator">></span> <span class="token punctuation">{</span>         <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ul><p>​        前面简单地介绍了对象的引用类型，GC决定一个对象是否能被回收与当对象具有的引用类型有很大的关系。一般会从GC Root开始向下搜索，如果对象与GC Root之间存在直接或间接的强引用有关系，则当前对象强可到达，不能被回收。如对象与GC Root之间只存在直接或间接的软引用有关系，则当前对象软可到达，GC时会视当前内存情况确定是否回收该对象。如对象与GC Root之间只存在直接或间接的弱引用有关系，则当前对象弱可到达，GC时不管内存如何该对象将都被回收，但在GC前可以再次强引用该对象达到让该对象不被回收。如对象与GC Root之间只存在直接或间接的虚引用有关系，则当前对象虚可到达，GC时该对象将被回收。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211026153107.png"></p><p>​        上面ObjectA、ObjectB、ObjectC、ObjectD、ObjectE、ObjectF、ObjectG 7个对象。</p><ul><li>与GC Root存在直接或间接强引用关系的对象有 ObjectA，GC时ObjectA一定不会被回收。</li><li>与GC Root存在直接或间接软引用关系的对象有 ObjectB、ObjcetE，GC时ObjectB与ObjectE可能会被回收。</li><li>与GC Root存在直接或间接弱引用关系的对象有 ObjectC、ObjectF，GC时ObjectC与ObjectF一定会被回收。</li><li>与GC Root存在直接或间接虚引用关系的对象有 ObjectD、ObjectG，GC时ObjectD与ObjectG一定会被回收。</li></ul><h5 id="2-2-ThreadLocal-get、-set、-remove方法"><a href="#2-2-ThreadLocal-get、-set、-remove方法" class="headerlink" title="2.2 ThreadLocal#get、#set、#remove方法"></a>2.2 ThreadLocal#get、#set、#remove方法</h5><p>​    <strong>ThreadLocal#get</strong>整体逻辑相对简单，具体分析见下面代码的注解。当未给<strong>ThreadLocal</strong>设置值时，<strong>get</strong>方法将调用<strong>setInitialValue</strong>方法返回<strong>initialValue</strong>方法指定的<strong>ThreadLocal</strong>的初始值，默认<strong>ThreadLocal</strong>的<strong>initialValue</strong>为null。<strong>ThreadLocal#get</strong>方法实际是用其自身作为Key通过开放寻址法在其所属线程的<strong>ThreadLocalMap</strong>上查找对应的value（与线程绑定的变量）。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//获取当前线程</span>  Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//从线程中获取成员变量ThreadLocalMap，此时ThreadLocalMap可能没被初始化</span>  ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//当前线程成员变量ThreadLocalMap已初始化</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//用this(当前ThreadLocal)为Key从ThreadLocalMap的Entry数组中找到对应的value</span>    ThreadLocalMap<span class="token punctuation">.</span>Entry e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//entry存在直接从其中拿出对应的值，然后返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>      T result <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>      <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">//当前线程成员变量ThreadLocalMap未初始化或者在其Entry数组中未找到对应的value, 设置value值</span>  <span class="token keyword">return</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//设置ThreadLocal初始化值</span><span class="token keyword">private</span> T <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//获取ThreadLocal的初始化值</span>  T value <span class="token operator">=</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//获取当前线程</span>  Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//从线程中获取成员变量ThreadLocalMap，此时ThreadLocalMap可能没被初始化</span>  ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//在ThreadLocalMap上设置当前ThreadLocal对应值</span>    map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">else</span>      <span class="token comment" spellcheck="true">//为当前线程设置成员变量ThreadLocalMap值</span>    <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//为线程成员变量ThreadLocalMap设置值，同时将当前的TheadLocal对的值绑定到ThreadLocalMap上</span><span class="token keyword">void</span> <span class="token function">createMap</span><span class="token punctuation">(</span>Thread t<span class="token punctuation">,</span> T firstValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>  t<span class="token punctuation">.</span>threadLocals <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalMap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> firstValue<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//默认ThreadLocal的initialValue为null，创建ThreadLocal对象时可以覆盖该方法指定初始值</span><span class="token keyword">protected</span> T <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ThreadLocal#set</strong>整体逻辑相对简单，具体分析见下面代码的注解。<strong>ThreadLocal#set</strong>方法实际是用其自身作为Key通过开放寻址法在其所属线程的<strong>ThreadLocalMap</strong>上将value与线程绑定。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//获取当前线程</span>    Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//从线程中获取成员变量ThreadLocalMap，此时ThreadLocalMap可能没被初始化</span>    ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span>          <span class="token comment" spellcheck="true">//在ThreadLocalMap上设置当前ThreadLocal对应值</span>        map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span>          <span class="token comment" spellcheck="true">//为当前线程设置成员变量ThreadLocalMap值</span>        <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ThreadLocal#remove</strong>整体逻辑相对简单，<strong>ThreadLocal#remove</strong>方法实际是用其自身作为Key通过开放寻址法，将当前<strong>ThreadLocal</strong>与其所属线程解绑。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  ThreadLocalMap m <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">!=</span> null<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//将当前ThreadLocal与其对应的线程解绑</span>    m<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2-3-ThreadLocalMap类"><a href="#2-3-ThreadLocalMap类" class="headerlink" title="2.3 ThreadLocalMap类"></a>2.3 ThreadLocalMap类</h5><p>​        从上面的<strong>ThreadLocal#get、#set、#remove</strong>方法分析可以看到，最终这些操作都是在<strong>ThreadLocalMap</strong>上完成。文中最开始已介绍过<strong>ThreadLocalMap</strong>实际是通过<strong>开放地址法</strong>实现的，其内部的<strong>Entry</strong>数据组table用于存储<strong>ThreadLocal</strong>与保存在<strong>ThreadLocal</strong>的值，最终实现<strong>ThreadLocal</strong>内保存的值与线程绑定。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// map的初始容量</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Entry数组</span>  <span class="token keyword">private</span> Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// Entry元素个数</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 阈值，用于扩容降低开放寻址时的冲突</span>  <span class="token keyword">private</span> <span class="token keyword">int</span> threshold<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//ThreadLocalMap中的Entry持有ThreadLocal的弱引用。</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ThreadLocal上关联的值</span>  Object value<span class="token punctuation">;</span>  <span class="token function">Entry</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> k<span class="token punctuation">,</span> Object v<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>    value <span class="token operator">=</span> v<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ThreadLocalMap</strong>构造函数</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">//创建ThreadLocalMap并在其上绑定第一个线程局部变量</span><span class="token function">ThreadLocalMap</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> firstKey<span class="token punctuation">,</span> Object firstValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>INITIAL_CAPACITY<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//取模获取引用ThreadLocal的Entry的下标</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> firstKey<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>INITIAL_CAPACITY <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>firstKey<span class="token punctuation">,</span> firstValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//设置扩容的阈值</span>    <span class="token function">setThreshold</span><span class="token punctuation">(</span>INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ThreadLocalMap#getEntry</strong>方法以<strong>ThreadLocal</strong>作为<strong>Key</strong>从<strong>ThreadLocalMap</strong>采用<strong>开放寻址法</strong>从<strong>Entry</strong>数组中寻找引用<strong>ThreadLocal</strong>对应的<strong>Entry</strong>。<strong>ThreadLocal#get</strong>方法会调用该方法，获取保存在Entry内的Value，即<strong>实际与当前线程绑定的变量值</strong>。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> Entry <span class="token function">getEntry</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//取模试探性获取引用ThreadLocal的Entry的下标</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>table<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Entry e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> key<span class="token punctuation">)</span>        <span class="token keyword">return</span> e<span class="token punctuation">;</span>    <span class="token keyword">else</span>          <span class="token comment" spellcheck="true">//发生冲突，采用开放寻址法从Entry数组中找引用ThreadLocal的Entry</span>        <span class="token keyword">return</span> <span class="token function">getEntryAfterMiss</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> i<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//发生冲突，采用开放寻址法从Entry数组中找引用ThreadLocal的Entry</span><span class="token keyword">private</span> Entry <span class="token function">getEntryAfterMiss</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> Entry e<span class="token punctuation">)</span> <span class="token punctuation">{</span>   Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>   <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>   <span class="token keyword">while</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>     ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 找到引用ThreadLocal的Entry返回</span>       <span class="token keyword">return</span> e<span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//找到之前引用ThreadLocal的Entry，但ThreadLocal的引用已被remove方法清理掉或被GC清理掉</span>       <span class="token comment" spellcheck="true">//通过重新哈希，清理已被remove或被GC回收的ThreadLocal上关联的value</span>       <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">else</span> <span class="token comment" spellcheck="true">// 继续向前寻找引用ThreadLocal的Entry</span>       i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>     e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> null<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//开放寻址，获取元素下标</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> len<span class="token punctuation">)</span> <span class="token operator">?</span> i <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ThreadLocalMap#set</strong>方法以<strong>ThreadLocal</strong>作为<strong>Key</strong>采用开放寻址法将value与其所属线程绑定。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> key<span class="token punctuation">,</span> Object value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//取模试探性获取引用ThreadLocal的Entry的下标</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//尝试用开放寻址的方法在Entry数组中找到之前引用ThreadLocal的Entry</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>         e <span class="token operator">!=</span> null<span class="token punctuation">;</span>         e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//找到之前引用ThreadLocal的Entry，重置value值并返回</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>          <span class="token comment" spellcheck="true">//找到之前引用ThreadLocal的Entry，但ThreadLocal的引用已被remove方法清理掉或被GC清理掉</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//重新将引用ThreadLocal的Entry放入到Entry数组中并清理已被remove或被GC回收的ThreadLocal上关联的value</span>            <span class="token function">replaceStaleEntry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">//未找到之前引用ThreadLocal的Entry，创建Entry并放入Entry数组</span>    tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> sz <span class="token operator">=</span> <span class="token operator">++</span>size<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//清理槽位失败且Entry数组长度超过阈值，重新rehash对Entry数组扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">cleanSomeSlots</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> sz<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sz <span class="token operator">>=</span> threshold<span class="token punctuation">)</span>        <span class="token function">rehash</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ThreadLocalMap#remove</strong>方法以<strong>ThreadLocal</strong>作为<strong>Key</strong>采用开放寻址法将value与其所属线程绑定。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>  <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//取模试探性获取引用ThreadLocal的Entry的下标</span>  <span class="token keyword">int</span> i <span class="token operator">=</span> key<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//用开放寻址法找到引用ThreadLocal的Entry，并将其清除</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//清除Entry上的弱引用ThreadLocal</span>      e<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//通过重新哈希，清理已被remove或被GC回收的ThreadLocal上关联的value</span>      <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>ThreadLocalMap#getEntry、#set、#remove</strong>方法内部最终都会尝试调用<strong>expungeStaleEntry</strong>方法。</p><p><strong>expungeStaleEntry</strong>通过重新哈希，清理已被remove或被<strong>GC</strong>回收的<strong>ThreadLocal</strong>上关联的value， 该方法可以保证由于只与Entry存在弱引用关系的<strong>ThreadLocal</strong>被<strong>GC</strong>回收后，Entry上的Value（与<strong>ThreadLocal</strong>上关联的value）能被及时清理，而<strong>不会因为Entry上的Value一直存在强引用最终导致的内存泄漏</strong>。实际<strong>ThreadLocal#set、#get、#remove</strong>方法最终都会调用<strong>expungeStaleEntry</strong>方法。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 通过重新哈希，清理已被remove或被GC回收的ThreadLocal上关联的value</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">expungeStaleEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> staleSlot<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> tab <span class="token operator">=</span> table<span class="token punctuation">;</span>  <span class="token keyword">int</span> len <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 清理当前位置上已被remove或被GC回收的ThreadLocal上关联的value</span>  tab<span class="token punctuation">[</span>staleSlot<span class="token punctuation">]</span><span class="token punctuation">.</span>value <span class="token operator">=</span> null<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 清理当前位置上的Entry</span>  tab<span class="token punctuation">[</span>staleSlot<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>  size<span class="token operator">--</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 向后重新哈希，直到对应位置上没有Entry。</span>  Entry e<span class="token punctuation">;</span>  <span class="token keyword">int</span> i<span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>staleSlot<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">;</span>i <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> k <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//清理当前位置上已被remove或被GC回收的ThreadLocal上关联的value</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>      e<span class="token punctuation">.</span>value <span class="token operator">=</span> null<span class="token punctuation">;</span>      tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>      size<span class="token operator">--</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//用开放寻址法，重新调整当前Entry在数组中的位置</span>      <span class="token keyword">int</span> h <span class="token operator">=</span> k<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//ThreadLocal初始位置h与i不一致，尝试将其放回始位置或开放寻址法后的位置</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>tab<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>                h <span class="token operator">=</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        tab<span class="token punctuation">[</span>h<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-使用场景"><a href="#3-使用场景" class="headerlink" title="3 使用场景"></a>3 使用场景</h4><p>​        本文开篇已介绍过，<strong>ThreadLocal</strong>适用方法调用链上参数的透传，但要注意是同线程间，但不适合异步方法调用的场景。对于异步方法调用，想做参数的透传可以采用阿里开源的<strong>TransmittableThreadLocal</strong>。权限、日志、事务等框架都可以利用<strong>ThreadLocal</strong>透传重要参数。</p><p>​        在使用<strong>Spring Security</strong>时，当用户认证通过后，业务逻辑处理中经常会去获取用户认证时的用户信息，通过会将这个功能封装在工具类中，如下的<strong>SecurityUtils#getAuthUser</strong>方法用于获取用户的认证信息，如果用户认证过返回用户信息，否则返回null。业务逻辑中直接通过<strong>SecurityUtils#getAuthUser</strong>方法便能方便的获取用户的认证信息。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SecurityUtils</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> User <span class="token function">getAuthUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 通过Srping Security 上下文获取用户的认证信息</span>      Authentication auth <span class="token operator">=</span> SecurityContextHolder<span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAuthentication</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span>  Objects<span class="token punctuation">.</span><span class="token function">nonNull</span><span class="token punctuation">(</span>auth<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>User<span class="token punctuation">)</span> auth<span class="token punctuation">.</span><span class="token function">getPrincipal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>      log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Get user auth info fail"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">CustomException</span><span class="token punctuation">(</span><span class="token string">"获取用户信息异常"</span><span class="token punctuation">,</span> HttpStatus<span class="token punctuation">.</span>UNAUTHORIZED<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>SecurityContextHolder</strong>采用策略模式实现，实默认策略便是通过ThreadLocal存储Spring Security的上下文信息，这个上下文信息中包括认证信息。<strong>ThreadLocalSecurityContextHolderStrategy</strong>源码如下。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalSecurityContextHolderStrategy</span> <span class="token keyword">implements</span> <span class="token class-name">SecurityContextHolderStrategy</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//采用ThreadLocal存储线程上下文信息</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> ThreadLocal<span class="token operator">&lt;</span>SecurityContext<span class="token operator">></span> contextHolder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clearContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        contextHolder<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> SecurityContext <span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//从ThreadLocal获取线程上下文信息</span>        SecurityContext ctx <span class="token operator">=</span> contextHolder<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>ctx <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ctx <span class="token operator">=</span> <span class="token function">createEmptyContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            contextHolder<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>ctx<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ctx<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setContext</span><span class="token punctuation">(</span>SecurityContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Assert<span class="token punctuation">.</span><span class="token function">notNull</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> <span class="token string">"Only non-null SecurityContext instances are permitted"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        contextHolder<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-内存泄漏问题分析"><a href="#4-内存泄漏问题分析" class="headerlink" title="4 内存泄漏问题分析"></a>4 内存泄漏问题分析</h4><h5 id="4-1-内存漏泄示例"><a href="#4-1-内存漏泄示例" class="headerlink" title="4.1 内存漏泄示例"></a>4.1 内存漏泄示例</h5><p>下面通过代码模拟ThreadLocal内存漏泄，注意运行指定的VM参数 -Xms大于50MB。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalOOM</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>    ThreadLocal tl <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CustomThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    tl<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Value50MB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//清理 CustomThreadLocal 对象的强引用</span>    tl <span class="token operator">=</span> null<span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Call System.gc method to trigger Full GC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span><span class="token function">gc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//GC线程优先级较低，休眠3秒确保Full GC已完成</span>    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">CustomThreadLocal</span> <span class="token keyword">extends</span> <span class="token class-name">ThreadLocal</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// Full GC 如果对象被回收，该方法会被调用</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"CustomThreadLocal 1 MB finalized."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Value50MB</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">1024</span> <span class="token operator">*</span> <span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// Full GC 如果对象被回收，该方法会被调用</span>      System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Value50MB 50 MB finalized."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>控制台输出：</p><blockquote><p><strong>Call System.gc method to trigger Full GC</strong><br><strong>My threadLocal 1 MB finalized.</strong></p></blockquote><p>​        从上面的输出可以知道，发生<strong>Full GC</strong>后<strong>CustomThreadLocal</strong> 对象对应的<strong>1MB</strong>内存被回收，但其上面关联的值<strong>Value50MB</strong>对应的<strong>50MB</strong>内存并没有被<strong>GC</strong>回收，出现了<strong>内存漏泄</strong>。如果应用中存在大量的这类<strong>ThreadLocal</strong>关联的值没被<strong>GC</strong>回收到，内存不断漏泄，最终将导致应用程序整体<strong>OOM</strong>，程序崩溃。</p><p><strong>4.2 原因分析</strong></p><p>​        在第2节部分源码分析中，已知道实际<strong>ThreadLocal</strong>与其保存的值都是被放在<strong>ThreadLocalMap</strong>内部<strong>Entry</strong>对应的实例上。而<strong>Entry</strong>持有<strong>ThreadLocal</strong>的弱引用，当<strong>ThreadLocal</strong>只被<strong>Entry</strong>引用时，<strong>ThreadLocal</strong>对象将在<strong>GC</strong>时被无条件的回收掉。</p><p>​        上面<strong>ThreadLocal</strong>内存漏泄的示例中，强弱引用关系如下。</p><p><strong>强引用：</strong></p><ul><li>**ThreadLocalRef  =&gt;ThreadLocal **</li><li><strong>ThreadRef  =&gt; Thread  =&gt; ThreadLocalMap =&gt; Entry数组 =&gt; Entry =&gt; Value50MB</strong></li></ul><p><strong>弱引用：</strong></p><ul><li>**Entry =&gt; ThreadLocal **</li></ul><p><img src="https://gitee.com/0909/blog/raw/master/img/20211027153948.png"></p><pre><code> tl = null;</code></pre><p>执行 t1 = null后，强弱引用关系如下。</p><p><strong>强引用：</strong></p><ul><li><strong>ThreadRef  =&gt; Thread  =&gt; ThreadLocalMap =&gt; Entry数组 =&gt; Entry =&gt; Value50MB</strong></li></ul><p><strong>弱引用：</strong></p><ul><li>**Entry =&gt; ThreadLocal **</li></ul><p><img src="https://gitee.com/0909/blog/raw/master/img/20211027154315.png"></p><p><strong>GC</strong>时发现 <strong>TheadLocal</strong>上只存在 <strong>Entry</strong>对其的弱引用，于是无条件将<strong>ThreadLocal</strong>对应的内存回收，示例中是<strong>CustomThreadLocal</strong>对应的<strong>1M</strong>内存。</p><p><strong>4.3  如何避内存漏泄</strong></p><p>​        从第2节中的源码分析中已知道，<strong>ThreadLocal#remove</strong>方法实际会调用<strong>ThreadLocalMap#expungeStaleEntry <strong>方法，达到将已被</strong>GC</strong>回收的<strong>ThreadLocal</strong>上关联的Value的强引断开，避免内存泄漏。所以在每次使用完<strong>ThreadLocal</strong>后，只要调用其对应的<strong>remove</strong>方法，就可以避内存漏泄。</p><h5 id="4-4-为什么Entry不强引用ThreadLocal"><a href="#4-4-为什么Entry不强引用ThreadLocal" class="headerlink" title="4.4 为什么Entry不强引用ThreadLocal"></a>4.4 为什么Entry不强引用ThreadLocal</h5><p><strong>ThreadLocalMap</strong>源码上的注解</p><blockquote><p>To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys. However, since reference queues are not used, stale entries are guaranteed to be removed only when the table starts running out of space.</p></blockquote><p>可以看到主要是为了避免大的<strong>ThreadLocal</strong>与长时间存活的使用场景。如果不采用<strong>Entry</strong>弱引用<strong>ThreadLocal</strong>，<strong>ThreadLocal</strong>将一直与<strong>Thread</strong>共存，这更加容易引起内存漏泄。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​        本文首先对ThreadLocal做出了整体的概述，简要地说明其使用场景、不足、业界的改进方案。然后对<strong>ThreaLocal</strong>的源码进行了详细地分析，接着介绍了其具体的使用场景、日常使用中可能会遇到的问题与问题的解决方案。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://github.com/alibaba/transmittable-thread-local">TransimittableThreadLocal</a></p><p><a href="https://mp.weixin.qq.com/s/8f29ZfGvZVPe0bO-FahokQ">Java Reference核心原理分析</a></p><h4 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h4><p>​        原创不易，点赞、在看、转发是对我莫大的鼓励，关注公众号洞悉源码是对我最大的支持。同时相信我会分享更多干货，我同你一起成长，我同你一起进步。</p>]]></content>
      
      
      <categories>
          
          <category> JDK源码 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JDK源码 </tag>
            
            <tag> ThreadLocal </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解分布式事务之可靠消息最终一致性</title>
      <link href="/2021/10/19/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8B%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/"/>
      <url>/2021/10/19/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E4%B9%8B%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E6%9C%80%E7%BB%88%E4%B8%80%E8%87%B4%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="一文详解分布式事务之基于消息投递与消费的最终一致性"><a href="#一文详解分布式事务之基于消息投递与消费的最终一致性" class="headerlink" title="一文详解分布式事务之基于消息投递与消费的最终一致性"></a>一文详解分布式事务之基于消息投递与消费的最终一致性</h3><h4 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h4><p>​        微服务架构中，服务的细分，导致原来在单一服务中的模块拆分为多个服务，同时数据存储也从单一的数据源，变为按服务划分的多数据源。单一服务单数据源时，可以通过数据库本身的<strong>ACID机制</strong>（<strong>Atomicity 原子性</strong>、<strong>Consistency 一致性</strong>、<strong>Isolation 隔离性</strong>、<strong>Durability 持久性</strong>）保证业务数据的一致性（通常称作<strong>本地事务</strong>），微服务架构下通常采用<strong>BASE机制</strong>（<strong>Basically Available 基本可用</strong>、**Soft State 软状态 <strong>、</strong>Eventual Consistency 最终一致性 **）来保证系统间数据的最终一致性。</p><p>​        分布式事务通常可采用<strong>2PC</strong>、<strong>3PC</strong>、<strong>TCC</strong>、<strong>SAGA</strong>、<strong>最大努力通知</strong>与本文将要介绍的<strong>基于消息投递与消费的最终一致性</strong>实现。2PC 与 3PC 依赖于数据库的事务能力，在一阶段开始事务后不进提交会严重影响应用程序的并发性能 ，实际业务中基本不会采用。TCC 相于2PC与3PC而言并发性能更高，是一种柔性事务，但要求业务侵入性较大且实现复杂，要求业务侧实现<strong>Try、Cancel、Confirm</strong>方法，同时为了解决网络通信失败或超时带来的异常情况，要求业务方在设计实现要<strong>允许空回滚、操作幂等性、防止资源悬挂</strong>，其比较适合数据一致性要求较高的业务场景，如组合支付，订单减库存。SAGA 其支持的并发性相对TCC而言更高，业务侵入性较低，适合长事务的业务场景。</p><h4 id="2-基于消息投递与消费的最终一致性"><a href="#2-基于消息投递与消费的最终一致性" class="headerlink" title="2  基于消息投递与消费的最终一致性"></a>2  基于消息投递与消费的最终一致性</h4><p>​            <strong>基于消息投递与消费的最终一致性</strong>  这类实现方案可以细分为<strong>本地消息表、可靠消息服务、事务消息（可靠消息服务的特例）</strong>，由于这些方案本质上都是<strong>将跨系统的业务操作变成可靠的消息投递与消费，达到将分布式事务拆分为多个本地事务的目地，实现系统间数据的最终一致性</strong>，就将这类方案统称为<strong>基于消息投递与消费的最终一致性</strong>。</p><h5 id="2-1-本地消息表"><a href="#2-1-本地消息表" class="headerlink" title="2.1 本地消息表"></a>2.1 本地消息表</h5><p>​        本地消息表该方案，由 eBay 的系统架构师 Dan Pritchett 在 2008 年在 ACM 发表的论文《<a href="https://queue.acm.org/detail.cfm?id=1394128">Base: An Acid Alternative</a>》中提出的，BASE机制也是他在该论文中提出的。先看一下直接用本地事务能否保证系统间数据的最终一致性。</p><p>​        以常见的电商平台，用户购买商品创建订单为例，订单系统在创建订单时，通常会采用预扣减库存的方式来避免超售，用户支付成功后再真正扣减库存，对于配置时间内超时未支付的订单，会将预扣减的库存归还。为了提高订单创建的效率，将订单系统中订单生成与预扣减库存二者异步解耦，即订单系统内生成订单再向MQ投递预扣减库存的消息。</p><img src="https://gitee.com/0909/blog/raw/master/img/20211021171244.png" style="zoom:80%;" /><p>订单系统内部分为4步，分别是</p><ul><li><p><strong>用户ID加锁防止用户重复下单</strong></p><p>通常会指定锁的自动释放时间，如1秒正常情况用户1秒内不可能真正下多单，这种情况更多是由于重复下单导致的，出现这种情况直接返回请误重复下单。</p></li><li><p><strong>Lua脚本校验库存预扣库存</strong></p><p>这一步主要是在缓存中校验与预扣库存</p></li><li><p><strong>创建订单</strong></p><p>真正创建业务订单</p></li><li><p><strong>投递订单创建消息</strong></p><p>订单系统向MQ投递订单创建消息</p></li></ul><p>​       讨论分布式事务时，我们将<strong>用户ID加锁防止用户重复下单</strong> 与 <strong>Lua脚本校验库存预扣库存</strong>这两步直接跳过，只关心与事务相关的 <strong>创建订单</strong> 与 <strong>投递订单创建消息</strong> 。</p><p>​        <font color ='red'> <strong>常见的错误作法有下面两种:</strong> </font></p><ul><li><font color = 'red'><strong>在本地事务中先创建订单，后投递订单创建消息</strong> </font></li></ul><pre class="line-numbers language-java"><code class="language-java">本地事务开始<span class="token number">1</span><span class="token punctuation">.</span> 创建订单<span class="token number">2</span><span class="token punctuation">.</span> 投递订单创建消息本地事务结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这种作法存在的问题如下，第二步<strong>投递订单创建消息</strong>由于网络抖动出现超时，整个本地事务回滚，此时业务订单创建回滚，但订单创建的消息可能已投递到MQ中，最终导致商品库存被错误的预扣。</p><ul><li><font color = 'red'><strong>在本地事务中先投递订单创建消息，后创建订单</strong> </font></li></ul><pre class="line-numbers language-java"><code class="language-java">本地事务开始<span class="token number">1</span><span class="token punctuation">.</span> 投递订单创建消息<span class="token number">2</span><span class="token punctuation">.</span> 创建订单本地事务结束<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这种作法同样存在，<strong>投递订单创建消息</strong>由于网络抖动出现超时，整个本地事务回滚，此时业务订单未创建，但订单创建的消息可能已投递到MQ中，最终导致商品库存被错误的预扣。</p><p>​        <strong>那如何保证创建订单与投递订单创建消息要么一起成功，要么一起失败？</strong> 本地消息就是解决该问题，其做法如下：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token number">1</span>、上游系统在本地事务中新增或更新业务记录，同时新增本地消息记录，消息状态为待发送<span class="token number">2</span>、上游系统中定时任务扫描本地消息表中状态为待发送的记录，将该记录投递到MQ中，MQ返回成功再更新本地消息表的状态为已发送<span class="token number">3</span>、MQ推送消息供下游系统消费<span class="token number">4</span>、下游系统消费MQ推着的消息，执行业务逻辑，返回ACK给MQ<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><img src="https://gitee.com/0909/blog/raw/master/img/20211022113826.png" style="zoom:80%;" /><p>​    <strong>注意：第2步可能出现定时任务向MQ投递重复消息的情况，第3步可能出现MQ重复推送消息的情况，所以下游在做业务处理时一定要通过一定机制保证操作的幂等性，像上面的例子不能出现重复消费创建订单消息而导致多次预扣减库存的情况，业务操作的幂等性可以参考之前的文章 <a href="https://mp.weixin.qq.com/s/3A0hFpfxPinIq2trvCkvOw">分布式系统下面业务操作幂等的必要性</a>。</strong></p><img src="https://gitee.com/0909/blog/raw/master/img/20211022124420.png" style="zoom:80%;" /><p>​    本地消息表方案增加了业务系统维护消息表的成本使得事务处理部分与业务系统耦合，不能成为通用的解决方案，高并发时本地消息表的读写操作会成为系统的瓶颈，同时定时任务扫描本地消息表会增加系统之间的延时。</p><h5 id="2-2-可靠消息最终一致性"><a href="#2-2-可靠消息最终一致性" class="headerlink" title="2.2 可靠消息最终一致性"></a>2.2 可靠消息最终一致性</h5><p>​        本地消息表方案对业务的侵入性很大，不合适作为通用的解决方案。通过将本地消息的处理，转由单独的服务去完成，可以得到通用的<strong>可靠消息最终一致性</strong>解决方案。</p><p>​        <strong>可靠消息最终一致性</strong>方案由<strong>上游服务、可靠消息服务、下游服务</strong>组成。</p><p><strong>可靠消息服务</strong></p><p>​        可靠消息服务专门负责存储消息、投递消息、更新消息状态的独立服务。消息一般由<strong>待确认、已发送、已取消、已完成</strong>组成。</p><ul><li><p><strong>待确认</strong></p><p>上游服务发送给可靠消息服务的待确认消息，上游服务在执行完本地事务的业务逻辑，后会对该消息进行确认或取消</p></li><li><p><strong>已发送</strong></p><p>上游服务本地事务执行成功，后会向可靠消息服务发送确认消息，可靠消息服务收到消息后，将消息状态由待确认更新为已发送</p></li><li><p><strong>已取消</strong> </p><p>上游服务本地事务执行失败，后会向可靠消息服务发送取消消息，可靠消息服务收到消息后，将消息状态由待确认更新为已取消</p></li><li><p><strong>已完成</strong></p><p>下游服务消费完MQ中的消息完后，会向MQ投递已完成消费消息，可靠消息服务消费该消息，将消息状态由已发送更新为已完成</p></li></ul><p><strong>上游服务</strong></p><p>上游服务，主动发起事务的一方，一般是指分布式事务中最先开始执行的那个服务。其在需要调用下游服务时，不直接通过RPC之类的方式调用，而是先生成一条消息，具体步骤如下：</p><ul><li>上游服务执行业务逻辑前，先发送一条待确认消息（一般称为half-msg，包含接口调用信息）给可靠消息服务，可靠消息服务会将这条记录存储到自己的数据库（或本地磁盘）状态为【<strong>待确认</strong>】（<strong>下图中第1步与第2步</strong>）。</li><li>上游服务在本地事务中执行业务逻辑，如果本地事务执行成功，侧可靠消息服务发送一条确认消息；如果本地执行失败，则向消息服务发送一条取消消息 （<strong>下图中第3步与第4步</strong>）。</li><li>可靠消息服务，根据收到消息为确认消息或取消消息，修改本地数据库对应消息记录的状态为【<strong>已发送</strong>】或【<strong>已取消</strong>】。如果是确认消息，同时还要将消息投递到MQ消息队列中，<strong>修改消息状态和投递MQ必须在一个事务里，保证要么都成功要么都失败</strong>（<strong>下图中第 5.1 步与第5.2步</strong>）。</li></ul><p><img src="https://gitee.com/0909/blog/raw/master/img/20211022165646.png"></p><p><strong>注意：</strong>为了防止出现生产者的本地事务执行成功，但是发送<strong>确认/取消</strong>消息超时的情况。可靠消息服务，内部一般会提供一个后台定时任务，不停的扫描消息表中消息状态为【<strong>待确认</strong>】的消息，然后回调上游服务的一个接口，由上游服务决定该消息应该确认还是取消，并发送对应消息。</p><p><strong>下游服务</strong></p><p>下游服务，订阅MQ消息，收到MQ的消息后执行本地事务。执行成功后会对消息进行ACK确认，同时会向MQ投递已完成消费的消息，可靠消息服务收到该消息后会更新消息表中的消息状态为【<strong>已完成</strong>】，然后再对消息进行ACK确认。</p><p>下游服务，订阅MQ消息，收到MQ的消息后执行对应的业务逻辑。 </p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211022165518.png"></p><p><strong>注意：</strong> 为了防止重复消息消费，下游服务业务逻辑处理要保证幂等。同时第8、第9步、每10步都可能由于系统或网络原因出现异常。第8失败，消息会再次推送（主流的MQ都会保障消息至少投递一次），下游服务业务逻辑处理要保证幂等。第9步失败，则要通过可靠消息服务中的定时任务对扫描已超时的【<strong>已发送</strong>】消息，并重新向MQ投递消息。第10步失败，同样消息会再次推送，若消息表中消息状态为【<strong>已完成</strong>】则直接再次ACK消息就好。<strong>业务操作的幂等性可以参考之前的文章 <a href="https://mp.weixin.qq.com/s/3A0hFpfxPinIq2trvCkvOw">分布式系统下面业务操作幂等的必要性</a>。</strong></p><h5 id="2-3-事务消息"><a href="#2-3-事务消息" class="headerlink" title="2.3 事务消息"></a>2.3 事务消息</h5><p>​        事务消息，该方案也叫可靠消息最终一致性，很多开源的消息中间件都支持分布式事务，比如RocketMQ、Kafka。其核心其思想和本地消息表、可靠消息服务是一样的，只不过是将可靠消息服务和MQ功能封装在一起，屏蔽了底层细节，从而更方便用户的使用。</p><p>​        RocketMQ在4.3.0已经支持分布式事务消息，这里RocketMQ采用了2PC的思想来实现了提交事务消息，同时增加一个补偿逻辑来处理二阶段超时或者失败的消息，如下图所示。</p><p><img src="https://gitee.com/0909/blog/raw/master/img/20211022224637.png"></p><p>上图说明了事务消息的大致方案，其中分为两个流程：<strong>正常事务消息的发送及提交</strong>、<strong>事务消息的补偿流程</strong>。</p><ul><li><strong>事务消息发送及提交</strong></li></ul><p>(1) 上游服务向MQ Server 发送half消息。</p><p>(2) MQ Server 服务端响应消息写入结果 (此时half消息对下游消息订阅者不可见)。</p><p>(3) 上游服务根据发送结果执行本地事务（如果写入失败，此时half消息对业务不可见，本地逻辑不执行）。</p><p>(4) 上游服务根据本地事务状态执行Commit或者Rollback（Commit操作生成消息索引，消息对消费者可见）</p><ul><li><strong>补偿流程</strong></li></ul><p>(5) 对没有Commit/Rollback的事务消息（pending状态的消息），MQ Server向上游服务发起一次“回查”</p><p>(6) 上游服务收到回查消息，检查回查消息对应的本地事务的状态</p><p>(7) 上游服务根据本地事务状态，重新Commit或者Rollback</p><p>其中，补偿阶段用于解决消息Commit或者Rollback发生超时或者失败的情况。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​        本文总结了基于消息投递与消费的最终一致性实现分布式事务的主要方案本地消息表、可靠消息服务、事务消息，这些方案本质上都是<strong>将跨系统的业务操作变成可靠的消息投递与消费，达到将分布式事务拆分为多个本地事务的目地，实现系统间数据的最终一致性</strong>。</p><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://mp.weixin.qq.com/s/s20KWuG88LGgWTShcUKJgg">分布式理论之分布式事务：可靠消息最终一致性方案</a></p><p><a href="https://github.com/apache/rocketmq/blob/master/docs/cn/design.md#5-%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF">RocketMQ 事务消息设计</a></p><h4 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h4><p>​        原创不易，点赞、在看、转发是对我莫大的鼓励，关注公众号洞悉源码是对我最大支持。同时相信我会分享更多干货，我同你一起成长，我同你一起进步。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式事务 </tag>
            
            <tag> BASE </tag>
            
            <tag> CAP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解mysql InnoDB存储引擎中的锁</title>
      <link href="/2021/10/13/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3mysql%20InnoDB%20%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E9%94%81/"/>
      <url>/2021/10/13/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3mysql%20InnoDB%20%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h3 id="一文详解mysql-InnoDB存储引擎中的锁"><a href="#一文详解mysql-InnoDB存储引擎中的锁" class="headerlink" title="一文详解mysql InnoDB存储引擎中的锁"></a>一文详解mysql InnoDB存储引擎中的锁</h3><h4 id="1-InnoDB-存储引擎锁分类"><a href="#1-InnoDB-存储引擎锁分类" class="headerlink" title="1 InnoDB 存储引擎锁分类"></a>1 InnoDB 存储引擎锁分类</h4><p>​        mysql官网上介绍了InnoDB中7种所 **<code>Shared and Exclusive Locks</code><strong>（共享与排他锁）、</strong><code>Intention Locks</code><strong>（意向锁）、</strong><code>Record Locks</code><strong>（记录锁）、</strong><code>Gap Locks</code><strong>（间隙锁）、</strong><code>Next-Key Locks</code><strong>（临键锁） 、</strong><code>Insert Intention Locks</code><strong>（插入意向锁）、</strong><code>AUTO-INC Locks</code> **（自增锁），这7种配合MVCC机制，使得mysql在高并发的读写业务场景上有较好的表现。</p><p>​        mysql InnoDB 支持不同粒度的锁，如表锁与行锁，同时支持表锁与行锁的共存。为更高效地支持不同粒度的锁，而引入<strong>Intention Locks</strong>（意向锁）。<strong>Shared and Exclusive Locks</strong>（共享与排他锁）主要是为了提高加行锁时读写的并发性。<strong>Record Locks</strong>（记录锁）用于控制带索引记录的操作性能。<strong>Gap Locks</strong>（间隙锁）+ <strong>Next-Key Locks</strong>（临键锁）避免<strong>Repeatable Read</strong>级别下面出现幻读。<strong>Intention Locks</strong>（插入意向锁）保证多个事务，在同一个索引，同一个范围区间插入记录时，如果插入的位置不冲突，不会阻塞彼此。<strong>AUTO-INC Locks</strong> （自增锁）保证同一事务中利用数据库自增ID插入数据时ID的连续性。</p><h4 id="2-Shared-and-Exclusive-Locks（共享与排他锁）"><a href="#2-Shared-and-Exclusive-Locks（共享与排他锁）" class="headerlink" title="2 Shared and Exclusive Locks（共享与排他锁）"></a>2 Shared and Exclusive Locks（共享与排他锁）</h4><p>​        InnoDB内实现了标准的行锁，其中包括两类锁<strong>Shared Locks (共享锁 S)</strong> 与 <strong>Exclusive Locks （排他锁 X）</strong>。</p><ul><li><strong>Shared Locks (共享锁 S) 允许获取锁的事务读取数据。</strong></li><li><strong>Exclusive Locks （排他锁 X）允许获取锁的事务修改、删除数据。</strong></li></ul><h5 id="2-1-共享锁-S-与-排他锁-X兼容互斥性"><a href="#2-1-共享锁-S-与-排他锁-X兼容互斥性" class="headerlink" title="2.1 共享锁 S 与 排他锁 X兼容互斥性"></a>2.1 共享锁 S 与 排他锁 X兼容互斥性</h5><pre><code>     如果事务A获取数据行Data上的共享锁 S，其他事务也可以获取数据行Data上的共享锁 S。如果事务A获取数据行Data上的排他锁 X，则其他事务不能获取数据行Data上的排他锁 X，同样也不能获取数据行Data上的共享锁 S，必须待到事务A**释放**数据行Data上的排他锁 X。共享锁 S与排他锁 X之间的兼容互斥性如下图。</code></pre><img src="https://gitee.com/0909/blog/raw/master/img/SX锁兼容性.png" style="zoom:80%;" /><h5 id="2-2-共享锁-S-与-排他锁-X兼容互斥性示例"><a href="#2-2-共享锁-S-与-排他锁-X兼容互斥性示例" class="headerlink" title="2.2 共享锁 S 与 排他锁 X兼容互斥性示例"></a>2.2 共享锁 S 与 排他锁 X兼容互斥性示例</h5><p>​        下面看一下在user表上，共享锁 S 与 排他锁 X兼容互斥性示例。user表中user_id 为<strong>primary key</strong>。</p><p><strong>一、Session1加共享锁S</strong></p><p>​        在Session1中 执行 select * from user where user_id = 1 lock in share mode 语句，此时user_id = 1 的行上加了<strong>共享锁 S</strong>。由于user_id的行上没有其他锁，查询结果如下。</p><img src="https://gitee.com/0909/blog/raw/master/img/20211014100110.png" style="zoom:80%;" /><p><strong>二、Session2再加共享锁s（可再次读取数据）</strong></p><p>​        在Session2中 执行 select * from user where user_id = 1 lock in share mode 语句，此时上面的Session1已加共享锁，由于<strong>共享锁S之间兼容</strong>可再次在user_id = 1 的行上加<strong>共享锁 S</strong>。Session2查询结果如下。</p><img src="https://gitee.com/0909/blog/raw/master/img/20211014100017.png" style="zoom:80%;" /><p><strong>三、Session3再加排他锁X（出现锁等待超时）</strong></p><p>​        在Session3中 执行 select * from user where user_id = 1 for upate 语句，此时user_id = 1 的行已被上次两个Session加<strong>共享锁 S</strong>。由于<strong>共享锁S与之排他锁X之间互斥</strong>，Session3要等待user_id = 1 的行上<strong>共享锁 S</strong>  释放才能获取结果，否则出现<strong>锁等待超时</strong>，查询结果如下。</p><img src="https://gitee.com/0909/blog/raw/master/img/20211014100211.png" style="zoom:80%;" /><p>​        共享锁 S 与 排他锁 X兼容互斥性其他情况不一一分析了。</p><h4 id="3-Intention-Locks（意向锁）"><a href="#3-Intention-Locks（意向锁）" class="headerlink" title="3 Intention Locks（意向锁）"></a>3 Intention Locks（意向锁）</h4><p>​        意向锁，表示未来的某个时刻，事务可能要加共享/排它锁了，先提前声明一个意向。InnoDB 支持**<code>多粒度锁（multiple granularity locking）</code><strong>，他允许</strong><code>行级锁</code><strong>与</strong><code>表级锁</code><strong>共存，为更高效地支持不同粒度的锁，而引入</strong>Intention Locks（意向锁）<strong>，而实际是一种</strong><code>表锁</code><strong>。Intention Locks（意向锁）分为</strong>意向共享锁（intention shared lock, IS）** 与<strong>意向排他锁（intention exclusive lock, IX）</strong>两种。</p><ul><li><p><strong>意向共享锁</strong>（intention shared lock, IS）：事务有意向对表中的某些行加<strong>共享锁</strong>（S锁）</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 事务要获取某些行的 S 锁，必须先获得表的 IS 锁。</span><span class="token keyword">SELECT</span> <span class="token keyword">column</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">LOCK</span> <span class="token operator">IN</span> <span class="token keyword">SHARE MODE</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p><strong>意向排他锁</strong>（intention exclusive lock, IX）：事务有意向对表中的某些行加<strong>排他锁</strong>（X锁）</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">-- 事务要获取某些行的 X 锁，必须先获得表的 IX 锁。</span><span class="token keyword">SELECT</span> <span class="token keyword">column</span> <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ul><p>意向锁是一种比较弱的锁，他们之间相互兼容</p><img src="https://gitee.com/0909/blog/raw/master/img/IS与IX兼容性.png" style="zoom:80%;" /><p><strong>注意：</strong> 意向锁是一种与<em>行锁不冲突</em> 的表锁，意向锁是用来提高表级加锁判断效率的，看完下面<strong>意向锁解决的问题</strong>便会明白。重要的事重复三遍</p><p><strong>意向锁不会与行级的共享 / 排他锁互斥</strong></p><p><strong>意向锁不会与行级的共享 / 排他锁互斥</strong></p><p><strong>意向锁不会与行级的共享 / 排他锁互斥</strong></p><h5 id="3-1-意向锁解决的问题"><a href="#3-1-意向锁解决的问题" class="headerlink" title="3.1 意向锁解决的问题"></a>3.1 意向锁解决的问题</h5><p>​        来看看如果没有意向锁时，一个事务想向表加表锁的整体处理流程。假设事务想向表加共享锁比如执行如下操作，</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">LOCK</span> <span class="token keyword">TABLES</span> <span class="token keyword">user</span> <span class="token keyword">READ</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>由于共享锁S与排他锁X互斥，所以当前事务试图为表加共享锁时，必须保证：</p><ul><li>当前没有其他事务持有user表的排他锁。</li><li>当前没有其他事务持有user表中任意一行的排他锁。</li></ul><p>所以当前事务在试图对表加共享锁前，会去检测上面的两个条件是否满足，即要检测user表每一行是否加了排他锁，没有意向锁时只能一行一行的检测，这种作法必然效率低下。<strong>意向锁是如何解决这种检测效率低下的问题的呢？</strong></p><p>​        上面已说到过事务要获取某些行的 S 锁，必须先获得表的 IS 锁，事务要获取某些行的 X 锁，必须先获得表的 IX 锁。同样事务想对表加共享锁，必须先获得表的 IS 锁，事务想对表加排他锁，必须先获得表的 IX 锁。这样事务试图对表加共享锁时，只要检测表上有没有已加 IX 锁就行，而不用一行行去检测表中所有记录存没存在加行排他锁（只要表中某一行要加行排他锁，必然要先加IX 锁），如果表上已加IX锁，事务试图对表加共享锁的事务将被阻塞。</p><h5 id="3-2-S锁-X锁-IS锁-IX锁之间的兼容互斥性"><a href="#3-2-S锁-X锁-IS锁-IX锁之间的兼容互斥性" class="headerlink" title="3.2 S锁 X锁 IS锁 IX锁之间的兼容互斥性"></a>3.2 S锁 X锁 IS锁 IX锁之间的兼容互斥性</h5><p>​        前面已了解S锁与X锁，IS锁与 IX锁之间的兼容互斥性，现在看一下S锁 X锁 IS锁 IX锁之间的兼容互斥性。意向锁之间互相兼容。</p><img src="https://gitee.com/0909/blog/raw/master/img/锁兼容性.png" style="zoom:80%;" /><p>注意：上面所说的S锁与X锁是针对于表锁，而不是行锁，意向锁只针对表，不针对行进行锁定，意向锁是用来提高表级加锁判断效率的，其不会影响多个事务并发对不同的行数据加行排他锁。重要的事再重复三遍</p><p><strong>意向锁不会与行级的共享 / 排他锁互斥</strong></p><p><strong>意向锁不会与行级的共享 / 排他锁互斥</strong></p><p><strong>意向锁不会与行级的共享 / 排他锁互斥</strong></p><h5 id="3-3-示例分析"><a href="#3-3-示例分析" class="headerlink" title="3.3 示例分析"></a>3.3 示例分析</h5><p><strong>一、事务 A 先获取了<code>user</code>表 (user_id为主键)某一行的排他锁（并未提交）</strong></p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> user_id <span class="token operator">=</span> <span class="token number">1</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1、事务A会先获取了 <code>user</code> 表上的<strong>意向排他锁（IX）</strong>。</p><p>2、事务A会先获取了 <code>user</code> 表中，user_id=1对应行上的**排他锁(X)**。</p><p><strong>二、事务B尝试获取user表上的表共享锁（S）</strong></p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">lock</span> <span class="token keyword">tables</span> <span class="token keyword">use</span> <span class="token keyword">read</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1、事务B检测事务A持有use表上的<strong>意向排他锁（IX）</strong>。</p><p>2、事务B对user表加锁请求处理阻塞等待</p><p><strong>三、事务C想获取user表中另一行的排他锁</strong></p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> user_id <span class="token operator">=</span> <span class="token number">7</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>1、事务C申请获取user表上的<strong>意向排他锁（IX）</strong>。</p><p>2、事务C检测到事务A已持有user表的<strong>意向排他锁（IX）</strong>。</p><p>3、因为意向排他锁（IX）之间不互斥，事务C成功获取user表上的<strong>意向排他锁（IX）</strong>。</p><p>4、因为user_id = 7对应行记录上没有排他锁，事务C成功user表上user_id=7的行上对应的<strong>行排它锁</strong>。</p><h4 id="4-Record-Locks（记录锁"><a href="#4-Record-Locks（记录锁" class="headerlink" title="4 Record Locks（记录锁)"></a>4 Record Locks（记录锁)</h4><p>​        Record Locks（记录锁）他锁定索引对应的数据行记录。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> user_id <span class="token operator">=</span> <span class="token number">7</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个词句有保证user表上user_id = 7 的记录被锁定，在当前事务没提交前，其他事务对该记录的当前读操作会被阻塞（当前读具体介绍可见我之的文章<a href="https://mp.weixin.qq.com/s/026g7KHA4ZbjsoIUf9fXNg">一文了解mysql InnDB中MVCC的今世前生</a>）。</p><h4 id="5-Gap-Locks（间隙锁）"><a href="#5-Gap-Locks（间隙锁）" class="headerlink" title="5 Gap Locks（间隙锁）"></a>5 Gap Locks（间隙锁）</h4><p>​        Gap Locks（间隙锁）用于锁定某一区间范围内的记录。它封锁索引记录中的间隔，或者第一条索引记录之前的范围，又或者最后一条索引记录之后的范围。其主要用于<strong>防止其他事务在索引记录中的间隔内部插入数据，而引起的幻读</strong>。对于<strong>读已提交</strong>(Read Committed, RC) 事务隔离级别，Gap Locks会自动失效。</p><h5 id="5-1-数据锁定范围分析"><a href="#5-1-数据锁定范围分析" class="headerlink" title="5.1 数据锁定范围分析"></a>5.1 数据锁定范围分析</h5><p>假设user表中<strong>user_id</strong>为<strong>主键(Primary Key)<strong>且为</strong>unsigned int</strong> 类型。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> user_id <span class="token operator">&lt;</span> <span class="token number">7</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        上面的操作锁定的记录范围为 user_id &gt;= 0 到 user_id = 6 的记录，只有事务提交后，其他事务才能操作该范围的记录。注意即使 user_id=3对应的记录不存在，事务没提交前，插入user_id=3记录也是不允许的，不然就没办法解决幻读问题。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> user_id <span class="token operator">></span> <span class="token number">7</span> <span class="token operator">and</span> user_id <span class="token operator">&lt;</span> <span class="token number">1000</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        上面的操作锁定的记录范围为 user_id &gt; 7 到 user_id &lt; 10000 的记录，只有事务提交后，其他事务才能操作该范围的记录。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token keyword">user</span> <span class="token keyword">where</span> user_id <span class="token operator">></span> <span class="token number">1000</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        上面的操作锁定的记录范围为 user_id &gt; 1000 到 int 最大值之间的记录，只有事务提交后，其他事务才能操作该范围的记录。</p><h4 id="6-Next-Key-Locks（临键锁）"><a href="#6-Next-Key-Locks（临键锁）" class="headerlink" title="6 Next-Key Locks（临键锁）"></a>6 Next-Key Locks（临键锁）</h4><p>​        <strong>Next-Key Locks（临键锁）</strong>是 <strong>Recod Locks（记录锁）</strong>与<strong>Gap Locks（间隙锁）</strong>的组合，它的封锁范围，既包含索引记录，又包含索引区间。同样其主要用于<strong>防止其他事务在索引记录中的间隔内部插入数据，而引起的幻读</strong>。</p><p>​        假设user表中<strong>user_id</strong>为<strong>主键(Primary Key)<strong>且为</strong>unsigned int</strong> 类型，表中已有use_id 为 3，5，6，9，1000的记录。则对user_id而言可能的Next-Key Locks（临键锁）范围有</p><ul><li>[0，3]</li><li>（3，5]</li><li>（5，9]</li><li>（9，1000]</li><li>（1000，int最大值]</li></ul><h4 id="7-Insert-Intention-Locks（插入意向锁）"><a href="#7-Insert-Intention-Locks（插入意向锁）" class="headerlink" title="7 Insert Intention Locks（插入意向锁）"></a>7 Insert Intention Locks（插入意向锁）</h4><p>​        <strong>Insert Intention Locks（插入意向锁）</strong>是间隙锁(Gap Locks)的一种，其专门针对插入操作，其能提高多个事务并发向锁区间的范围内插入不同数据的并发效率，<strong>插入意向锁提高了并发插入的效率</strong>。</p><p>​        假设user表中<strong>user_id</strong>为<strong>主键(Primary Key)<strong>且为</strong>unsigned int</strong> 类型且非自增，表中已有use_id 为 7，99，1000的记录。</p><p>​        事务A先执行，在user_id=7与user_id=99两条记录中插入了一行包含user_id = 9的记录，还未提交</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token keyword">user</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span> xxx<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        事务B后执行，也在user_id=7与user_id=99两条记录中插入了一行包含user_id = 97的记录，提交。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">insert</span> <span class="token keyword">into</span> <span class="token keyword">user</span> <span class="token keyword">values</span><span class="token punctuation">(</span><span class="token number">97</span><span class="token punctuation">,</span> xxx<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此事务A与事务B分别会加user_id=9与user_id=97的    <strong>Insert Intention Locks（插入意向锁）</strong>， 事务B不会被事务B给阻塞。</p><h4 id="8-AUTO-INC-Locks（自增锁）"><a href="#8-AUTO-INC-Locks（自增锁）" class="headerlink" title="8 AUTO-INC Locks（自增锁）"></a>8 AUTO-INC Locks（自增锁）</h4><p>​        <strong>AUTO-INC Locks（自增锁）</strong>是一种特殊的表级别锁（table-level lock），专门针对事务插入AUTO_INCREMENT类型的列。最简单的情况，如果一个事务正在往表中插入记录，所有其他事务的插入必须等待，以便第一个事务插入的行，是连续的主键值。InnoDB 提供了 <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar_innodb_autoinc_lock_mode"><code>innodb_autoinc_lock_mode</code></a> 参数用于控制AUTO-INC Locks（自增锁）。其允许选择如何在可预测的自动增量值序列和插入操作的最大并发之间进行权衡。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​        本文介绍了mysql InnoDB存储引擎中常见的锁，并通过部分示例对锁进行简要地分析。mysql InnoDB 支持不同粒度的锁，如表锁与行锁，同时支持表锁与行锁的共存。为更高效地支持不同粒度的锁，而引入<strong>Intention Locks</strong>（意向锁）。<strong>Shared and Exclusive Locks</strong>（共享与排他锁）主要是为了提高加行锁时读写的并发性。<strong>Record Locks</strong>（记录锁）用于控制带索引记录的操作性能。<strong>Gap Locks</strong>（间隙锁）+ <strong>Next-Key Locks</strong>（临键锁）避免<strong>Repeatable Read</strong>级别下面出现幻读。<strong>Intention Locks</strong>（插入意向锁）保证多个事务，在同一个索引，同一个范围区间插入记录时，如果插入的位置不冲突，不会阻塞彼此。<strong>AUTO-INC Locks</strong> （自增锁）保证同一事务中利用数据库自增ID插入数据时ID的连续性。</p><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking.html#innodb-shared-exclusive-locks">InnoDB Locking</a></p><p><a href="https://mp.weixin.qq.com/s/f4_o-6-JEbIzPCH09mxHJg">这次终于懂了，InnoDB的七种锁（收藏）</a></p><h4 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h4><p>​        原创不易，点赞、在看、转发是对我莫大的鼓励，关注公众号洞悉源码是对我最大支持。同时相信我会分享更多干货，我同你一起成长，我同你一起进步。</p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> InnoDB </tag>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文详解mysql MVCC的今世前身</title>
      <link href="/2021/10/12/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3mysql%20MVCC%E7%9A%84%E4%BB%8A%E4%B8%96%E5%89%8D%E8%BA%AB/"/>
      <url>/2021/10/12/%E4%B8%80%E6%96%87%E8%AF%A6%E8%A7%A3mysql%20MVCC%E7%9A%84%E4%BB%8A%E4%B8%96%E5%89%8D%E8%BA%AB/</url>
      
        <content type="html"><![CDATA[<h3 id="一文详解mysql-MVCC的今世前身"><a href="#一文详解mysql-MVCC的今世前身" class="headerlink" title="一文详解mysql MVCC的今世前身"></a>一文详解mysql MVCC的今世前身</h3><h4 id="1-为什么需求MVCC"><a href="#1-为什么需求MVCC" class="headerlink" title="1 为什么需求MVCC"></a>1 为什么需求MVCC</h4><p>​        MVCC全称为<a href="https://en.wikipedia.org/wiki/Multiversion_concurrency_control">Multi-Version Concurrency Control</a>（多版本并发控制），是一种数据库并发访问无锁的优化方案。其无锁优化是针对于读取时不需要加锁，其基本思路是数据库的任何修改都不会直接覆盖原来的数据，而是生成新的副本，并通过链表将新老版本副本串连，每个副本中都会包含修改数据记录的版本号，读取数据时根据版本号的对比确定链表上哪个版本的数据对当前事务可见。在该技术出现前，只有读-读之间可以并发，引入多版本控制之后，读-读、读-写、写-读都可以并发，实现读无需加锁、读写不冲突，极大提高了数据库系统的并发性。</p><p>​        在mysql InnoDB中，只有<strong>READ COMMITE</strong> 和 <strong>REPEATABLE READ</strong> 二个隔离级别下面，MVCC才会工作。READ UNCOMMITED 总读取最新版本的数据不需求MVCC进行多版本并发的控制，而SERIALIZABLE会对所有读取操作加锁，同样不需求MVCC。mysql InnoDB 存储引擎中 MVCC 机制简单的来说是通过<strong>隐式列 + undo log + read view</strong> 实现的。</p><h4 id="2-隐式列、undo-log-、-read-view、快照读和当前读"><a href="#2-隐式列、undo-log-、-read-view、快照读和当前读" class="headerlink" title="2 隐式列、undo log 、 read view、快照读和当前读"></a>2 隐式列、undo log 、 read view、快照读和当前读</h4><h5 id="2-1-隐式列"><a href="#2-1-隐式列" class="headerlink" title="2.1 隐式列"></a>2.1 隐式列</h5><p>​        InnoDB 会为第一行数据加三列，分别是<strong>DB_TRX_ID、DB_ROLL_PTR、DB_ROW_ID</strong>（ <a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-multi-versioning.html">InnoDB Multi-Versioning</a>）。</p><ul><li><p><strong>DB_TRX_ID 代表最近更新或新增该行数据事务的事务标识，也可叫事务ID(删除操作也被看作一种特殊的更新)</strong></p></li><li><p><strong>DB_ROLL_PTR 表示回滚指针，其指向当前记录上一次更新或新增操作对应的undo log，undo log 能还原数据到之前的状态</strong></p></li><li><p>**DB_ROW_ID 在无聚簇索引时 innodb内部自动创建的自增id  **</p><img src="https://gitee.com/0909/blog/raw/master/img/隐式列.png" style="zoom:80%;" /></li></ul><h5 id="2-2-undo-log"><a href="#2-2-undo-log" class="headerlink" title="2.2 undo log"></a>2.2 undo log</h5><p>​        undo log 主要有两大用途一是实现InnoDB中事务的原子性，保障已部分落盘的数据可以被回滚，另外其用于实现MVCC机制中多版本数据的变向存储。undo log 是逻辑日志，其记录了上一次操作的逆向操作。</p><img src="https://gitee.com/0909/blog/raw/master/img/20211012145919.png" style="zoom:80%;" /><h5 id="2-3-read-view"><a href="#2-3-read-view" class="headerlink" title="2.3 read view"></a>2.3 read view</h5><p>​        <a href="https://dev.mysql.com/doc/refman/5.7/en/glossary.html#glos_read_view">read veiw</a> 是InnoDB在进行快照读时产生时产生的<strong>读视图</strong>（后面介绍快照读，也叫一致性读 <strong>consistent read</strong> ）。当执行快照读时，系统会为其创建一个read view,  并通过最新数据与undo log链上数据中的DB_TRX_ID 与read view 进行比较，来决定<strong>当前事务</strong>（<strong>创建read view对应的事务</strong>）能够看到undo log上哪个版本的数据。</p><h5 id="2-4-快照读和当前读"><a href="#2-4-快照读和当前读" class="headerlink" title="2.4 快照读和当前读"></a>2.4 快照读和当前读</h5><p>​        <strong>快照读</strong></p><p>​        简单的select 语句（不包含 select … lock in share model, select … for update）都快照读。mysql官网的叫<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-consistent-read.html">consistent read</a>，因为一致性读是基于快照的，通常会叫快照读，这类读不用加读锁，而是通过**隐式列 +  undo log + read view **来获取所要的数据。快照读实际就是InnoDB中MVCC机制的实现。</p><p>​        <strong>当前读</strong></p><p>​        所有的需要加锁的涉及读取的操作（可以参考mysql官网中的<a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-locking-reads.html">innodb locking reads</a> ）如</p><ul><li>select … lock in share model</li><li>select … for update</li><li>update …</li><li>insert …</li><li>delect …</li></ul><h4 id="3-Innodb-MVCC-快照读处理流程"><a href="#3-Innodb-MVCC-快照读处理流程" class="headerlink" title="3 Innodb MVCC 快照读处理流程"></a>3 Innodb MVCC 快照读处理流程</h4><p>​        通过前面简单的介绍已了解到快照读实际就是InnoDB中MVCC机制的实现。现在来看一下MVCC快照读的整体处理流程。快照读时数据可见的判断依赖于ReadView 这个数据结构，其包含关键属性如下。</p><ul><li><strong><code>m_ids</code></strong> 当前快照被创建时，活跃（已启动但未提交）的事务集合。</li><li><strong><code>m_low_limit_id</code></strong> 高水位，当前系统中的事务的最大ID值加一，即下一个开启的事务的ID。</li><li><strong><code>m_up_limit_id</code></strong>  低水位，当前活跃事务的最小ID，小于该ID的事务都是已经提交的事务。</li><li><strong><code>m_creator_trx_id</code></strong> 创建该read view的事务ID。</li></ul><img src="https://gitee.com/0909/blog/raw/master/img/事务ReadView1.png" style="zoom:80%;" /><p>​        InnoDB在处理快照读（consistent read 一致性读时），只要拿出数据中的DB_TRX_ID（隐式列中最近更新或新增该行数据事务的事务标识，事务ID）然后与ReadView中的m_ids、m_low_limit_id、m_up_limit_id、m_creator_trx_id进行比较，就可确定当前版本的数据对ReadView读视图是否可见。处理算法大体流程如下：</p><p>**1、如果DB_TRX_ID = m_creator_trx_id, DB_TRX_ID 对应数据对当前事务可见，表示这条数据是由当前事务m_creator_trx_id 创建的。 **</p><p><strong>2、DB_TRX_ID ≥ m_low_limit_id （高水位）， DB_TRX_ID 对应数据对当前事务不可见，表示这条数据是由将来的事务更新的。</strong></p><p><strong>3、DB_TRX_ID &lt; m_up_limit_id （低水位） ，DB_TRX_ID 对应数据对当前事务可见，表示这条数据是由已经提交的事务更新的。</strong></p><p><strong>4、DB_TRX_ID 介于高水位与低水位之间，如果DB_TRX_ID在m_ids（活跃事务集合）中，表示尚未提交的事务， DB_TRX_ID 对应数据对当前事务不可见;  如果DB_TRX_ID不在m_ids（活跃事务集合）中，表示事务已经提交了， DB_TRX_ID 对应数据对当前事务可见。</strong></p><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><p><a href="https://dev.mysql.com/doc/refman/5.7/en/innodb-storage-engine.html">The InnoDB Storage Engine</a></p><p><a href="https://github.com/mysql/mysql-server/blob/5.7/storage/innobase/include/read0types.h">mysql5.7 ReadView 源码</a></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> MVCC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统下面业务操作幂等的必要性</title>
      <link href="/2021/10/01/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%9D%A2%E4%B8%9A%E5%8A%A1%E6%93%8D%E4%BD%9C%E5%B9%82%E7%AD%89%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/"/>
      <url>/2021/10/01/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%9D%A2%E4%B8%9A%E5%8A%A1%E6%93%8D%E4%BD%9C%E5%B9%82%E7%AD%89%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="幂等性的常见实现方法"><a href="#幂等性的常见实现方法" class="headerlink" title="幂等性的常见实现方法"></a>幂等性的常见实现方法</h3><h4 id="1-为什么分布式系统要求业务操作的幂等性"><a href="#1-为什么分布式系统要求业务操作的幂等性" class="headerlink" title="1 为什么分布式系统要求业务操作的幂等性"></a>1 为什么分布式系统要求业务操作的幂等性</h4><p>幂等（idempotent）的概念源于数学，幂等的特点是任意多次执行所产生的影响均与一次执行产生的影响相同，不会因为多次的操作产生别的副作用。分布式系统由多个系统与节点组成，系统与节点在进行通信时由于网络、系统或节点的不稳定性导致一次系统与系统之间接口调用结果的三态，成功、失败、未知（请求已发出，但出现超时返回异常，此时下游系统可能已处理成功也可能处理失败）。系统在处理未知状态的调用结果时，通常会通过定时任务进行重试，这也就导致了位于下游的系统其接口可能会被相同的请求重复调用多次的情况。如果分布式系统没有保证各业务操作的幂等，必然导致由于多次相同操作带来的业务副作用（用户同一笔订单支付了多次，用户收到多条相同的发货通知、商品下面展示了多条用户同一时间的相同评论记录）。</p><h4 id="2-实现业务操作幂等性的常用方法"><a href="#2-实现业务操作幂等性的常用方法" class="headerlink" title="2 实现业务操作幂等性的常用方法"></a>2 实现业务操作幂等性的常用方法</h4><h5 id="2-1-业务Token"><a href="#2-1-业务Token" class="headerlink" title="2.1 业务Token"></a>2.1 业务Token</h5><p>​        业务Token通常的作法是在请求实际的业务操作前先去获取对应的业务Token，下游业务根据请求参数与时间生成Token，然后将Token写入缓存并设置一定的过期时间。真正发起业务请求时，请求发起方会将业务Token加入到请求参数中。下游业务收到业务请求后会先判段缓存中Token是否存在，如果存在则删除缓存中的业务Token并执行业务逻辑，如果不存则直接返回错误。<strong>这种做法实际是防重而非真正意思上的幂等</strong>。</p><img src="https://gitee.com/0909/blog/raw/master/img/幂等.png" style="zoom:80%;" /><p>​        <strong>方案优点、缺点、合适业务场景</strong>：业务Token方案整体实现简单，但实际为防重策略，Token过期时间要根据业务情况去确定。对于新增数据的业务场景比较适合，比如用户在支付订单前，在进入支付订单页面时交易系统可以先根据用户与订单的信息从支付系统获取业务Token，然后在支付时再将支付信息、订单信息、业务Token一起传给支付系统，支付系统再去校验业务Token，存在则调用支付渠道执行支付逻辑，不存在直接返回支付失败。</p><h5 id="2-2-乐观锁-状态机或版本号"><a href="#2-2-乐观锁-状态机或版本号" class="headerlink" title="2.2 乐观锁 + 状态机或版本号"></a>2.2 乐观锁 + 状态机或版本号</h5><p>​        乐观锁+状态机或版本号，通常的作法是在执行业务逻辑时将对应的SQL加上乐观锁，SQL的条件一般是有现在状态或版本号。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">update</span> <span class="token keyword">order</span> <span class="token keyword">set</span> order_status <span class="token operator">=</span> ${next_status} <span class="token keyword">where</span> order_status <span class="token operator">=</span> ${current_status}<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>有些场景也会直接通过版本号使用乐观锁。</p><pre class="line-numbers language-sql"><code class="language-sql"><span class="token keyword">update</span> post_detail <span class="token keyword">set</span> title <span class="token operator">=</span> ${title}<span class="token punctuation">,</span> content <span class="token operator">=</span> ${content}<span class="token punctuation">,</span> version <span class="token operator">=</span> ${current_version} <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">where</span> version <span class="token operator">=</span> ${current_version}<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>​        <strong>方案优点、缺点、合适业务场景</strong>：实现简单，不依赖外部系统，效率高，但不适合新增数据的业务场景只适合数据更新场景。这种方式不仅适合处理并发请求量很大的场景同时，同时适时一些请求量很小的场景。比如一些运营后台。</p><img src="https://gitee.com/0909/blog/raw/master/img/version.png" style="zoom:80%;" /><p>​        多运营人员同时操作一内容导致，最后运营人员A以为最终内容是title为t2，content为c1，运营人员B以为最终内容是title为t1，content为c2。而实际数据库中的数据为运营人员A与运营人员B操作的之和，<strong>还有一种可能是运营人员B直接把运营人员A的操作内容给覆盖了</strong>，再运营人员B与A完全不知情时。这种场景更好的处理方式是通过乐观锁+版本号。直接让后继的操作运营人员感知，之前的内容以被修改。</p><img src="https://gitee.com/0909/blog/raw/master/img/fail_with_version.png" style="zoom:80%;" /><h5 id="2-3-悲观锁"><a href="#2-3-悲观锁" class="headerlink" title="2.3 悲观锁"></a>2.3 悲观锁</h5><p>​        悲观锁实现分为单进程与多进程。单进程要么是在应用层加锁要么是在BD层面加锁。应用层加锁Java语言中可以通过synchronize关键字或是并发包下面的Lock子类实现。BD层面加锁可以采用select for update实现，但要避免锁表的情况。多进程场景的话要通过分布式锁来实现，主流的实现思路有Redis,  Zookeeper。Redis实现上可以直接使用Redisson实现的RedLock。Zookeeper可以通过其watch机制实现分布式锁。</p><p>​        <strong>方案优点、缺点、合适业务场景</strong>：悲观锁应该是在没有其他合适方案时才会采取的兜底方案。悲观锁会降低系统整体的并发量。采用select for update 能保证BD层面数据的一致性，但存在锁表的风险。                    </p><h5 id="2-4-去重表-唯一索引"><a href="#2-4-去重表-唯一索引" class="headerlink" title="2.4 去重表(唯一索引)"></a>2.4 去重表(唯一索引)</h5><p>​        去重表的实现思路是请求自身带唯一的ID，或是根据请求参数与时间等特性生成唯一的ID，下游服务在处理请求时，先将唯一ID插入去重表中(唯一ID是去重表的唯一索引)，成功则执行业务逻辑，DB层面抛出DuplicateKeyException时则直接返回失败或是检索历史处理结果返回。去重表（唯一索引）非常<strong>适合处理MQ消费消息场景时的幂等性问题。通常MQ都不会保证消息投递的唯一性，下游在消费消息时一定要根据业务场景的不同考虑是否要保证消费消息的幂等性</strong>。</p><h4 id="3-业务场景分析"><a href="#3-业务场景分析" class="headerlink" title="3 业务场景分析"></a>3 业务场景分析</h4><p>​        实际的业务场景中通常会结合多种方式来保证业务操作的幂等性。下面简要的介绍一下支付业务场景的幂等实现。</p><h5 id="3-1-支付业务场景"><a href="#3-1-支付业务场景" class="headerlink" title="3.1 支付业务场景"></a>3.1 支付业务场景</h5><p><img src="https://gitee.com/0909/blog/raw/master/img/%E6%94%AF%E4%BB%98%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86.png" alt="支付流程"></p><p>​        上面是用户支付订单场景时业务系统、支付中心、支付通道之间整体交互的时序图（同业务应用APP与业务服系统交互部分统一划到业务系统/应用，同支付通道与支付通道APP交互部分统一划到支付通道）。 整个流程可分为三大步 <strong>一、用户发起订单支付进入收银台 ，二、用户选定支付产品，确认支付 ，三、应用通过SDK调用支付通道，展示支付结果。</strong>这三大步中业务系统与支付中心交互的接口共有三个分别是<strong>统一下单接口（createPayOrder 1.2步）、支付接口（pay 2.3步）、支付结果查询接口（queryPayResult 3.3 步）</strong>。在整体流程中业务系统与支付中心比较重要的数据模型有<strong>业务订单（业务系统）、支付订单（支付中心）、支付流水单（支付中心），比较重要的状态有业务订单支付状态、支付订单支付状态、支付流水支付状态。业务订单支付状态：待支付、支付中、支付成功、支付失败，支付订单支付状态：待支付、支付中、支付成功、支付失败，支付流水支付状态：待支付、支付中、支付成功、支付失败。</strong></p><p><strong>一、统一下单接口（createPayOrder）幂等</strong></p><p>​       用户从业务APP订单页面，点击去支付会进入收银台页面。<strong>在实现每次进入收银台页面前或是重新切换到收银台页面，业务APP实际会先根据业务订单号调用支付结果查询接口，如果已支付成功则提示不能重复支付，后跳会之前的页面。</strong> 支付中心的统一下单接口（createPayOrder）会根据业务标识与业务订单号去创建支付订单并返回支付单号。实际上业务系统在获取收银支付产品列表时支付系统内会调统一下单接口（createPayOrder）。如果在这个过程中发面支付中心已存在对应订单号的支付订单且支付状态为支付成功，则不会返回支付产品列表，而且提示该订单已支付成功。<strong>统一下单接口（createPayOrder）通过支付订单表中业务标识与业务订单组成的唯一锁引防重与处理幂等。</strong></p><img src="https://gitee.com/0909/blog/raw/master/img/支付统一下单幂等.png" style="zoom:80%;" /><p><strong>二、支付接口（pay ）幂等</strong></p><p>​        用户进入收银台页面后，选中某一支付产品后，点击确认支付时。业务APP实际会通过业务系统调用支付中心的支付接口(pay)。支付中心内部会根据支付单号、支付产品编码去创建支付流水，并根据支付产吕编码调用支付通道统一下单接口返回预支付标识，支付中心再根据不同的支付通道组装并加密支付参数，然后返回给业务APP，APP根据返回的支付参数通过SDK调对应支付通道的支付方法。</p><p>​        </p><img src="https://gitee.com/0909/blog/raw/master/img/支付接口幂等.png" style="zoom:80%;" /><p>上面整体流程上有几点要注意：</p><p>​        <strong>1、为了降低用户重复支付的概率，支付中心应该对支付订单进行锁单，业务系统第一次调pay支付接口后用支付中心会用支付单号对支付订单进行锁单，同时会设置一个较短的释放时间如2s，当用户频繁操作时如果支付订单处理锁单状态直接提示用户操作过于频繁请误重复支付。</strong></p><p>​        <strong>2、在创建支付流水前要检查支付流水记录中否存在同一支付单号的其他支付中的支付流水，如果存在要支付中心应主动调用对应支付通道支付结果查询接口进行处理。如果支付通道侧返回支付成功，则提用户请误重复支付。</strong></p><p>​        <strong>3、按上面的流程处理还是可以出现重复支付的情况，在支付单未被锁单或之前的锁单已释放后，可能出现用户多次支付的情况。当同一支付单号有多笔支付状态为支付成功的支付流水时，应做相应的原路退款处理。</strong></p><p>​        <strong>4、在用户支付的过程中，如果业务订单刚好超时自动关闭，最终导致业务系统无法正常处理支付中心支付成功的消息，对这种特殊情况一定要做好处理。</strong></p><p><strong>三、支付结果查询接口（queryPayResult ）幂等</strong></p><p>​        支付结果查询接口，主要用于业务则APP在SDK调用支付通道支付接口后，并同步收到支付结果，后进行主动查询当前业务订单是否支付成，并展示对应的支付结果给用户。</p><img src="https://gitee.com/0909/blog/raw/master/img/支付结果查询接口幂等.png" style="zoom:80%;" /><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​        本文简要地总结了常见的处理幂等手段与其适用的场景，这些处理手段的本质共性可归纳为<strong>让请求串行或唯一化，某一时间只处一请求</strong>。<strong>悲欢锁实际是在让请求串行化，业务Token、乐观锁 + 状态机或版本号、去重表(唯一索引)实际是在让请求唯一化</strong>。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://it.deepinmind.com/distributed/2019/06/30/avoiding-double-payments-in-a-distributed-payments-system.html">Avoiding Double Payments in a Distributed Payments System</a></p><p><a href="https://www.codenong.com/js93dfce882bf5/">Airbnb支付系统如何在分布式环境下避免重复打款</a></p><p><a href="https://tech.meituan.com/2016/09/29/distributed-system-mutually-exclusive-idempotence-cerberus-gtis.html">分布式系统互斥性与幂等性问题的分析与解决</a></p><p><a href="https://mp.weixin.qq.com/s/9Z-N3cfWu7oMVJsTDkbb-Q">基于有限状态机与消息队列的三方支付系统补单实践</a></p><p><a href="https://www.jianshu.com/p/2c8cf162cf62">第三方支付微服务幂等设计</a></p>]]></content>
      
      
      <categories>
          
          <category> 分布式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 幂等 </tag>
            
            <tag> 支付 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存常见风险(缓存穿透、缓存击穿、缓存雪崩、缓存污染)与应对方法</title>
      <link href="/2021/09/06/%E7%BC%93%E5%AD%98%E5%B8%B8%E8%A7%81%E9%A3%8E%E9%99%A9(%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93)%E4%B8%8E%E5%BA%94%E5%AF%B9%E6%96%B9%E6%B3%95/"/>
      <url>/2021/09/06/%E7%BC%93%E5%AD%98%E5%B8%B8%E8%A7%81%E9%A3%8E%E9%99%A9(%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E3%80%81%E7%BC%93%E5%AD%98%E6%B1%A1%E6%9F%93)%E4%B8%8E%E5%BA%94%E5%AF%B9%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="缓存常见风险-缓存穿透、缓存击穿、缓存雪崩、缓存污染-与应对方法"><a href="#缓存常见风险-缓存穿透、缓存击穿、缓存雪崩、缓存污染-与应对方法" class="headerlink" title="缓存常见风险(缓存穿透、缓存击穿、缓存雪崩、缓存污染)与应对方法"></a>缓存常见风险(缓存穿透、缓存击穿、缓存雪崩、缓存污染)与应对方法</h3><h4 id="1-缓存穿透"><a href="#1-缓存穿透" class="headerlink" title="1 缓存穿透"></a>1 缓存穿透</h4><p>​ 缓存穿透是指由于请求要获取的数据不在实际的数据源中（数据库），导致每次请求都会穿透缓存，直接落在实际的数据源（数据库）上。这类请求使得缓存层无法缓解真实数据源上的 CUP 或 I/O 压力，最终使得服务可用性与稳定性下降。产生这类问题通常是业务逻辑本身不合理或存在问题，或者可能是被恶意攻击。解决缓存穿透常用的方法有下面三种。</p><h5 id="1-1-接口校验"><a href="#1-1-接口校验" class="headerlink" title="1.1 接口校验"></a>1.1 接口校验</h5><p>​ 正常业务流程中可能会存在少量访问不存在 key 的情况，如果有但的不存 key 的情况，很有可能系统遭受了恶意的攻击。对应这种问题有效的方法之一就是在服务调用的最外层对基本的数据合法性、用户访问权限进行校验。例如对于商品查询中，商品 ID 通过是正整数，对于负数业务层可以直接返回参数非法。</p><h5 id="1-2-存储空值-业务合适的默认值"><a href="#1-2-存储空值-业务合适的默认值" class="headerlink" title="1.2 存储空值/业务合适的默认值"></a>1.2 存储空值/业务合适的默认值</h5><p>​ 虽然数据源（数据库）中，没有请求所要的数据，但可以考虑缓存空值或是业务合适的默认值来便向处理该问题。这么做要注意两点：<strong>一对应的缓存值要约定一个比较短的过期时间，使得一段时间内缓存最多被击穿一次。</strong> <strong>二后继业务在数据中新增了该 key 对应的数据，那应当在插入之后主动清理掉缓存的 Key 值。</strong></p><h5 id="1-3-布隆过滤器（Bloom-Filter）"><a href="#1-3-布隆过滤器（Bloom-Filter）" class="headerlink" title="1.3 布隆过滤器（Bloom Filter）"></a>1.3 布隆过滤器（Bloom Filter）</h5><p>​ 对于恶意攻击导致的缓存穿透，通常会在缓存之前设置一个布隆过滤器来解决。这类恶意攻击者通常会刻意制造数据库中肯定不存在的 key 值，然后发送大量的请求。布隆过滤器可以将不存在的 key 值拦截在缓存层之外，让到达缓存层的流量，几乎在数据源（数据库）中都是存在 key 值的。布隆过滤器由一个 bitSet 和 一组 Hash 函数（算法）组成，是一种空间效率极高的概率型算法和数据结构，主要用来判断一个元素是否在集合中存在。通常会将数据源（数据库）中存在的 key 值全量放入布隆过滤器中。如果请求的 key 值布隆过滤器中找不到，那么将直接返回，这类 key 值在源数据源（数据库中）中一定不存在，但<strong>要注意请求的 key 在布隆过滤器中，也有可以最后 key 值在数据源中找不到</strong>，因为布隆过滤器可能存在漏判的情况，但经过多次 hash 后这种情况的概率通常会很低。下面给一个误判示例。</p><img src="https://gitee.com/0909/blog/raw/master/img/bloomfilter.png" alt="bloomfilter" style="zoom:80%;" /><p>如上图，假设数据库中有 a 和 b 两条记录，通过布隆过滤器的 h1、h2、h3 三个散列函数得到 bitset 的位下标然后标记为 1，最后 a 与 b 两条记录在布隆过滤器中保存成功。然后查询请求要获取值为 c 的记录。c 虽然没有在数据库中但由于 c 的 h1(c)、h2(c)、h3(c) ,分别已数据 a 和 b 两条记录的 h2(a)、h1(b)、h3(a)值相同，最终导致误判。<strong>注意布隆过滤器有一个比较大的弊端就是存在其中的数据不支持删除。那么如果有数据要从隆过滤器剔除应该如何处理呢，剔除了又要存回隆过滤器该如何处理？</strong> 如果删除频率比较低且数据量少的话，可以用一个 HashMap 维护删除的记录，用于标记其不在隆过滤器内。请求时先走一下 HashMap，再走隆过滤器。那如果删除频率比较高且数据量很大的话，使用 HashMap 就不合适了。这个问题就先放这里吧。_ v _</p><h4 id="2-缓存击穿"><a href="#2-缓存击穿" class="headerlink" title="2 缓存击穿"></a>2 缓存击穿</h4><p>​ 缓存击穿是指由于某种原因缓存中的数据已失效（如缓存过期），而此时有大量的请求来获取该数据，最终由于缓存中没有数据，所有请求都落在实际的数据源（数据库）上。通常热点 key 的失效，容易导致缓存击穿。</p><h5 id="2-1-热点数据管理"><a href="#2-1-热点数据管理" class="headerlink" title="2.1 热点数据管理"></a>2.1 热点数据管理</h5><p>​ 热点数据由代码来手动管理，缓存击穿是仅针对热点数据被自动失效才引发的问题，对于这类数据，可以直接由开发者通过代码来有计划地完成更新、失效，避免由缓存的策略自动管理。极端情况可能设置热点永不过期。</p><h5 id="2-2-加锁同步"><a href="#2-2-加锁同步" class="headerlink" title="2.2 加锁同步"></a>2.2 加锁同步</h5><p>​ 以请求该数据的 Key 值为锁，使得只有第一个请求可以流入到真实的数据源中，其他线程采取阻塞或重试策略。当第一个请求从数据源中获取到数据后，在将数据写入到缓存中。如果是进程内缓存出现问题，施加普通互斥锁即可，如果是分布式缓存中出现的问题，就施加分布式锁，这样数据源就不会同时收到大量针对同一个数据的请求了。下面给出伪代码的实现，这里没有区分进程内的情况与分布式的情况。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getData</span><span class="token punctuation">(</span>String key<span class="token punctuation">)</span>  <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//从缓存中获取数据</span>    String data <span class="token operator">=</span> <span class="token function">getDataFromCache</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//缓存中存在数据直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> data<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//尝试获取锁，并成功</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lock<span class="token punctuation">.</span><span class="token function">tryLock</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//再次尝试从缓存中获取数据</span>            data <span class="token operator">=</span> <span class="token function">getDataFromCache</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//缓存中存在数据直接返回</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> data<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//从DB中获取数据</span>            data <span class="token operator">=</span> <span class="token function">getDataFromDB</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//数据存在设置缓存</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">setCache</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> data<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 释放获取到的锁</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//尝试获取锁，但失败。线程sleep 100毫秒后，再次调用获取数据方法。</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">getData</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-缓存雪崩"><a href="#3-缓存雪崩" class="headerlink" title="3 缓存雪崩"></a>3 缓存雪崩</h4><p>​ 缓存击穿是针对单个热点数据失效，由大量请求击穿缓存而给真实数据源带来压力。而缓存雪崩侧是由于大量不同数据在短时间内一起失效，导致这些数据对应的大量请求在缓存层上无法命中，直接达到了真实的数据源，最终导致数据源在短时间内压力剧增。通常这种情况产生的原因有两种，一是由于缓存服务因某些原因崩溃后重启，此时也会造成大量数据同时失效;另外一种是由于大量公共数据从一次操作加载的，这样都可能出现由此载入缓存的大批数据具有相同的过期时间，在同一时刻一起失效。</p><h5 id="3-1-增强缓存层可用性"><a href="#3-1-增强缓存层可用性" class="headerlink" title="3.1 增强缓存层可用性"></a>3.1 增强缓存层可用性</h5><p>​ 为了避免由于缓存层自崩溃后重启，大量请求导致缓存雪崩。缓存层应集群化部署，同时缓存系统前应该做相应的流量控制，超过阈值部分的流量直接丢弃或者先缓存在 MQ 中（流量高风过后在逐步处理请求）。</p><h5 id="3-2-分散缓存过期时间"><a href="#3-2-分散缓存过期时间" class="headerlink" title="3.2 分散缓存过期时间"></a>3.2 分散缓存过期时间</h5><p>​ 为了避免大量热点数据在某个时间段内集中失效，我们在在设置失效时间时可以在原时间的基础上加上或者减去一个范围内的随机值。比如原本是一个小时过期，在缓存不同数据时，设置生存期为 55 分钟到 65 分钟之间的某个随机时间。</p><h4 id="4-缓存污染"><a href="#4-缓存污染" class="headerlink" title="4 缓存污染"></a>4 缓存污染</h4><p>​ 所谓的缓存污染是指缓存中的数据与真实数据源中的数据不一致的情况。虽然缓存通常不追求强一致性，但这我们应当最大程度上保证缓存中的数据与真实数据源中的数据一致，并通过某种手段保证数据的最终的一致性。</p><p>​ 缓存污染大多数是由开发者更新缓存不规范造成的，比如执行某类业务操作，先更新了缓存中某些值，然后再执行业务逻辑更新数据源中的数据，但由于某些原因（后继业务发生异常回滚了）最终没有成功写入到数据源，此时缓存的数据是新的，而数据源中的数据却是旧的。<strong>另外一种常见的不规范的操作是先更新 BD，再更新缓存</strong>。</p><img src="https://gitee.com/0909/blog/raw/master/img/updateCacheInvalid.png" alt="错误更新缓存" style="zoom:80%;" /><p>​ 时间轴的顺是 T1、T2、T3、T4、T5，执行的业务逻辑分别是进程 A 更新 DB 数据 V 为 1、进程 B 更新 DB 数据 V 为 2、进程 B 更新缓存数据 V 为 2、进程 A 更新缓存数据 V 为 1、进程 C 读取缓存数据 V 为 1。可以看到 DB 中数据 V 对应的实际为 2，而缓存中存储的值为进程 A 更新的值 1，最终导致进程 C 读取到的缓存数据 V 的值为 1，该值与数据库中 V 的真实值不一致。</p><p>​ 为了提高数据的最终一致性，业界提出了很多缓存更新的模式，如 Read/Write Through、Write Behind Caching 、 Cache Aside 等。</p><h5 id="4-1-Read-Write-Through"><a href="#4-1-Read-Write-Through" class="headerlink" title="4.1 Read/Write Through"></a>4.1 Read/Write Through</h5><p>​ Read/Write Through 简单的来讲就是通过读写来去更新缓存，而真实数据源层对业务操作来说是透明的，这样种模式的个显著特点就是业务代码与缓存、真实数据源之间的耦合度低，代码简洁。但缓存层要单独去实现与维护。</p><p>​ Read Through 业务层直接从缓存中读取数据，不关心缓存中数据获取的逻辑。</p><img src="https://gitee.com/0909/blog/raw/master/img/Cache-Read-through.png" alt="Cache-Read-through" style="zoom:80%;" /><p>​ Write Through 写缓存与真实数据源在同一个事务中执行，要么同时成功要么同时失败。这样一定程度上增加了请求处理的时间，但保证了缓存与真实数据源中数据的一致性。</p><img src="https://gitee.com/0909/blog/raw/master/img/Cache-Write-through.png" alt="Cache-Write-through" style="zoom:80%;" /><h5 id="4-2-Write-Behind-Caching"><a href="#4-2-Write-Behind-Caching" class="headerlink" title="4.2 Write Behind Caching"></a>4.2 Write Behind Caching</h5><p>​ Write Behind Caching 是指先写缓存，然后再按一定的策略去更新真实数据源。可以同步刷新、也可以是异步刷新。对于一些大批量写的业务场景，该模式能极大<strong>提高系统处理能力、降低系统的延时性</strong>。该模式的缺点是<strong>可能导致缓存中的数据与真实数据源中的数据不一致</strong>。Write Behind Caching 内部可以将这些批量操作在缓存中做一定的聚合，然后再按某种策略写到真实的数据源中。这种模式 Write Behind Caching 与 Write Through 共同点是缓存层与真实数据源之间的交互对应业务层面来说都是透明的。与 Write Through 对比能发现该模式适合<strong>处理大批量的写操作，同时允许存在一定的数据不一致性的业务场景</strong>，比如非关键业务的日志处理。</p><h5 id="4-3-Cache-Aside"><a href="#4-3-Cache-Aside" class="headerlink" title="4.3 Cache Aside"></a>4.3 Cache Aside</h5><p>​ 该模式简单同时实现成本低，而且能较好的保证数据一致性。其获取数据整体流程可以分为以下几步：</p><p>1、业务层请求获取某个 key 对应的数据。</p><p>2、业务层检查缓存中是否存在请求 key 对应的值。如果缓存存在（缓存命中），从缓存中拿出对应值，如果缓存不存在先再从实际数据源（数据库）中获取对应的数据，在将数据写入缓存中。</p><p>3、业务层返回 key 对应的值。</p><img src="https://gitee.com/0909/blog/raw/master/img/cache-aside.png" alt="cache-aside" style="zoom:80%;" /><p>其更新流程总体可分为以下步骤：</p><p>1、业务层更新数据源（数据库）对应的数据。</p><p>2、如果更新数据源（数据库）中的数据成功，设置缓存层数据失效。</p><p>注意<strong>第二步骤中如果更新数据源（数据库）中的数据成功，接着是要让缓存层数据失效，而不是去更新缓存中的数据</strong>。前面已分析了先更新数据源（数据库）再更新缓存可能导致的数据不一致问题。<strong>那么是不是遵循 Cache Aside 的模式处理数据就不会存在数据不一致性的问题呢？</strong>实际上还是有数据还是有可能存在不一致只是这种情况的概率很小。</p><img src="https://gitee.com/0909/blog/raw/master/img/cache-aside-fail.png" style="zoom:80%;" /><p>时间轴的顺是 T1、T2、T3、T4、T5、T6，执行的业务逻辑分别是进程 A 获取缓存数据 V 不存在、进程 A 获取 DB 中数据 V 为 1、进程 B 更新 DB 数据 V 为 2、进程 B 设置数据 V 缓存失效、进程 A 设置缓存数据 V 为 1、进程 C 读取缓存数据 V 为 1。可以看到 DB 中数据 V 对应的实际为 2，而缓存中存储的值为进程 A 更新的值 1，最终导致进程 C 读取到的缓存数据 V 的值为 1，该值与数据库中 V 的真实值不一致。但这种情况的概率很小，理论上进程 B 在执行更新 DB 数据 V 为 2 与进程 B 设置数据 V 缓存失效两步（操作 DB 与操作缓存）所要花费的时间运大于进程 A 设置缓存数据 V 为 1（操作缓存）时间。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​ 本文总结了缓存常见风险(缓存穿透、缓存击穿、缓存雪崩、缓存污染)与应对方法。跟这个话题相关的文章应该是到处都是，而且面试也经常会被问到，但个人觉得很多东西还是要系统性地去总结一下，然后再总结的过程中去更多的思考一些自己平时忽视的关键性点。这些关键性点往往也是别人容易忽视的。在写总结性文章时不能去找出一些关键性点意义可能就没那么大了。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://catsincode.com/caching-strategy/">Caching Strategies Overview</a></p><p><a href="http://icyfenix.cn/architect-perspective/general-architecture/diversion-system/cache-middleware.html#%E7%BC%93%E5%AD%98%E9%A3%8E%E9%99%A9">缓存风险</a></p><p><a href="https://coolshell.cn/articles/17416.html">缓存更新的套路</a></p>]]></content>
      
      
      <categories>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 缓存 </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
